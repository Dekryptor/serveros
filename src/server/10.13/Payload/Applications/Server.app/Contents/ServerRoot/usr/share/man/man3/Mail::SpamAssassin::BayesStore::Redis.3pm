.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SpamAssassin::BayesStore::Redis 3"
.TH Mail::SpamAssassin::BayesStore::Redis 3 "2016-06-09" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SpamAssassin::BayesStore::Redis \- Redis Bayesian Storage Module Implementation
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module implementes a Redis based bayesian storage module.
.PP
Apache SpamAssassin v3.4.0 introduces support for keeping
a Bayes database on a Redis server, either running locally, or accessed
over network. Similar to \s-1SQL\s0 backends, the database may be concurrently
used by several hosts running SpamAssassin.
.PP
The current implementation only supports a global Bayes database, i.e.
per-recipient sub-databases are not supported. The Redis 2.6.* server
supports access over IPv4 or over a Unix socket, starting with Redis 
version 2.8.0 also IPv6 is supported. Bear in mind that Redis server only 
offers limited access controls, so it is advisable to let the Redis server 
bind to a loopback interface only, or to use other mechanisms to limit 
access, such as local firewall rules.
.PP
The Redis backend for Bayes can put a Lua scripting support in a Redis
server to good use, improving performance. The Lua support is available
in Redis server since version 2.6.  In absence of a Lua support, the Redis
backend uses batched (pipelined) traditional Redis commands, so it should
work with a Redis server version 2.4 (untested), although this is not
recommended for busy sites.
.PP
Expiration of token and 'seen' message id entries is left to the Redis
server. There is no provision for manually expiring a database, so it is
highly recommended to leave the setting bayes_auto_expire to its default
value 1 (i.e. enabled).
.PP
Example configuration:
.PP
.Vb 5
\&  bayes_store_module  Mail::SpamAssassin::BayesStore::Redis
\&  bayes_sql_dsn       server=127.0.0.1:6379;password=foo;database=2
\&  bayes_token_ttl 21d
\&  bayes_seen_ttl   8d
\&  bayes_auto_expire 1
.Ve
.PP
A redis server with a Lua support (2.6 or higher) is recommended
for performance reasons.
.PP
The bayes_sql_dsn config variable has been hijacked for our purposes:
.PP
.Vb 1
\&  bayes_sql_dsn
\&
\&    Optional config parameters affecting a connection to a redis server.
\&
\&    This is a semicolon\-separated list of option=value pairs, where an option
\&    can be: server, password, database. Unrecognized options are silently
\&    ignored.
\&
\&    The \*(Aqserver\*(Aq option specifies a socket on which a redis server is
\&    listening. It can be an absolute path of a Unix socket, or a host:port
\&    pair, where a host can be an IPv4 or IPv6 address or a host name.
\&    An IPv6 address must be enclosed in brackets, e.g. [::1]:6379
\&    (IPv6 support in a redis server is available since version 2.8.0).
\&    A default is to connect to an INET socket at 127.0.0.1, port 6379.
\&
\&    The value of a \*(Aqpassword\*(Aq option is sent in an AUTH command to a redis
\&    server on connecting if a server requests authentication. A password is
\&    sent in plain text and a redis server only offers an optional rudimentary
\&    authentication. To limit access to a redis server use its \*(Aqbind\*(Aq option
\&    to bind to a specific interface (typically to a loopback interface),
\&    or use a host\-based firewall.
\&
\&    The value of a \*(Aqdatabase\*(Aq option can be an non\-negative (small) integer,
\&    which is passed to a redis server with a SELECT command on connecting,
\&    and chooses a sub\-database index. A default database index is 0.
\&
\&    Example: server=localhost:6379;password=foo;database=2
\&
\&  bayes_token_ttl
\&
\&    Controls token expiry (ttl value in SECONDS, sent as\-is to Redis)
\&    when bayes_auto_expire is true. Default value is 3 weeks (but check
\&    Mail::SpamAssassin::Conf.pm to make sure).
\&
\&  bayes_seen_ttl
\&
\&    Controls \*(Aqseen\*(Aq expiry (ttl value in SECONDS, sent as\-is to Redis)
\&    when bayes_auto_expire is true. Default value is 8 days (but check
\&    Mail::SpamAssassin::Conf.pm to make sure).
.Ve
.PP
Expiry is done internally in Redis using *_ttl settings mentioned above,
but only if bayes_auto_expire is true (which is a default).  This is
why \-\-force\-expire etc does nothing, and token counts and atime values
are shown as zero in statistics.
.PP
\&\s-1LIMITATIONS:\s0 Only global bayes storage is implemented, per-user bayes is
not currently available. Dumping (sa-learn \-\-backup, or \-\-dump) of a huge
database may not be possible if all keys do not fit into process memory.
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
public class (Mail::SpamAssassin::BayesStore::Redis) new (Mail::Spamassassin::Plugin::Bayes \f(CW$bayes\fR)
.PP
Description:
This methods creates a new instance of the Mail::SpamAssassin::BayesStore::Redis
object.  It expects to be passed an instance of the Mail::SpamAssassin:Bayes
object which is passed into the Mail::SpamAssassin::BayesStore parent object.
.SS "prefork_init"
.IX Subsection "prefork_init"
public instance (Boolean) prefork_init ();
.PP
Description:
This optional method is called in the parent process shortly before
forking off child processes.
.SS "spamd_child_init"
.IX Subsection "spamd_child_init"
public instance (Boolean) spamd_child_init ();
.PP
Description:
This optional method is called in a child process shortly after being spawned.
.SS "tie_db_readonly"
.IX Subsection "tie_db_readonly"
public instance (Boolean) tie_db_readonly ();
.PP
Description:
This method ensures that the database connection is properly setup and working.
.SS "tie_db_writable"
.IX Subsection "tie_db_writable"
public instance (Boolean) tie_db_writable ()
.PP
Description:
This method ensures that the database connection is properly setup and
working. If necessary it will initialize the database so that they can
begin using the database immediately.
.SS "_open_db"
.IX Subsection "_open_db"
private instance (Boolean) _open_db (Boolean \f(CW$writable\fR)
.PP
Description:
This method ensures that the database connection is properly setup and
working.  It will initialize bayes variables so that they can begin using
the database immediately.
.SS "untie_db"
.IX Subsection "untie_db"
public instance () untie_db ()
.PP
Description:
Closes any open db handles.  You can safely call this at any time.
.SS "sync_due"
.IX Subsection "sync_due"
public instance (Boolean) sync_due ()
.PP
Description:
This method determines if a database sync is currently required.
.PP
Unused for Redis implementation.
.SS "expiry_due"
.IX Subsection "expiry_due"
public instance (Boolean) expiry_due ()
.PP
Description:
This methods determines if an expire is due.
.PP
Unused for Redis implementation.
.SS "seen_get"
.IX Subsection "seen_get"
public instance (String) seen_get (string \f(CW$msgid\fR)
.PP
Description:
This method retrieves the stored value, if any, for \f(CW$msgid\fR.  The return
value is the stored string ('s' for spam and 'h' for ham) or undef if \f(CW$msgid\fR
is not found.
.SS "seen_put"
.IX Subsection "seen_put"
public (Boolean) seen_put (string \f(CW$msgid\fR, char \f(CW$flag\fR)
.PP
Description:
This method records \f(CW$msgid\fR as the type given by \f(CW$flag\fR.  \f(CW$flag\fR is one
of two values 's' for spam and 'h' for ham.
.SS "seen_delete"
.IX Subsection "seen_delete"
public instance (Boolean) seen_delete (string \f(CW$msgid\fR)
.PP
Description:
This method removes \f(CW$msgid\fR from the database.
.SS "get_storage_variables"
.IX Subsection "get_storage_variables"
public instance (@) get_storage_variables ()
.PP
Description:
This method retrieves the various administrative variables used by
the Bayes process and database.
.PP
The values returned in the array are in the following order:
.PP
0: scan count base
1: number of spam
2: number of ham
3: number of tokens in db
4: last expire atime
5: oldest token in db atime
6: db version value
7: last journal sync
8: last atime delta
9: last expire reduction count
10: newest token in db atime
.PP
Only 1,2,6 are used with Redis, others return zero always.
.SS "get_running_expire_tok"
.IX Subsection "get_running_expire_tok"
public instance (String \f(CW$time\fR) get_running_expire_tok ()
.PP
Description:
This method determines if an expire is currently running and returns
the last time set.
.SS "set_running_expire_tok"
.IX Subsection "set_running_expire_tok"
public instance (String \f(CW$time\fR) set_running_expire_tok ()
.PP
Description:
This method sets the time that an expire starts running.
.SS "remove_running_expire_tok"
.IX Subsection "remove_running_expire_tok"
public instance (Boolean) remove_running_expire_tok ()
.PP
Description:
This method removes the row in the database that indicates that
and expire is currently running.
.SS "tok_get"
.IX Subsection "tok_get"
public instance (Integer, Integer, Integer) tok_get (String \f(CW$token\fR)
.PP
Description:
This method retrieves a specificed token (\f(CW$token\fR) from the database
and returns its spam_count, ham_count and last access time.
.SS "tok_get_all"
.IX Subsection "tok_get_all"
public instance (\e@) tok_get (@ \f(CW$tokens\fR)
.PP
Description:
This method retrieves the specified tokens (\f(CW$tokens\fR) from storage and
returns a ref to arrays spam count, ham count and last access time.
.SS "tok_count_change"
.IX Subsection "tok_count_change"
public instance (Boolean) tok_count_change (
  Integer \f(CW$dspam\fR, Integer \f(CW$dham\fR, String \f(CW$token\fR, String \f(CW$newatime\fR)
.PP
Description:
This method takes a \f(CW$spam_count\fR and \f(CW$ham_count\fR and adds it to
\&\f(CW$tok\fR along with updating \f(CW$tok\fRs atime with \f(CW$atime\fR.
.SS "multi_tok_count_change"
.IX Subsection "multi_tok_count_change"
public instance (Boolean) multi_tok_count_change (
  Integer \f(CW$dspam\fR, Integer \f(CW$dham\fR, \e% \f(CW$tokens\fR, String \f(CW$newatime\fR)
.PP
Description:
This method takes a \f(CW$dspam\fR and \f(CW$dham\fR and adds it to all of the
tokens in the \f(CW$tokens\fR hash ref along with updating each token's
atime with \f(CW$atime\fR.
.SS "nspam_nham_get"
.IX Subsection "nspam_nham_get"
public instance ($spam_count, \f(CW$ham_count\fR) nspam_nham_get ()
.PP
Description:
This method retrieves the total number of spam and the total number of
ham learned.
.SS "nspam_nham_change"
.IX Subsection "nspam_nham_change"
public instance (Boolean) nspam_nham_change (Integer \f(CW$num_spam\fR,
                                             Integer \f(CW$num_ham\fR)
.PP
Description:
This method updates the number of spam and the number of ham in the database.
.SS "tok_touch"
.IX Subsection "tok_touch"
public instance (Boolean) tok_touch (String \f(CW$token\fR,
                                     String \f(CW$atime\fR)
.PP
Description:
This method updates the given tokens (\f(CW$token\fR) atime.
.PP
The assumption is that the token already exists in the database.
.PP
We will never update to an older atime
.SS "tok_touch_all"
.IX Subsection "tok_touch_all"
public instance (Boolean) tok_touch (\e@ \f(CW$tokens\fR
                                     String \f(CW$atime\fR)
.PP
Description:
This method does a mass update of the given list of tokens \f(CW$tokens\fR,
if the existing token atime is < \f(CW$atime\fR.
.SS "cleanup"
.IX Subsection "cleanup"
public instance (Boolean) cleanup ()
.PP
Description:
This method perfoms any cleanup necessary before moving onto the next
operation.
.SS "get_magic_re"
.IX Subsection "get_magic_re"
public instance (String) get_magic_re ()
.PP
Description:
This method returns a regexp which indicates a magic token.
.SS "sync"
.IX Subsection "sync"
public instance (Boolean) sync (\e% \f(CW$opts\fR)
.PP
Description:
This method performs a sync of the database
.SS "perform_upgrade"
.IX Subsection "perform_upgrade"
public instance (Boolean) perform_upgrade (\e% \f(CW$opts\fR);
.PP
Description:
Performs an upgrade of the database from one version to another, not
currently used in this implementation.
.SS "clear_database"
.IX Subsection "clear_database"
public instance (Boolean) clear_database ()
.PP
Description:
This method deletes all records for a particular user.
.PP
Callers should be aware that any errors returned by this method
could causes the database to be inconsistent for the given user.
.SS "dump_db_toks"
.IX Subsection "dump_db_toks"
public instance () dump_db_toks (String \f(CW$template\fR, String \f(CW$regex\fR, Array \f(CW@vars\fR)
.PP
Description:
This method loops over all tokens, computing the probability for the token
and then printing it out according to the passed in token.
.SS "backup_database"
.IX Subsection "backup_database"
public instance (Boolean) backup_database ()
.PP
Description:
This method will dump the users database in a machine readable format.
.SS "restore_database"
.IX Subsection "restore_database"
public instance (Boolean) restore_database (String \f(CW$filename\fR, Boolean \f(CW$showdots\fR)
.PP
Description:
This method restores a database from the given filename, \f(CW$filename\fR.
.PP
Callers should be aware that any errors returned by this method
could causes the database to be inconsistent for the given user.
.SS "db_readable"
.IX Subsection "db_readable"
public instance (Boolean) \fIdb_readable()\fR
.PP
Description:
This method returns a boolean value indicating if the database is in a
readable state.
.SS "db_writable"
.IX Subsection "db_writable"
public instance (Boolean) \fIdb_writable()\fR
.PP
Description:
This method returns a boolean value indicating if the database is in a
writable state.
