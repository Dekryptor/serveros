// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.

// Patched for:
// https://prototype.lighthouseapp.com/projects/8886/tickets/289/a/405849/prototypejs.patch

/*  Prototype JavaScript framework, version 1.7
 *  (c) 2005-2010 Sam Stephenson
 *
 *  Prototype is freely distributable under the terms of an MIT-style license.
 *  For details, see the Prototype web site: http://www.prototypejs.org/
 *
 *--------------------------------------------------------------------------*/


var Prototype = {

  Version: '1.7',

  Browser: (function(){
    var ua = navigator.userAgent;
    var isOpera = Object.prototype.toString.call(window.opera) == '[object Opera]';
    return {
      IE:             !!window.attachEvent && !isOpera,
      Opera:          isOpera,
      WebKit:         ua.indexOf('AppleWebKit/') > -1,
      Gecko:          ua.indexOf('Gecko') > -1 && ua.indexOf('KHTML') === -1,
      MobileSafari:   /Apple.*Mobile/.test(ua)
    }
  })(),

  BrowserFeatures: {
    XPath: !!document.evaluate,

    SelectorsAPI: !!document.querySelector,

    ElementExtensions: (function() {
      var constructor = window.Element || window.HTMLElement;
      return !!(constructor && constructor.prototype);
    })(),
    SpecificElementExtensions: (function() {
      if (typeof window.HTMLDivElement !== 'undefined')
        return true;

      var div = document.createElement('div'),
          form = document.createElement('form'),
          isSupported = false;

      if (div['__proto__'] && (div['__proto__'] !== form['__proto__'])) {
        isSupported = true;
      }

      div = form = null;

      return isSupported;
    })()
  },

  ScriptFragment: '<script[^>]*>([\\S\\s]*?)<\/script>',
  JSONFilter: /^\/\*-secure-([\s\S]*)\*\/\s*$/,

  emptyFunction: function() { },

  K: function(x) { return x }
};

if (Prototype.Browser.MobileSafari)
  Prototype.BrowserFeatures.SpecificElementExtensions = false;
/* Based on Alex Arnell's inheritance implementation. */

var Class = (function() {

  var IS_DONTENUM_BUGGY = (function(){
    for (var p in { toString: 1 }) {
      if (p === 'toString') return false;
    }
    return true;
  })();

  function subclass() {};
  function create() {
    var parent = null, properties = $A(arguments);
    if (Object.isFunction(properties[0]))
      parent = properties.shift();

    function klass() {
      this.initialize.apply(this, arguments);
    }

    Object.extend(klass, Class.Methods);
    klass.superclass = parent;
    klass.subclasses = [];

    if (parent) {
      subclass.prototype = parent.prototype;
      klass.prototype = new subclass;
      parent.subclasses.push(klass);
    }

    for (var i = 0, length = properties.length; i < length; i++)
      klass.addMethods(properties[i]);

    if (!klass.prototype.initialize)
      klass.prototype.initialize = Prototype.emptyFunction;

    klass.prototype.constructor = klass;
    return klass;
  }

  function addMethods(source) {
    var ancestor   = this.superclass && this.superclass.prototype,
        properties = Object.keys(source);

    if (IS_DONTENUM_BUGGY) {
      if (source.toString != Object.prototype.toString)
        properties.push("toString");
      if (source.valueOf != Object.prototype.valueOf)
        properties.push("valueOf");
    }

    for (var i = 0, length = properties.length; i < length; i++) {
      var property = properties[i], value = source[property];
      if (ancestor && Object.isFunction(value) &&
          value.argumentNames()[0] == "$super") {
        var method = value;
        value = (function(m) {
          return function() { return ancestor[m].apply(this, arguments); };
        })(property).wrap(method);

        value.valueOf = method.valueOf.bind(method);
        value.toString = method.toString.bind(method);
      }
      this.prototype[property] = value;
    }

    return this;
  }

  return {
    create: create,
    Methods: {
      addMethods: addMethods
    }
  };
})();
(function() {

  var _toString = Object.prototype.toString,
      NULL_TYPE = 'Null',
      UNDEFINED_TYPE = 'Undefined',
      BOOLEAN_TYPE = 'Boolean',
      NUMBER_TYPE = 'Number',
      STRING_TYPE = 'String',
      OBJECT_TYPE = 'Object',
      FUNCTION_CLASS = '[object Function]',
      BOOLEAN_CLASS = '[object Boolean]',
      NUMBER_CLASS = '[object Number]',
      STRING_CLASS = '[object String]',
      ARRAY_CLASS = '[object Array]',
      DATE_CLASS = '[object Date]',
      NATIVE_JSON_STRINGIFY_SUPPORT = window.JSON &&
        typeof JSON.stringify === 'function' &&
        JSON.stringify(0) === '0' &&
        typeof JSON.stringify(Prototype.K) === 'undefined';

  function Type(o) {
    switch(o) {
      case null: return NULL_TYPE;
      case (void 0): return UNDEFINED_TYPE;
    }
    var type = typeof o;
    switch(type) {
      case 'boolean': return BOOLEAN_TYPE;
      case 'number':  return NUMBER_TYPE;
      case 'string':  return STRING_TYPE;
    }
    return OBJECT_TYPE;
  }

  function extend(destination, source) {
    for (var property in source)
      destination[property] = source[property];
    return destination;
  }

  function inspect(object) {
    try {
      if (isUndefined(object)) return 'undefined';
      if (object === null) return 'null';
      return object.inspect ? object.inspect() : String(object);
    } catch (e) {
      if (e instanceof RangeError) return '...';
      throw e;
    }
  }

  function toJSON(value) {
    return Str('', { '': value }, []);
  }

  function Str(key, holder, stack) {
    var value = holder[key],
        type = typeof value;

    if (Type(value) === OBJECT_TYPE && typeof value.toJSON === 'function') {
      value = value.toJSON(key);
    }

    var _class = _toString.call(value);

    switch (_class) {
      case NUMBER_CLASS:
      case BOOLEAN_CLASS:
      case STRING_CLASS:
        value = value.valueOf();
    }

    switch (value) {
      case null: return 'null';
      case true: return 'true';
      case false: return 'false';
    }

    type = typeof value;
    switch (type) {
      case 'string':
        return value.inspect(true);
      case 'number':
        return isFinite(value) ? String(value) : 'null';
      case 'object':

        for (var i = 0, length = stack.length; i < length; i++) {
          if (stack[i] === value) { throw new TypeError(); }
        }
        stack.push(value);

        var partial = [];
        if (_class === ARRAY_CLASS) {
          for (var i = 0, length = value.length; i < length; i++) {
            var str = Str(i, value, stack);
            partial.push(typeof str === 'undefined' ? 'null' : str);
          }
          partial = '[' + partial.join(',') + ']';
        } else {
          var keys = Object.keys(value);
          for (var i = 0, length = keys.length; i < length; i++) {
            var key = keys[i], str = Str(key, value, stack);
            if (typeof str !== "undefined") {
               partial.push(key.inspect(true)+ ':' + str);
             }
          }
          partial = '{' + partial.join(',') + '}';
        }
        stack.pop();
        return partial;
    }
  }

  function stringify(object) {
    return JSON.stringify(object);
  }

  function toQueryString(object) {
    return $H(object).toQueryString();
  }

  function toHTML(object) {
    return object && object.toHTML ? object.toHTML() : String.interpret(object);
  }

  function keys(object) {
    if (Type(object) !== OBJECT_TYPE) { throw new TypeError(); }
    var results = [];
    for (var property in object) {
      if (object.hasOwnProperty(property)) {
        results.push(property);
      }
    }
    return results;
  }

  function values(object) {
    var results = [];
    for (var property in object)
      results.push(object[property]);
    return results;
  }

  function clone(object) {
    return extend({ }, object);
  }

  function isElement(object) {
    return !!(object && object.nodeType == 1);
  }

  function isArray(object) {
    return _toString.call(object) === ARRAY_CLASS;
  }

  var hasNativeIsArray = (typeof Array.isArray == 'function')
    && Array.isArray([]) && !Array.isArray({});

  if (hasNativeIsArray) {
    isArray = Array.isArray;
  }

  function isHash(object) {
    return object instanceof Hash;
  }

  function isFunction(object) {
    return _toString.call(object) === FUNCTION_CLASS;
  }

  function isString(object) {
    return _toString.call(object) === STRING_CLASS;
  }

  function isNumber(object) {
    return _toString.call(object) === NUMBER_CLASS;
  }

  function isDate(object) {
    return _toString.call(object) === DATE_CLASS;
  }

  function isUndefined(object) {
    return typeof object === "undefined";
  }

  extend(Object, {
    extend:        extend,
    inspect:       inspect,
    toJSON:        NATIVE_JSON_STRINGIFY_SUPPORT ? stringify : toJSON,
    toQueryString: toQueryString,
    toHTML:        toHTML,
    keys:          Object.keys || keys,
    values:        values,
    clone:         clone,
    isElement:     isElement,
    isArray:       isArray,
    isHash:        isHash,
    isFunction:    isFunction,
    isString:      isString,
    isNumber:      isNumber,
    isDate:        isDate,
    isUndefined:   isUndefined
  });
})();
Object.extend(Function.prototype, (function() {
  var slice = Array.prototype.slice;

  function update(array, args) {
    var arrayLength = array.length, length = args.length;
    while (length--) array[arrayLength + length] = args[length];
    return array;
  }

  function merge(array, args) {
    array = slice.call(array, 0);
    return update(array, args);
  }

  function argumentNames() {
    var names = this.toString().match(/^[\s\(]*function[^(]*\(([^)]*)\)/)[1]
      .replace(/\/\/.*?[\r\n]|\/\*(?:.|[\r\n])*?\*\//g, '')
      .replace(/\s+/g, '').split(',');
    return names.length == 1 && !names[0] ? [] : names;
  }

  function bind(context) {
    if (arguments.length < 2 && Object.isUndefined(arguments[0])) return this;
    var __method = this, args = slice.call(arguments, 1);
    return function() {
      var a = merge(args, arguments);
      return __method.apply(context, a);
    }
  }

  function bindAsEventListener(context) {
    var __method = this, args = slice.call(arguments, 1);
    return function(event) {
      var a = update([event || window.event], args);
      return __method.apply(context, a);
    }
  }

  function curry() {
    if (!arguments.length) return this;
    var __method = this, args = slice.call(arguments, 0);
    return function() {
      var a = merge(args, arguments);
      return __method.apply(this, a);
    }
  }

  function delay(timeout) {
    var __method = this, args = slice.call(arguments, 1);
    timeout = timeout * 1000;
    return window.setTimeout(function() {
      return __method.apply(__method, args);
    }, timeout);
  }

  function defer() {
    var args = update([0.01], arguments);
    return this.delay.apply(this, args);
  }

  function wrap(wrapper) {
    var __method = this;
    return function() {
      var a = update([__method.bind(this)], arguments);
      return wrapper.apply(this, a);
    }
  }

  function methodize() {
    if (this._methodized) return this._methodized;
    var __method = this;
    return this._methodized = function() {
      var a = update([this], arguments);
      return __method.apply(null, a);
    };
  }

  return {
    argumentNames:       argumentNames,
    bind:                bind,
    bindAsEventListener: bindAsEventListener,
    curry:               curry,
    delay:               delay,
    defer:               defer,
    wrap:                wrap,
    methodize:           methodize
  }
})());



(function(proto) {


  function toISOString() {
    return this.getUTCFullYear() + '-' +
      (this.getUTCMonth() + 1).toPaddedString(2) + '-' +
      this.getUTCDate().toPaddedString(2) + 'T' +
      this.getUTCHours().toPaddedString(2) + ':' +
      this.getUTCMinutes().toPaddedString(2) + ':' +
      this.getUTCSeconds().toPaddedString(2) + 'Z';
  }


  function toJSON() {
    return this.toISOString();
  }

  if (!proto.toISOString) proto.toISOString = toISOString;
  if (!proto.toJSON) proto.toJSON = toJSON;

})(Date.prototype);


RegExp.prototype.match = RegExp.prototype.test;

RegExp.escape = function(str) {
  return String(str).replace(/([.*+?^=!:${}()|[\]\/\\])/g, '\\$1');
};
var PeriodicalExecuter = Class.create({
  initialize: function(callback, frequency) {
    this.callback = callback;
    this.frequency = frequency;
    this.currentlyExecuting = false;

    this.registerCallback();
  },

  registerCallback: function() {
    this.timer = setInterval(this.onTimerEvent.bind(this), this.frequency * 1000);
  },

  execute: function() {
    this.callback(this);
  },

  stop: function() {
    if (!this.timer) return;
    clearInterval(this.timer);
    this.timer = null;
  },

  onTimerEvent: function() {
    if (!this.currentlyExecuting) {
      try {
        this.currentlyExecuting = true;
        this.execute();
        this.currentlyExecuting = false;
      } catch(e) {
        this.currentlyExecuting = false;
        throw e;
      }
    }
  }
});
Object.extend(String, {
  interpret: function(value) {
    return value == null ? '' : String(value);
  },
  specialChar: {
    '\b': '\\b',
    '\t': '\\t',
    '\n': '\\n',
    '\f': '\\f',
    '\r': '\\r',
    '\\': '\\\\'
  }
});

Object.extend(String.prototype, (function() {
  var NATIVE_JSON_PARSE_SUPPORT = window.JSON &&
    typeof JSON.parse === 'function' &&
    JSON.parse('{"test": true}').test;

  function prepareReplacement(replacement) {
    if (Object.isFunction(replacement)) return replacement;
    var template = new Template(replacement);
    return function(match) { return template.evaluate(match) };
  }

  function gsub(pattern, replacement) {
    var result = '', source = this, match;
    replacement = prepareReplacement(replacement);

    if (Object.isString(pattern))
      pattern = RegExp.escape(pattern);

    if (!(pattern.length || pattern.source)) {
      replacement = replacement('');
      return replacement + source.split('').join(replacement) + replacement;
    }

    while (source.length > 0) {
      if (match = source.match(pattern)) {
        result += source.slice(0, match.index);
        result += String.interpret(replacement(match));
        source  = source.slice(match.index + match[0].length);
      } else {
        result += source, source = '';
      }
    }
    return result;
  }

  function sub(pattern, replacement, count) {
    replacement = prepareReplacement(replacement);
    count = Object.isUndefined(count) ? 1 : count;

    return this.gsub(pattern, function(match) {
      if (--count < 0) return match[0];
      return replacement(match);
    });
  }

  function scan(pattern, iterator) {
    this.gsub(pattern, iterator);
    return String(this);
  }

  function truncate(length, truncation) {
    length = length || 30;
    truncation = Object.isUndefined(truncation) ? '...' : truncation;
    return this.length > length ?
      this.slice(0, length - truncation.length) + truncation : String(this);
  }

  function strip() {
    return this.replace(/^\s+/, '').replace(/\s+$/, '');
  }

  function stripTags() {
    return this.replace(/<\w+(\s+("[^"]*"|'[^']*'|[^>])+)?>|<\/\w+>/gi, '');
  }

  function stripScripts() {
    return this.replace(new RegExp(Prototype.ScriptFragment, 'img'), '');
  }

  function extractScripts() {
    var matchAll = new RegExp(Prototype.ScriptFragment, 'img'),
        matchOne = new RegExp(Prototype.ScriptFragment, 'im');
    return (this.match(matchAll) || []).map(function(scriptTag) {
      return (scriptTag.match(matchOne) || ['', ''])[1];
    });
  }

  function evalScripts() {
    return this.extractScripts().map(function(script) { return eval(script) });
  }

  function escapeHTML() {
    return this.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
  }

  function unescapeHTML() {
    return this.stripTags().replace(/&lt;/g,'<').replace(/&gt;/g,'>').replace(/&amp;/g,'&');
  }


  function toQueryParams(separator) {
    var match = this.strip().match(/([^?#]*)(#.*)?$/);
    if (!match) return { };

    return match[1].split(separator || '&').inject({ }, function(hash, pair) {
      if ((pair = pair.split('='))[0]) {
        var key = decodeURIComponent(pair.shift()),
            value = pair.length > 1 ? pair.join('=') : pair[0];

        if (value != undefined) value = decodeURIComponent(value);

        if (key in hash) {
          if (!Object.isArray(hash[key])) hash[key] = [hash[key]];
          hash[key].push(value);
        }
        else hash[key] = value;
      }
      return hash;
    });
  }

  function toArray() {
    return this.split('');
  }

  function succ() {
    return this.slice(0, this.length - 1) +
      String.fromCharCode(this.charCodeAt(this.length - 1) + 1);
  }

  function times(count) {
    return count < 1 ? '' : new Array(count + 1).join(this);
  }

  function camelize() {
    return this.replace(/-+(.)?/g, function(match, chr) {
      return chr ? chr.toUpperCase() : '';
    });
  }

  function capitalize() {
    return this.charAt(0).toUpperCase() + this.substring(1).toLowerCase();
  }

  function underscore() {
    return this.replace(/::/g, '/')
               .replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2')
               .replace(/([a-z\d])([A-Z])/g, '$1_$2')
               .replace(/-/g, '_')
               .toLowerCase();
  }

  function dasherize() {
    return this.replace(/_/g, '-');
  }

  function inspect(useDoubleQuotes) {
    var escapedString = this.replace(/[\x00-\x1f\\]/g, function(character) {
      if (character in String.specialChar) {
        return String.specialChar[character];
      }
      return '\\u00' + character.charCodeAt().toPaddedString(2, 16);
    });
    if (useDoubleQuotes) return '"' + escapedString.replace(/"/g, '\\"') + '"';
    return "'" + escapedString.replace(/'/g, '\\\'') + "'";
  }

  function unfilterJSON(filter) {
    return this.replace(filter || Prototype.JSONFilter, '$1');
  }

  function isJSON() {
    var str = this;
    if (str.blank()) return false;
    str = str.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@');
    str = str.replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']');
    str = str.replace(/(?:^|:|,)(?:\s*\[)+/g, '');
    return (/^[\],:{}\s]*$/).test(str);
  }

  function evalJSON(sanitize) {
    var json = this.unfilterJSON(),
        cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
    if (cx.test(json)) {
      json = json.replace(cx, function (a) {
        return '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
      });
    }
    try {
      if (!sanitize || json.isJSON()) return eval('(' + json + ')');
    } catch (e) { }
    throw new SyntaxError('Badly formed JSON string: ' + this.inspect());
  }

  function parseJSON() {
    var json = this.unfilterJSON();
    return JSON.parse(json);
  }

  function include(pattern) {
    return this.indexOf(pattern) > -1;
  }

  function startsWith(pattern) {
    return this.lastIndexOf(pattern, 0) === 0;
  }

  function endsWith(pattern) {
    var d = this.length - pattern.length;
    return d >= 0 && this.indexOf(pattern, d) === d;
  }

  function empty() {
    return this == '';
  }

  function blank() {
    return /^\s*$/.test(this);
  }

  function interpolate(object, pattern) {
    return new Template(this, pattern).evaluate(object);
  }

  return {
    gsub:           gsub,
    sub:            sub,
    scan:           scan,
    truncate:       truncate,
    strip:          String.prototype.trim || strip,
    stripTags:      stripTags,
    stripScripts:   stripScripts,
    extractScripts: extractScripts,
    evalScripts:    evalScripts,
    escapeHTML:     escapeHTML,
    unescapeHTML:   unescapeHTML,
    toQueryParams:  toQueryParams,
    parseQuery:     toQueryParams,
    toArray:        toArray,
    succ:           succ,
    times:          times,
    camelize:       camelize,
    capitalize:     capitalize,
    underscore:     underscore,
    dasherize:      dasherize,
    inspect:        inspect,
    unfilterJSON:   unfilterJSON,
    isJSON:         isJSON,
    evalJSON:       NATIVE_JSON_PARSE_SUPPORT ? parseJSON : evalJSON,
    include:        include,
    startsWith:     startsWith,
    endsWith:       endsWith,
    empty:          empty,
    blank:          blank,
    interpolate:    interpolate
  };
})());

var Template = Class.create({
  initialize: function(template, pattern) {
    this.template = template.toString();
    this.pattern = pattern || Template.Pattern;
  },

  evaluate: function(object) {
    if (object && Object.isFunction(object.toTemplateReplacements))
      object = object.toTemplateReplacements();

    return this.template.gsub(this.pattern, function(match) {
      if (object == null) return (match[1] + '');

      var before = match[1] || '';
      if (before == '\\') return match[2];

      var ctx = object, expr = match[3],
          pattern = /^([^.[]+|\[((?:.*?[^\\])?)\])(\.|\[|$)/;

      match = pattern.exec(expr);
      if (match == null) return before;

      while (match != null) {
        var comp = match[1].startsWith('[') ? match[2].replace(/\\\\]/g, ']') : match[1];
        ctx = ctx[comp];
        if (null == ctx || '' == match[3]) break;
        expr = expr.substring('[' == match[3] ? match[1].length : match[0].length);
        match = pattern.exec(expr);
      }

      return before + String.interpret(ctx);
    });
  }
});
Template.Pattern = /(^|.|\r|\n)(#\{(.*?)\})/;

var $break = { };

var Enumerable = (function() {
  function each(iterator, context) {
    var index = 0;
    try {
      this._each(function(value) {
        iterator.call(context, value, index++);
      });
    } catch (e) {
      if (e != $break) throw e;
    }
    return this;
  }

  function eachSlice(number, iterator, context) {
    var index = -number, slices = [], array = this.toArray();
    if (number < 1) return array;
    while ((index += number) < array.length)
      slices.push(array.slice(index, index+number));
    return slices.collect(iterator, context);
  }

  function all(iterator, context) {
    iterator = iterator || Prototype.K;
    var result = true;
    this.each(function(value, index) {
      result = result && !!iterator.call(context, value, index);
      if (!result) throw $break;
    });
    return result;
  }

  function any(iterator, context) {
    iterator = iterator || Prototype.K;
    var result = false;
    this.each(function(value, index) {
      if (result = !!iterator.call(context, value, index))
        throw $break;
    });
    return result;
  }

  function collect(iterator, context) {
    iterator = iterator || Prototype.K;
    var results = [];
    this.each(function(value, index) {
      results.push(iterator.call(context, value, index));
    });
    return results;
  }

  function detect(iterator, context) {
    var result;
    this.each(function(value, index) {
      if (iterator.call(context, value, index)) {
        result = value;
        throw $break;
      }
    });
    return result;
  }

  function findAll(iterator, context) {
    var results = [];
    this.each(function(value, index) {
      if (iterator.call(context, value, index))
        results.push(value);
    });
    return results;
  }

  function grep(filter, iterator, context) {
    iterator = iterator || Prototype.K;
    var results = [];

    if (Object.isString(filter))
      filter = new RegExp(RegExp.escape(filter));

    this.each(function(value, index) {
      if (filter.match(value))
        results.push(iterator.call(context, value, index));
    });
    return results;
  }

  function include(object) {
    if (Object.isFunction(this.indexOf))
      if (this.indexOf(object) != -1) return true;

    var found = false;
    this.each(function(value) {
      if (value == object) {
        found = true;
        throw $break;
      }
    });
    return found;
  }

  function inGroupsOf(number, fillWith) {
    fillWith = Object.isUndefined(fillWith) ? null : fillWith;
    return this.eachSlice(number, function(slice) {
      while(slice.length < number) slice.push(fillWith);
      return slice;
    });
  }

  function inject(memo, iterator, context) {
    this.each(function(value, index) {
      memo = iterator.call(context, memo, value, index);
    });
    return memo;
  }

  function invoke(method) {
    var args = $A(arguments).slice(1);
    return this.map(function(value) {
      return value[method].apply(value, args);
    });
  }

  function max(iterator, context) {
    iterator = iterator || Prototype.K;
    var result;
    this.each(function(value, index) {
      value = iterator.call(context, value, index);
      if (result == null || value >= result)
        result = value;
    });
    return result;
  }

  function min(iterator, context) {
    iterator = iterator || Prototype.K;
    var result;
    this.each(function(value, index) {
      value = iterator.call(context, value, index);
      if (result == null || value < result)
        result = value;
    });
    return result;
  }

  function partition(iterator, context) {
    iterator = iterator || Prototype.K;
    var trues = [], falses = [];
    this.each(function(value, index) {
      (iterator.call(context, value, index) ?
        trues : falses).push(value);
    });
    return [trues, falses];
  }

  function pluck(property) {
    var results = [];
    this.each(function(value) {
      results.push(value[property]);
    });
    return results;
  }

  function reject(iterator, context) {
    var results = [];
    this.each(function(value, index) {
      if (!iterator.call(context, value, index))
        results.push(value);
    });
    return results;
  }

  function sortBy(iterator, context) {
    return this.map(function(value, index) {
      return {
        value: value,
        criteria: iterator.call(context, value, index)
      };
    }).sort(function(left, right) {
      var a = left.criteria, b = right.criteria;
      return a < b ? -1 : a > b ? 1 : 0;
    }).pluck('value');
  }

  function toArray() {
    return this.map();
  }

  function zip() {
    var iterator = Prototype.K, args = $A(arguments);
    if (Object.isFunction(args.last()))
      iterator = args.pop();

    var collections = [this].concat(args).map($A);
    return this.map(function(value, index) {
      return iterator(collections.pluck(index));
    });
  }

  function size() {
    return this.toArray().length;
  }

  function inspect() {
    return '#<Enumerable:' + this.toArray().inspect() + '>';
  }









  return {
    each:       each,
    eachSlice:  eachSlice,
    all:        all,
    every:      all,
    any:        any,
    some:       any,
    collect:    collect,
    map:        collect,
    detect:     detect,
    findAll:    findAll,
    select:     findAll,
    filter:     findAll,
    grep:       grep,
    include:    include,
    member:     include,
    inGroupsOf: inGroupsOf,
    inject:     inject,
    invoke:     invoke,
    max:        max,
    min:        min,
    partition:  partition,
    pluck:      pluck,
    reject:     reject,
    sortBy:     sortBy,
    toArray:    toArray,
    entries:    toArray,
    zip:        zip,
    size:       size,
    inspect:    inspect,
    find:       detect
  };
})();

function $A(iterable) {
  if (!iterable) return [];
  if ('toArray' in Object(iterable)) return iterable.toArray();
  var length = iterable.length || 0, results = new Array(length);
  while (length--) results[length] = iterable[length];
  return results;
}


function $w(string) {
  if (!Object.isString(string)) return [];
  string = string.strip();
  return string ? string.split(/\s+/) : [];
}

Array.from = $A;


(function() {
  var arrayProto = Array.prototype,
      slice = arrayProto.slice,
      _each = arrayProto.forEach; // use native browser JS 1.6 implementation if available

  function each(iterator, context) {
    for (var i = 0, length = this.length >>> 0; i < length; i++) {
      if (i in this) iterator.call(context, this[i], i, this);
    }
  }
  if (!_each) _each = each;

  function clear() {
    this.length = 0;
    return this;
  }

  function first() {
    return this[0];
  }

  function last() {
    return this[this.length - 1];
  }

  function compact() {
    return this.select(function(value) {
      return value != null;
    });
  }

  function flatten() {
    return this.inject([], function(array, value) {
      if (Object.isArray(value))
        return array.concat(value.flatten());
      array.push(value);
      return array;
    });
  }

  function without() {
    var values = slice.call(arguments, 0);
    return this.select(function(value) {
      return !values.include(value);
    });
  }

  function reverse(inline) {
    return (inline === false ? this.toArray() : this)._reverse();
  }

  function uniq(sorted) {
    return this.inject([], function(array, value, index) {
      if (0 == index || (sorted ? array.last() != value : !array.include(value)))
        array.push(value);
      return array;
    });
  }

  function intersect(array) {
    return this.uniq().findAll(function(item) {
      return array.detect(function(value) { return item === value });
    });
  }


  function clone() {
    return slice.call(this, 0);
  }

  function size() {
    return this.length;
  }

  function inspect() {
    return '[' + this.map(Object.inspect).join(', ') + ']';
  }

  function indexOf(item, i) {
    i || (i = 0);
    var length = this.length;
    if (i < 0) i = length + i;
    for (; i < length; i++)
      if (this[i] === item) return i;
    return -1;
  }

  function lastIndexOf(item, i) {
    i = isNaN(i) ? this.length : (i < 0 ? this.length + i : i) + 1;
    var n = this.slice(0, i).reverse().indexOf(item);
    return (n < 0) ? n : i - n - 1;
  }

  function concat() {
    var array = slice.call(this, 0), item;
    for (var i = 0, length = arguments.length; i < length; i++) {
      item = arguments[i];
      if (Object.isArray(item) && !('callee' in item)) {
        for (var j = 0, arrayLength = item.length; j < arrayLength; j++)
          array.push(item[j]);
      } else {
        array.push(item);
      }
    }
    return array;
  }

  Object.extend(arrayProto, Enumerable);

  if (!arrayProto._reverse)
    arrayProto._reverse = arrayProto.reverse;

  Object.extend(arrayProto, {
    _each:     _each,
    clear:     clear,
    first:     first,
    last:      last,
    compact:   compact,
    flatten:   flatten,
    without:   without,
    reverse:   reverse,
    uniq:      uniq,
    intersect: intersect,
    clone:     clone,
    toArray:   clone,
    size:      size,
    inspect:   inspect
  });

  var CONCAT_ARGUMENTS_BUGGY = (function() {
    return [].concat(arguments)[0][0] !== 1;
  })(1,2)

  if (CONCAT_ARGUMENTS_BUGGY) arrayProto.concat = concat;

  if (!arrayProto.indexOf) arrayProto.indexOf = indexOf;
  if (!arrayProto.lastIndexOf) arrayProto.lastIndexOf = lastIndexOf;
})();
function $H(object) {
  return new Hash(object);
};

var Hash = Class.create(Enumerable, (function() {
  function initialize(object) {
    this._object = Object.isHash(object) ? object.toObject() : Object.clone(object);
  }


  function _each(iterator) {
    for (var key in this._object) {
      var value = this._object[key], pair = [key, value];
      pair.key = key;
      pair.value = value;
      iterator(pair);
    }
  }

  function set(key, value) {
    return this._object[key] = value;
  }

  function get(key) {
    if (this._object[key] !== Object.prototype[key])
      return this._object[key];
  }

  function unset(key) {
    var value = this._object[key];
    delete this._object[key];
    return value;
  }

  function toObject() {
    return Object.clone(this._object);
  }



  function keys() {
    return this.pluck('key');
  }

  function values() {
    return this.pluck('value');
  }

  function index(value) {
    var match = this.detect(function(pair) {
      return pair.value === value;
    });
    return match && match.key;
  }

  function merge(object) {
    return this.clone().update(object);
  }

  function update(object) {
    return new Hash(object).inject(this, function(result, pair) {
      result.set(pair.key, pair.value);
      return result;
    });
  }

  function toQueryPair(key, value) {
    if (Object.isUndefined(value)) return key;
    return key + '=' + encodeURIComponent(String.interpret(value));
  }

  function toQueryString() {
    return this.inject([], function(results, pair) {
      var key = encodeURIComponent(pair.key), values = pair.value;

      if (values && typeof values == 'object') {
        if (Object.isArray(values)) {
          var queryValues = [];
          for (var i = 0, len = values.length, value; i < len; i++) {
            value = values[i];
            queryValues.push(toQueryPair(key, value));
          }
          return results.concat(queryValues);
        }
      } else results.push(toQueryPair(key, values));
      return results;
    }).join('&');
  }

  function inspect() {
    return '#<Hash:{' + this.map(function(pair) {
      return pair.map(Object.inspect).join(': ');
    }).join(', ') + '}>';
  }

  function clone() {
    return new Hash(this);
  }

  return {
    initialize:             initialize,
    _each:                  _each,
    set:                    set,
    get:                    get,
    unset:                  unset,
    toObject:               toObject,
    toTemplateReplacements: toObject,
    keys:                   keys,
    values:                 values,
    index:                  index,
    merge:                  merge,
    update:                 update,
    toQueryString:          toQueryString,
    inspect:                inspect,
    toJSON:                 toObject,
    clone:                  clone
  };
})());

Hash.from = $H;
Object.extend(Number.prototype, (function() {
  function toColorPart() {
    return this.toPaddedString(2, 16);
  }

  function succ() {
    return this + 1;
  }

  function times(iterator, context) {
    $R(0, this, true).each(iterator, context);
    return this;
  }

  function toPaddedString(length, radix) {
    var string = this.toString(radix || 10);
    return '0'.times(length - string.length) + string;
  }

  function abs() {
    return Math.abs(this);
  }

  function round() {
    return Math.round(this);
  }

  function ceil() {
    return Math.ceil(this);
  }

  function floor() {
    return Math.floor(this);
  }

  return {
    toColorPart:    toColorPart,
    succ:           succ,
    times:          times,
    toPaddedString: toPaddedString,
    abs:            abs,
    round:          round,
    ceil:           ceil,
    floor:          floor
  };
})());

function $R(start, end, exclusive) {
  return new ObjectRange(start, end, exclusive);
}

var ObjectRange = Class.create(Enumerable, (function() {
  function initialize(start, end, exclusive) {
    this.start = start;
    this.end = end;
    this.exclusive = exclusive;
  }

  function _each(iterator) {
    var value = this.start;
    while (this.include(value)) {
      iterator(value);
      value = value.succ();
    }
  }

  function include(value) {
    if (value < this.start)
      return false;
    if (this.exclusive)
      return value < this.end;
    return value <= this.end;
  }

  return {
    initialize: initialize,
    _each:      _each,
    include:    include
  };
})());



var Abstract = { };


var Try = {
  these: function() {
    var returnValue;

    for (var i = 0, length = arguments.length; i < length; i++) {
      var lambda = arguments[i];
      try {
        returnValue = lambda();
        break;
      } catch (e) { }
    }

    return returnValue;
  }
};

var Ajax = {
  getTransport: function() {
    return Try.these(
      function() {return new XMLHttpRequest()},
      function() {return new ActiveXObject('Msxml2.XMLHTTP')},
      function() {return new ActiveXObject('Microsoft.XMLHTTP')}
    ) || false;
  },

  activeRequestCount: 0
};

Ajax.Responders = {
  responders: [],

  _each: function(iterator) {
    this.responders._each(iterator);
  },

  register: function(responder) {
    if (!this.include(responder))
      this.responders.push(responder);
  },

  unregister: function(responder) {
    this.responders = this.responders.without(responder);
  },

  dispatch: function(callback, request, transport, json) {
    this.each(function(responder) {
      if (Object.isFunction(responder[callback])) {
        try {
          responder[callback].apply(responder, [request, transport, json]);
        } catch (e) { }
      }
    });
  }
};

Object.extend(Ajax.Responders, Enumerable);

Ajax.Responders.register({
  onCreate:   function() { Ajax.activeRequestCount++ },
  onComplete: function() { Ajax.activeRequestCount-- }
});
Ajax.Base = Class.create({
  initialize: function(options) {
    this.options = {
      method:       'post',
      asynchronous: true,
      contentType:  'application/x-www-form-urlencoded',
      encoding:     'UTF-8',
      parameters:   '',
      evalJSON:     true,
      evalJS:       true
    };
    Object.extend(this.options, options || { });

    this.options.method = this.options.method.toLowerCase();

    if (Object.isHash(this.options.parameters))
      this.options.parameters = this.options.parameters.toObject();
  }
});
Ajax.Request = Class.create(Ajax.Base, {
  _complete: false,

  initialize: function($super, url, options) {
    $super(options);
    this.transport = Ajax.getTransport();
    this.request(url);
  },

  request: function(url) {
    this.url = url;
    this.method = this.options.method;
    var params = Object.isString(this.options.parameters) ?
          this.options.parameters :
          Object.toQueryString(this.options.parameters);

    if (params && this.method === 'get') {
      this.url += (this.url.include('?') ? '&' : '?') + params;
    }

    this.parameters = params.toQueryParams();

    try {
      var response = new Ajax.Response(this);
      if (this.options.onCreate) this.options.onCreate(response);
      Ajax.Responders.dispatch('onCreate', this, response);

      this.transport.open(this.method.toUpperCase(), this.url,
        this.options.asynchronous);

      if (this.options.asynchronous) this.respondToReadyState.bind(this).defer(1);

      this.transport.onreadystatechange = this.onStateChange.bind(this);
      this.setRequestHeaders();

      this.body = this.method == 'post' ? (this.options.postBody || params) : this.options.postBody;
      this.transport.send(this.body);

      /* Force Firefox to handle ready state 4 for synchronous requests */
      if (!this.options.asynchronous && this.transport.overrideMimeType)
        this.onStateChange();

    }
    catch (e) {
      this.dispatchException(e);
    }
  },

  onStateChange: function() {
    var readyState = this.transport.readyState;
    if (readyState > 1 && !((readyState == 4) && this._complete))
      this.respondToReadyState(this.transport.readyState);
  },

  setRequestHeaders: function() {
    var headers = {
      'X-Requested-With': 'XMLHttpRequest',
      'X-Prototype-Version': Prototype.Version,
      'Accept': 'text/javascript, text/html, application/xml, text/xml, */*'
    };

    if (['post', 'put'].include(this.method)) {
      headers['Content-type'] = this.options.contentType +
        (this.options.encoding ? '; charset=' + this.options.encoding : '');

      /* Force "Connection: close" for older Mozilla browsers to work
       * around a bug where XMLHttpRequest sends an incorrect
       * Content-length header. See Mozilla Bugzilla #246651.
       */
      if (this.transport.overrideMimeType &&
          (navigator.userAgent.match(/Gecko\/(\d{4})/) || [0,2005])[1] < 2005)
            headers['Connection'] = 'close';
    }

    if (typeof this.options.requestHeaders == 'object') {
      var extras = this.options.requestHeaders;

      if (Object.isFunction(extras.push))
        for (var i = 0, length = extras.length; i < length; i += 2)
          headers[extras[i]] = extras[i+1];
      else
        $H(extras).each(function(pair) { headers[pair.key] = pair.value });
    }

    for (var name in headers)
      this.transport.setRequestHeader(name, headers[name]);
  },

  success: function() {
    var status = this.getStatus();
    return !status || (status >= 200 && status < 300) || status == 304;
  },

  getStatus: function() {
    try {
      if (this.transport.status === 1223) return 204;
      return this.transport.status || 0;
    } catch (e) { return 0 }
  },

  respondToReadyState: function(readyState) {
    var state = Ajax.Request.Events[readyState], response = new Ajax.Response(this);

    if (state == 'Complete') {
      try {
        this._complete = true;
        (this.options['on' + response.status]
         || this.options['on' + (this.success() ? 'Success' : 'Failure')]
         || Prototype.emptyFunction)(response, response.headerJSON);
      } catch (e) {
        this.dispatchException(e);
      }

      var contentType = response.getHeader('Content-type');
      if (this.options.evalJS == 'force'
          || (this.options.evalJS && this.isSameOrigin() && contentType
          && contentType.match(/^\s*(text|application)\/(x-)?(java|ecma)script(;.*)?\s*$/i)))
        this.evalResponse();
    }

    try {
      (this.options['on' + state] || Prototype.emptyFunction)(response, response.headerJSON);
      Ajax.Responders.dispatch('on' + state, this, response, response.headerJSON);
    } catch (e) {
      this.dispatchException(e);
    }

    if (state == 'Complete') {
      this.transport.onreadystatechange = Prototype.emptyFunction;
    }
  },

  isSameOrigin: function() {
    var m = this.url.match(/^\s*https?:\/\/[^\/]*/);
    return !m || (m[0] == '#{protocol}//#{domain}#{port}'.interpolate({
      protocol: location.protocol,
      domain: document.domain,
      port: location.port ? ':' + location.port : ''
    }));
  },

  getHeader: function(name) {
    try {
      return this.transport.getResponseHeader(name) || null;
    } catch (e) { return null; }
  },

  evalResponse: function() {
    try {
      return eval((this.transport.responseText || '').unfilterJSON());
    } catch (e) {
      this.dispatchException(e);
    }
  },

  dispatchException: function(exception) {
    (this.options.onException || Prototype.emptyFunction)(this, exception);
    Ajax.Responders.dispatch('onException', this, exception);
  }
});

Ajax.Request.Events =
  ['Uninitialized', 'Loading', 'Loaded', 'Interactive', 'Complete'];








Ajax.Response = Class.create({
  initialize: function(request){
    this.request = request;
    var transport  = this.transport  = request.transport,
        readyState = this.readyState = transport.readyState;

    if ((readyState > 2 && !Prototype.Browser.IE) || readyState == 4) {
      this.status       = this.getStatus();
      this.statusText   = this.getStatusText();
      this.responseText = String.interpret(transport.responseText);
      this.headerJSON   = this._getHeaderJSON();
    }

    if (readyState == 4) {
      var xml = transport.responseXML;
      this.responseXML  = Object.isUndefined(xml) ? null : xml;
      this.responseJSON = this._getResponseJSON();
    }
  },

  status:      0,

  statusText: '',

  getStatus: Ajax.Request.prototype.getStatus,

  getStatusText: function() {
    try {
      return this.transport.statusText || '';
    } catch (e) { return '' }
  },

  getHeader: Ajax.Request.prototype.getHeader,

  getAllHeaders: function() {
    try {
      return this.getAllResponseHeaders();
    } catch (e) { return null }
  },

  getResponseHeader: function(name) {
    return this.transport.getResponseHeader(name);
  },

  getAllResponseHeaders: function() {
    return this.transport.getAllResponseHeaders();
  },

  _getHeaderJSON: function() {
    var json = this.getHeader('X-JSON');
    if (!json) return null;
    json = decodeURIComponent(escape(json));
    try {
      return json.evalJSON(this.request.options.sanitizeJSON ||
        !this.request.isSameOrigin());
    } catch (e) {
      this.request.dispatchException(e);
    }
  },

  _getResponseJSON: function() {
    var options = this.request.options;
    if (!options.evalJSON || (options.evalJSON != 'force' &&
      !(this.getHeader('Content-type') || '').include('application/json')) ||
        this.responseText.blank())
          return null;
    try {
      return this.responseText.evalJSON(options.sanitizeJSON ||
        !this.request.isSameOrigin());
    } catch (e) {
      this.request.dispatchException(e);
    }
  }
});

Ajax.Updater = Class.create(Ajax.Request, {
  initialize: function($super, container, url, options) {
    this.container = {
      success: (container.success || container),
      failure: (container.failure || (container.success ? null : container))
    };

    options = Object.clone(options);
    var onComplete = options.onComplete;
    options.onComplete = (function(response, json) {
      this.updateContent(response.responseText);
      if (Object.isFunction(onComplete)) onComplete(response, json);
    }).bind(this);

    $super(url, options);
  },

  updateContent: function(responseText) {
    var receiver = this.container[this.success() ? 'success' : 'failure'],
        options = this.options;

    if (!options.evalScripts) responseText = responseText.stripScripts();

    if (receiver = $(receiver)) {
      if (options.insertion) {
        if (Object.isString(options.insertion)) {
          var insertion = { }; insertion[options.insertion] = responseText;
          receiver.insert(insertion);
        }
        else options.insertion(receiver, responseText);
      }
      else receiver.update(responseText);
    }
  }
});

Ajax.PeriodicalUpdater = Class.create(Ajax.Base, {
  initialize: function($super, container, url, options) {
    $super(options);
    this.onComplete = this.options.onComplete;

    this.frequency = (this.options.frequency || 2);
    this.decay = (this.options.decay || 1);

    this.updater = { };
    this.container = container;
    this.url = url;

    this.start();
  },

  start: function() {
    this.options.onComplete = this.updateComplete.bind(this);
    this.onTimerEvent();
  },

  stop: function() {
    this.updater.options.onComplete = undefined;
    clearTimeout(this.timer);
    (this.onComplete || Prototype.emptyFunction).apply(this, arguments);
  },

  updateComplete: function(response) {
    if (this.options.decay) {
      this.decay = (response.responseText == this.lastText ?
        this.decay * this.options.decay : 1);

      this.lastText = response.responseText;
    }
    this.timer = this.onTimerEvent.bind(this).delay(this.decay * this.frequency);
  },

  onTimerEvent: function() {
    this.updater = new Ajax.Updater(this.container, this.url, this.options);
  }
});


function $(element) {
  if (arguments.length > 1) {
    for (var i = 0, elements = [], length = arguments.length; i < length; i++)
      elements.push($(arguments[i]));
    return elements;
  }
  if (Object.isString(element))
    element = document.getElementById(element);
  return Element.extend(element);
}

if (Prototype.BrowserFeatures.XPath) {
  document._getElementsByXPath = function(expression, parentElement) {
    var results = [];
    var query = document.evaluate(expression, $(parentElement) || document,
      null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
    for (var i = 0, length = query.snapshotLength; i < length; i++)
      results.push(Element.extend(query.snapshotItem(i)));
    return results;
  };
}

/*--------------------------------------------------------------------------*/

if (!Node) var Node = { };

if (!Node.ELEMENT_NODE) {
  Object.extend(Node, {
    ELEMENT_NODE: 1,
    ATTRIBUTE_NODE: 2,
    TEXT_NODE: 3,
    CDATA_SECTION_NODE: 4,
    ENTITY_REFERENCE_NODE: 5,
    ENTITY_NODE: 6,
    PROCESSING_INSTRUCTION_NODE: 7,
    COMMENT_NODE: 8,
    DOCUMENT_NODE: 9,
    DOCUMENT_TYPE_NODE: 10,
    DOCUMENT_FRAGMENT_NODE: 11,
    NOTATION_NODE: 12
  });
}



(function(global) {
  function shouldUseCache(tagName, attributes) {
    if (tagName === 'select') return false;
    if ('type' in attributes) return false;
    return true;
  }

  var HAS_EXTENDED_CREATE_ELEMENT_SYNTAX = (function(){
    try {
      var el = document.createElement('<input name="x">');
      return el.tagName.toLowerCase() === 'input' && el.name === 'x';
    }
    catch(err) {
      return false;
    }
  })();

  var element = global.Element;

  global.Element = function(tagName, attributes) {
    attributes = attributes || { };
    tagName = tagName.toLowerCase();
    var cache = Element.cache;

    if (HAS_EXTENDED_CREATE_ELEMENT_SYNTAX && attributes.name) {
      tagName = '<' + tagName + ' name="' + attributes.name + '">';
      delete attributes.name;
      return Element.writeAttribute(document.createElement(tagName), attributes);
    }

    if (!cache[tagName]) cache[tagName] = Element.extend(document.createElement(tagName));

    var node = shouldUseCache(tagName, attributes) ?
     cache[tagName].cloneNode(false) : document.createElement(tagName);

    return Element.writeAttribute(node, attributes);
  };

  Object.extend(global.Element, element || { });
  if (element) global.Element.prototype = element.prototype;

})(this);

Element.idCounter = 1;
Element.cache = { };

Element._purgeElement = function(element) {
  var uid = element._prototypeUID;
  if (uid) {
    Element.stopObserving(element);
    element._prototypeUID = void 0;
    delete Element.Storage[uid];
  }
}

Element.Methods = {
  visible: function(element) {
    return $(element).style.display != 'none';
  },

  toggle: function(element) {
    element = $(element);
    Element[Element.visible(element) ? 'hide' : 'show'](element);
    return element;
  },

  hide: function(element) {
    element = $(element);
    element.style.display = 'none';
    return element;
  },

  show: function(element) {
    element = $(element);
    element.style.display = '';
    return element;
  },

  remove: function(element) {
    element = $(element);
    element.parentNode.removeChild(element);
    return element;
  },

  update: (function(){

    var SELECT_ELEMENT_INNERHTML_BUGGY = (function(){
      var el = document.createElement("select"),
          isBuggy = true;
      el.innerHTML = "<option value=\"test\">test</option>";
      if (el.options && el.options[0]) {
        isBuggy = el.options[0].nodeName.toUpperCase() !== "OPTION";
      }
      el = null;
      return isBuggy;
    })();

    var TABLE_ELEMENT_INNERHTML_BUGGY = (function(){
      try {
        var el = document.createElement("table");
        if (el && el.tBodies) {
          el.innerHTML = "<tbody><tr><td>test</td></tr></tbody>";
          var isBuggy = typeof el.tBodies[0] == "undefined";
          el = null;
          return isBuggy;
        }
      } catch (e) {
        return true;
      }
    })();

    var LINK_ELEMENT_INNERHTML_BUGGY = (function() {
      try {
        var el = document.createElement('div');
        el.innerHTML = "<link>";
        var isBuggy = (el.childNodes.length === 0);
        el = null;
        return isBuggy;
      } catch(e) {
        return true;
      }
    })();

    var ANY_INNERHTML_BUGGY = SELECT_ELEMENT_INNERHTML_BUGGY ||
     TABLE_ELEMENT_INNERHTML_BUGGY || LINK_ELEMENT_INNERHTML_BUGGY;

    var SCRIPT_ELEMENT_REJECTS_TEXTNODE_APPENDING = (function () {
      var s = document.createElement("script"),
          isBuggy = false;
      try {
        s.appendChild(document.createTextNode(""));
        isBuggy = !s.firstChild ||
          s.firstChild && s.firstChild.nodeType !== 3;
      } catch (e) {
        isBuggy = true;
      }
      s = null;
      return isBuggy;
    })();


    function update(element, content) {
      element = $(element);
      var purgeElement = Element._purgeElement;

      var descendants = element.getElementsByTagName('*'),
       i = descendants.length;
      while (i--) purgeElement(descendants[i]);

      if (content && content.toElement)
        content = content.toElement();

      if (Object.isElement(content))
        return element.update().insert(content);

      content = Object.toHTML(content);

      var tagName = element.tagName.toUpperCase();

      if (tagName === 'SCRIPT' && SCRIPT_ELEMENT_REJECTS_TEXTNODE_APPENDING) {
        element.text = content;
        return element;
      }

      if (ANY_INNERHTML_BUGGY) {
        if (tagName in Element._insertionTranslations.tags) {
          while (element.firstChild) {
            element.removeChild(element.firstChild);
          }
          Element._getContentFromAnonymousElement(tagName, content.stripScripts())
            .each(function(node) {
              element.appendChild(node)
            });
        } else if (LINK_ELEMENT_INNERHTML_BUGGY && Object.isString(content) && content.indexOf('<link') > -1) {
          while (element.firstChild) {
            element.removeChild(element.firstChild);
          }
          var nodes = Element._getContentFromAnonymousElement(tagName, content.stripScripts(), true);
          nodes.each(function(node) { element.appendChild(node) });
        }
        else {
          element.innerHTML = content.stripScripts();
        }
      }
      else {
        element.innerHTML = content.stripScripts();
      }

      content.evalScripts.bind(content).defer();
      return element;
    }

    return update;
  })(),

  replace: function(element, content) {
    element = $(element);
    if (content && content.toElement) content = content.toElement();
    else if (!Object.isElement(content)) {
      content = Object.toHTML(content);
      var range = element.ownerDocument.createRange();
      range.selectNode(element);
      content.evalScripts.bind(content).defer();
      content = range.createContextualFragment(content.stripScripts());
    }
    element.parentNode.replaceChild(content, element);
    return element;
  },

  insert: function(element, insertions) {
    element = $(element);

    if (Object.isString(insertions) || Object.isNumber(insertions) ||
        Object.isElement(insertions) || (insertions && (insertions.toElement || insertions.toHTML)))
          insertions = {bottom:insertions};

    var content, insert, tagName, childNodes;

    for (var position in insertions) {
      content  = insertions[position];
      position = position.toLowerCase();
      insert = Element._insertionTranslations[position];

      if (content && content.toElement) content = content.toElement();
      if (Object.isElement(content)) {
        insert(element, content);
        continue;
      }

      content = Object.toHTML(content);

      tagName = ((position == 'before' || position == 'after')
        ? element.parentNode : element).tagName.toUpperCase();

      childNodes = Element._getContentFromAnonymousElement(tagName, content.stripScripts());

      if (position == 'top' || position == 'after') childNodes.reverse();
      childNodes.each(insert.curry(element));

      content.evalScripts.bind(content).defer();
    }

    return element;
  },

  wrap: function(element, wrapper, attributes) {
    element = $(element);
    if (Object.isElement(wrapper))
      $(wrapper).writeAttribute(attributes || { });
    else if (Object.isString(wrapper)) wrapper = new Element(wrapper, attributes);
    else wrapper = new Element('div', wrapper);
    if (element.parentNode)
      element.parentNode.replaceChild(wrapper, element);
    wrapper.appendChild(element);
    return wrapper;
  },

  inspect: function(element) {
    element = $(element);
    var result = '<' + element.tagName.toLowerCase();
    $H({'id': 'id', 'className': 'class'}).each(function(pair) {
      var property = pair.first(),
          attribute = pair.last(),
          value = (element[property] || '').toString();
      if (value) result += ' ' + attribute + '=' + value.inspect(true);
    });
    return result + '>';
  },

  recursivelyCollect: function(element, property, maximumLength) {
    element = $(element);
    maximumLength = maximumLength || -1;
    var elements = [];

    while (element = element[property]) {
      if (element.nodeType == 1)
        elements.push(Element.extend(element));
      if (elements.length == maximumLength)
        break;
    }

    return elements;
  },

  ancestors: function(element) {
    return Element.recursivelyCollect(element, 'parentNode');
  },

  descendants: function(element) {
    return Element.select(element, "*");
  },

  firstDescendant: function(element) {
    element = $(element).firstChild;
    while (element && element.nodeType != 1) element = element.nextSibling;
    return $(element);
  },

  immediateDescendants: function(element) {
    var results = [], child = $(element).firstChild;
    while (child) {
      if (child.nodeType === 1) {
        results.push(Element.extend(child));
      }
      child = child.nextSibling;
    }
    return results;
  },

  previousSiblings: function(element, maximumLength) {
    return Element.recursivelyCollect(element, 'previousSibling');
  },

  nextSiblings: function(element) {
    return Element.recursivelyCollect(element, 'nextSibling');
  },

  siblings: function(element) {
    element = $(element);
    return Element.previousSiblings(element).reverse()
      .concat(Element.nextSiblings(element));
  },

  match: function(element, selector) {
    element = $(element);
    if (Object.isString(selector))
      return Prototype.Selector.match(element, selector);
    return selector.match(element);
  },

  up: function(element, expression, index) {
    element = $(element);
    if (arguments.length == 1) return $(element.parentNode);
    var ancestors = Element.ancestors(element);
    return Object.isNumber(expression) ? ancestors[expression] :
      Prototype.Selector.find(ancestors, expression, index);
  },

  down: function(element, expression, index) {
    element = $(element);
    if (arguments.length == 1) return Element.firstDescendant(element);
    return Object.isNumber(expression) ? Element.descendants(element)[expression] :
      Element.select(element, expression)[index || 0];
  },

  previous: function(element, expression, index) {
    element = $(element);
    if (Object.isNumber(expression)) index = expression, expression = false;
    if (!Object.isNumber(index)) index = 0;

    if (expression) {
      return Prototype.Selector.find(element.previousSiblings(), expression, index);
    } else {
      return element.recursivelyCollect("previousSibling", index + 1)[index];
    }
  },

  next: function(element, expression, index) {
    element = $(element);
    if (Object.isNumber(expression)) index = expression, expression = false;
    if (!Object.isNumber(index)) index = 0;

    if (expression) {
      return Prototype.Selector.find(element.nextSiblings(), expression, index);
    } else {
      var maximumLength = Object.isNumber(index) ? index + 1 : 1;
      return element.recursivelyCollect("nextSibling", index + 1)[index];
    }
  },


  select: function(element) {
    element = $(element);
    var expressions = Array.prototype.slice.call(arguments, 1).join(', ');
    return Prototype.Selector.select(expressions, element);
  },

  adjacent: function(element) {
    element = $(element);
    var expressions = Array.prototype.slice.call(arguments, 1).join(', ');
    return Prototype.Selector.select(expressions, element.parentNode).without(element);
  },

  identify: function(element) {
    element = $(element);
    var id = Element.readAttribute(element, 'id');
    if (id) return id;
    do { id = 'anonymous_element_' + Element.idCounter++ } while ($(id));
    Element.writeAttribute(element, 'id', id);
    return id;
  },

  readAttribute: function(element, name) {
    element = $(element);
    if (Prototype.Browser.IE) {
      var t = Element._attributeTranslations.read;
      if (t.values[name]) return t.values[name](element, name);
      if (t.names[name]) name = t.names[name];
      if (name.include(':')) {
        return (!element.attributes || !element.attributes[name]) ? null :
         element.attributes[name].value;
      }
    }
    return element.getAttribute(name);
  },

  writeAttribute: function(element, name, value) {
    element = $(element);
    var attributes = { }, t = Element._attributeTranslations.write;

    if (typeof name == 'object') attributes = name;
    else attributes[name] = Object.isUndefined(value) ? true : value;

    for (var attr in attributes) {
      name = t.names[attr] || attr;
      value = attributes[attr];
      if (t.values[attr]) name = t.values[attr](element, value);
      if (value === false || value === null)
        element.removeAttribute(name);
      else if (value === true)
        element.setAttribute(name, name);
      else element.setAttribute(name, value);
    }
    return element;
  },

  getHeight: function(element) {
    return Element.getDimensions(element).height;
  },

  getWidth: function(element) {
    return Element.getDimensions(element).width;
  },

  classNames: function(element) {
    return new Element.ClassNames(element);
  },

  hasClassName: function(element, className) {
    if (!(element = $(element))) return;
    var elementClassName = element.className;
    return (elementClassName.length > 0 && (elementClassName == className ||
      new RegExp("(^|\\s)" + className + "(\\s|$)").test(elementClassName)));
  },

  addClassName: function(element, className) {
    if (!(element = $(element))) return;
    if (!Element.hasClassName(element, className))
      element.className += (element.className ? ' ' : '') + className;
    return element;
  },

  removeClassName: function(element, className) {
    if (!(element = $(element))) return;
    element.className = element.className.replace(
      new RegExp("(^|\\s+)" + className + "(\\s+|$)"), ' ').strip();
    return element;
  },

  toggleClassName: function(element, className) {
    if (!(element = $(element))) return;
    return Element[Element.hasClassName(element, className) ?
      'removeClassName' : 'addClassName'](element, className);
  },

  cleanWhitespace: function(element) {
    element = $(element);
    var node = element.firstChild;
    while (node) {
      var nextNode = node.nextSibling;
      if (node.nodeType == 3 && !/\S/.test(node.nodeValue))
        element.removeChild(node);
      node = nextNode;
    }
    return element;
  },

  empty: function(element) {
    return $(element).innerHTML.blank();
  },

  descendantOf: function(element, ancestor) {
    element = $(element), ancestor = $(ancestor);

    if (element.compareDocumentPosition)
      return (element.compareDocumentPosition(ancestor) & 8) === 8;

    if (ancestor.contains)
      return ancestor.contains(element) && ancestor !== element;

    while (element = element.parentNode)
      if (element == ancestor) return true;

    return false;
  },

  scrollTo: function(element) {
    element = $(element);
    var pos = Element.cumulativeOffset(element);
    window.scrollTo(pos[0], pos[1]);
    return element;
  },

  getStyle: function(element, style) {
    element = $(element);
    style = style == 'float' ? 'cssFloat' : style.camelize();
    var value = element.style[style];
    if (!value || value == 'auto') {
      var css = document.defaultView.getComputedStyle(element, null);
      value = css ? css[style] : null;
    }
    if (style == 'opacity') return value ? parseFloat(value) : 1.0;
    return value == 'auto' ? null : value;
  },

  getOpacity: function(element) {
    return $(element).getStyle('opacity');
  },

  setStyle: function(element, styles) {
    element = $(element);
    var elementStyle = element.style, match;
    if (Object.isString(styles)) {
      element.style.cssText += ';' + styles;
      return styles.include('opacity') ?
        element.setOpacity(styles.match(/opacity:\s*(\d?\.?\d*)/)[1]) : element;
    }
    for (var property in styles)
      if (property == 'opacity') element.setOpacity(styles[property]);
      else
        elementStyle[(property == 'float' || property == 'cssFloat') ?
          (Object.isUndefined(elementStyle.styleFloat) ? 'cssFloat' : 'styleFloat') :
            property] = styles[property];

    return element;
  },

  setOpacity: function(element, value) {
    element = $(element);
    element.style.opacity = (value == 1 || value === '') ? '' :
      (value < 0.00001) ? 0 : value;
    return element;
  },

  makePositioned: function(element) {
    element = $(element);
    var pos = Element.getStyle(element, 'position');
    if (pos == 'static' || !pos) {
      element._madePositioned = true;
      element.style.position = 'relative';
      if (Prototype.Browser.Opera) {
        element.style.top = 0;
        element.style.left = 0;
      }
    }
    return element;
  },

  undoPositioned: function(element) {
    element = $(element);
    if (element._madePositioned) {
      element._madePositioned = undefined;
      element.style.position =
        element.style.top =
        element.style.left =
        element.style.bottom =
        element.style.right = '';
    }
    return element;
  },

  makeClipping: function(element) {
    element = $(element);
    if (element._overflow) return element;
    element._overflow = Element.getStyle(element, 'overflow') || 'auto';
    if (element._overflow !== 'hidden')
      element.style.overflow = 'hidden';
    return element;
  },

  undoClipping: function(element) {
    element = $(element);
    if (!element._overflow) return element;
    element.style.overflow = element._overflow == 'auto' ? '' : element._overflow;
    element._overflow = null;
    return element;
  },

  clonePosition: function(element, source) {
    var options = Object.extend({
      setLeft:    true,
      setTop:     true,
      setWidth:   true,
      setHeight:  true,
      offsetTop:  0,
      offsetLeft: 0
    }, arguments[2] || { });

    source = $(source);
    var p = Element.viewportOffset(source), delta = [0, 0], parent = null;

    element = $(element);

    if (Element.getStyle(element, 'position') == 'absolute') {
      parent = Element.getOffsetParent(element);
      delta = Element.viewportOffset(parent);
    }

    if (parent == document.body) {
      delta[0] -= document.body.offsetLeft;
      delta[1] -= document.body.offsetTop;
    }

    if (options.setLeft)   element.style.left  = (p[0] - delta[0] + options.offsetLeft) + 'px';
    if (options.setTop)    element.style.top   = (p[1] - delta[1] + options.offsetTop) + 'px';
    if (options.setWidth)  element.style.width = source.offsetWidth + 'px';
    if (options.setHeight) element.style.height = source.offsetHeight + 'px';
    return element;
  }
};

Object.extend(Element.Methods, {
  getElementsBySelector: Element.Methods.select,

  childElements: Element.Methods.immediateDescendants
});

Element._attributeTranslations = {
  write: {
    names: {
      className: 'class',
      htmlFor:   'for'
    },
    values: { }
  }
};

if (Prototype.Browser.Opera) {
  Element.Methods.getStyle = Element.Methods.getStyle.wrap(
    function(proceed, element, style) {
      switch (style) {
        case 'height': case 'width':
          if (!Element.visible(element)) return null;

          var dim = parseInt(proceed(element, style), 10);

          if (dim !== element['offset' + style.capitalize()])
            return dim + 'px';

          var properties;
          if (style === 'height') {
            properties = ['border-top-width', 'padding-top',
             'padding-bottom', 'border-bottom-width'];
          }
          else {
            properties = ['border-left-width', 'padding-left',
             'padding-right', 'border-right-width'];
          }
          return properties.inject(dim, function(memo, property) {
            var val = proceed(element, property);
            return val === null ? memo : memo - parseInt(val, 10);
          }) + 'px';
        default: return proceed(element, style);
      }
    }
  );

  Element.Methods.readAttribute = Element.Methods.readAttribute.wrap(
    function(proceed, element, attribute) {
      if (attribute === 'title') return element.title;
      return proceed(element, attribute);
    }
  );
}

else if (Prototype.Browser.IE) {
  Element.Methods.getStyle = function(element, style) {
    element = $(element);
    style = (style == 'float' || style == 'cssFloat') ? 'styleFloat' : style.camelize();
    var value = element.style[style];
    if (!value && element.currentStyle) value = element.currentStyle[style];

    if (style == 'opacity') {
      if (value = (element.getStyle('filter') || '').match(/alpha\(opacity=(.*)\)/))
        if (value[1]) return parseFloat(value[1]) / 100;
      return 1.0;
    }

    if (value == 'auto') {
      if ((style == 'width' || style == 'height') && (element.getStyle('display') != 'none'))
        return element['offset' + style.capitalize()] + 'px';
      return null;
    }
    return value;
  };

  Element.Methods.setOpacity = function(element, value) {
    function stripAlpha(filter){
      return filter.replace(/alpha\([^\)]*\)/gi,'');
    }
    element = $(element);
    var currentStyle = element.currentStyle;
    if ((currentStyle && !currentStyle.hasLayout) ||
      (!currentStyle && element.style.zoom == 'normal'))
        element.style.zoom = 1;

    var filter = element.getStyle('filter'), style = element.style;
    if (value == 1 || value === '') {
      (filter = stripAlpha(filter)) ?
        style.filter = filter : style.removeAttribute('filter');
      return element;
    } else if (value < 0.00001) value = 0;
    style.filter = stripAlpha(filter) +
      'alpha(opacity=' + (value * 100) + ')';
    return element;
  };

  Element._attributeTranslations = (function(){

    var classProp = 'className',
        forProp = 'for',
        el = document.createElement('div');

    el.setAttribute(classProp, 'x');

    if (el.className !== 'x') {
      el.setAttribute('class', 'x');
      if (el.className === 'x') {
        classProp = 'class';
      }
    }
    el = null;

    el = document.createElement('label');
    el.setAttribute(forProp, 'x');
    if (el.htmlFor !== 'x') {
      el.setAttribute('htmlFor', 'x');
      if (el.htmlFor === 'x') {
        forProp = 'htmlFor';
      }
    }
    el = null;

    return {
      read: {
        names: {
          'class':      classProp,
          'className':  classProp,
          'for':        forProp,
          'htmlFor':    forProp
        },
        values: {
          _getAttr: function(element, attribute) {
            return element.getAttribute(attribute);
          },
          _getAttr2: function(element, attribute) {
            return element.getAttribute(attribute, 2);
          },
          _getAttrNode: function(element, attribute) {
            var node = element.getAttributeNode(attribute);
            return node ? node.value : "";
          },
          _getEv: (function(){

            var el = document.createElement('div'), f;
            el.onclick = Prototype.emptyFunction;
            var value = el.getAttribute('onclick');

            if (String(value).indexOf('{') > -1) {
              f = function(element, attribute) {
                attribute = element.getAttribute(attribute);
                if (!attribute) return null;
                attribute = attribute.toString();
                attribute = attribute.split('{')[1];
                attribute = attribute.split('}')[0];
                return attribute.strip();
              };
            }
            else if (value === '') {
              f = function(element, attribute) {
                attribute = element.getAttribute(attribute);
                if (!attribute) return null;
                return attribute.strip();
              };
            }
            el = null;
            return f;
          })(),
          _flag: function(element, attribute) {
            return $(element).hasAttribute(attribute) ? attribute : null;
          },
          style: function(element) {
            return element.style.cssText.toLowerCase();
          },
          title: function(element) {
            return element.title;
          }
        }
      }
    }
  })();

  Element._attributeTranslations.write = {
    names: Object.extend({
      cellpadding: 'cellPadding',
      cellspacing: 'cellSpacing'
    }, Element._attributeTranslations.read.names),
    values: {
      checked: function(element, value) {
        element.checked = !!value;
      },

      style: function(element, value) {
        element.style.cssText = value ? value : '';
      }
    }
  };

  Element._attributeTranslations.has = {};

  $w('colSpan rowSpan vAlign dateTime accessKey tabIndex ' +
      'encType maxLength readOnly longDesc frameBorder').each(function(attr) {
    Element._attributeTranslations.write.names[attr.toLowerCase()] = attr;
    Element._attributeTranslations.has[attr.toLowerCase()] = attr;
  });

  (function(v) {
    Object.extend(v, {
      href:        v._getAttr2,
      src:         v._getAttr2,
      type:        v._getAttr,
      action:      v._getAttrNode,
      disabled:    v._flag,
      checked:     v._flag,
      readonly:    v._flag,
      multiple:    v._flag,
      onload:      v._getEv,
      onunload:    v._getEv,
      onclick:     v._getEv,
      ondblclick:  v._getEv,
      onmousedown: v._getEv,
      onmouseup:   v._getEv,
      onmouseover: v._getEv,
      onmousemove: v._getEv,
      onmouseout:  v._getEv,
      onfocus:     v._getEv,
      onblur:      v._getEv,
      onkeypress:  v._getEv,
      onkeydown:   v._getEv,
      onkeyup:     v._getEv,
      onsubmit:    v._getEv,
      onreset:     v._getEv,
      onselect:    v._getEv,
      onchange:    v._getEv
    });
  })(Element._attributeTranslations.read.values);

  if (Prototype.BrowserFeatures.ElementExtensions) {
    (function() {
      function _descendants(element) {
        var nodes = element.getElementsByTagName('*'), results = [];
        for (var i = 0, node; node = nodes[i]; i++)
          if (node.tagName !== "!") // Filter out comment nodes.
            results.push(node);
        return results;
      }

      Element.Methods.down = function(element, expression, index) {
        element = $(element);
        if (arguments.length == 1) return element.firstDescendant();
        return Object.isNumber(expression) ? _descendants(element)[expression] :
          Element.select(element, expression)[index || 0];
      }
    })();
  }

}

else if (Prototype.Browser.Gecko && /rv:1\.8\.0/.test(navigator.userAgent)) {
  Element.Methods.setOpacity = function(element, value) {
    element = $(element);
    element.style.opacity = (value == 1) ? 0.999999 :
      (value === '') ? '' : (value < 0.00001) ? 0 : value;
    return element;
  };
}

else if (Prototype.Browser.WebKit) {
  Element.Methods.setOpacity = function(element, value) {
    element = $(element);
    element.style.opacity = (value == 1 || value === '') ? '' :
      (value < 0.00001) ? 0 : value;

    if (value == 1)
      if (element.tagName.toUpperCase() == 'IMG' && element.width) {
        element.width++; element.width--;
      } else try {
        var n = document.createTextNode(' ');
        element.appendChild(n);
        element.removeChild(n);
      } catch (e) { }

    return element;
  };
}

if ('outerHTML' in document.documentElement) {
  Element.Methods.replace = function(element, content) {
    element = $(element);

    if (content && content.toElement) content = content.toElement();
    if (Object.isElement(content)) {
      element.parentNode.replaceChild(content, element);
      return element;
    }

    content = Object.toHTML(content);
    var parent = element.parentNode, tagName = parent.tagName.toUpperCase();

    if (Element._insertionTranslations.tags[tagName]) {
      var nextSibling = element.next(),
          fragments = Element._getContentFromAnonymousElement(tagName, content.stripScripts());
      parent.removeChild(element);
      if (nextSibling)
        fragments.each(function(node) { parent.insertBefore(node, nextSibling) });
      else
        fragments.each(function(node) { parent.appendChild(node) });
    }
    else element.outerHTML = content.stripScripts();

    content.evalScripts.bind(content).defer();
    return element;
  };
}

Element._returnOffset = function(l, t) {
  var result = [l, t];
  result.left = l;
  result.top = t;
  return result;
};

Element._getContentFromAnonymousElement = function(tagName, html, force) {
  var div = new Element('div'),
      t = Element._insertionTranslations.tags[tagName];

  var workaround = false;
  if (t) workaround = true;
  else if (force) {
    workaround = true;
    t = ['', '', 0];
  }

  if (workaround) {
    div.innerHTML = '&nbsp;' + t[0] + html + t[1];
    div.removeChild(div.firstChild);
    for (var i = t[2]; i--; ) {
      div = div.firstChild;
    }
  }
  else {
    div.innerHTML = html;
  }
  return $A(div.childNodes);
};

Element._insertionTranslations = {
  before: function(element, node) {
    element.parentNode.insertBefore(node, element);
  },
  top: function(element, node) {
    element.insertBefore(node, element.firstChild);
  },
  bottom: function(element, node) {
    element.appendChild(node);
  },
  after: function(element, node) {
    element.parentNode.insertBefore(node, element.nextSibling);
  },
  tags: {
    TABLE:  ['<table>',                '</table>',                   1],
    TBODY:  ['<table><tbody>',         '</tbody></table>',           2],
    TR:     ['<table><tbody><tr>',     '</tr></tbody></table>',      3],
    TD:     ['<table><tbody><tr><td>', '</td></tr></tbody></table>', 4],
    SELECT: ['<select>',               '</select>',                  1]
  }
};

(function() {
  var tags = Element._insertionTranslations.tags;
  Object.extend(tags, {
    THEAD: tags.TBODY,
    TFOOT: tags.TBODY,
    TH:    tags.TD
  });
})();

Element.Methods.Simulated = {
  hasAttribute: function(element, attribute) {
    attribute = Element._attributeTranslations.has[attribute] || attribute;
    var node = $(element).getAttributeNode(attribute);
    return !!(node && node.specified);
  }
};

Element.Methods.ByTag = { };

Object.extend(Element, Element.Methods);

(function(div) {

  if (!Prototype.BrowserFeatures.ElementExtensions && div['__proto__']) {
    window.HTMLElement = { };
    window.HTMLElement.prototype = div['__proto__'];
    Prototype.BrowserFeatures.ElementExtensions = true;
  }

  div = null;

})(document.createElement('div'));

Element.extend = (function() {

  function checkDeficiency(tagName) {
    if (typeof window.Element != 'undefined') {
      var proto = window.Element.prototype;
      if (proto) {
        var id = '_' + (Math.random()+'').slice(2),
            el = document.createElement(tagName);
        proto[id] = 'x';
        var isBuggy = (el[id] !== 'x');
        delete proto[id];
        el = null;
        return isBuggy;
      }
    }
    return false;
  }

  function extendElementWith(element, methods) {
    for (var property in methods) {
      var value = methods[property];
      if (Object.isFunction(value) && !(property in element))
        element[property] = value.methodize();
    }
  }

  var HTMLOBJECTELEMENT_PROTOTYPE_BUGGY = checkDeficiency('object');

  if (Prototype.BrowserFeatures.SpecificElementExtensions) {
    if (HTMLOBJECTELEMENT_PROTOTYPE_BUGGY) {
      return function(element) {
        if (element && typeof element._extendedByPrototype == 'undefined') {
          var t = element.tagName;
          if (t && (/^(?:object|applet|embed)$/i.test(t))) {
            extendElementWith(element, Element.Methods);
            extendElementWith(element, Element.Methods.Simulated);
            extendElementWith(element, Element.Methods.ByTag[t.toUpperCase()]);
          }
        }
        return element;
      }
    }
    return Prototype.K;
  }

  var Methods = { }, ByTag = Element.Methods.ByTag;

  var extend = Object.extend(function(element) {
    if (!element || typeof element._extendedByPrototype != 'undefined' ||
        element.nodeType != 1 || element == window) return element;

    var methods = Object.clone(Methods),
        tagName = element.tagName.toUpperCase();

    if (ByTag[tagName]) Object.extend(methods, ByTag[tagName]);

    extendElementWith(element, methods);

    element._extendedByPrototype = Prototype.emptyFunction;
    return element;

  }, {
    refresh: function() {
      if (!Prototype.BrowserFeatures.ElementExtensions) {
        Object.extend(Methods, Element.Methods);
        Object.extend(Methods, Element.Methods.Simulated);
      }
    }
  });

  extend.refresh();
  return extend;
})();

if (document.documentElement.hasAttribute) {
  Element.hasAttribute = function(element, attribute) {
    return element.hasAttribute(attribute);
  };
}
else {
  Element.hasAttribute = Element.Methods.Simulated.hasAttribute;
}

Element.addMethods = function(methods) {
  var F = Prototype.BrowserFeatures, T = Element.Methods.ByTag;

  if (!methods) {
    Object.extend(Form, Form.Methods);
    Object.extend(Form.Element, Form.Element.Methods);
    Object.extend(Element.Methods.ByTag, {
      "FORM":     Object.clone(Form.Methods),
      "INPUT":    Object.clone(Form.Element.Methods),
      "SELECT":   Object.clone(Form.Element.Methods),
      "TEXTAREA": Object.clone(Form.Element.Methods),
      "BUTTON":   Object.clone(Form.Element.Methods)
    });
  }

  if (arguments.length == 2) {
    var tagName = methods;
    methods = arguments[1];
  }

  if (!tagName) Object.extend(Element.Methods, methods || { });
  else {
    if (Object.isArray(tagName)) tagName.each(extend);
    else extend(tagName);
  }

  function extend(tagName) {
    tagName = tagName.toUpperCase();
    if (!Element.Methods.ByTag[tagName])
      Element.Methods.ByTag[tagName] = { };
    Object.extend(Element.Methods.ByTag[tagName], methods);
  }

  function copy(methods, destination, onlyIfAbsent) {
    onlyIfAbsent = onlyIfAbsent || false;
    for (var property in methods) {
      var value = methods[property];
      if (!Object.isFunction(value)) continue;
      if (!onlyIfAbsent || !(property in destination))
        destination[property] = value.methodize();
    }
  }

  function findDOMClass(tagName) {
    var klass;
    var trans = {
      "OPTGROUP": "OptGroup", "TEXTAREA": "TextArea", "P": "Paragraph",
      "FIELDSET": "FieldSet", "UL": "UList", "OL": "OList", "DL": "DList",
      "DIR": "Directory", "H1": "Heading", "H2": "Heading", "H3": "Heading",
      "H4": "Heading", "H5": "Heading", "H6": "Heading", "Q": "Quote",
      "INS": "Mod", "DEL": "Mod", "A": "Anchor", "IMG": "Image", "CAPTION":
      "TableCaption", "COL": "TableCol", "COLGROUP": "TableCol", "THEAD":
      "TableSection", "TFOOT": "TableSection", "TBODY": "TableSection", "TR":
      "TableRow", "TH": "TableCell", "TD": "TableCell", "FRAMESET":
      "FrameSet", "IFRAME": "IFrame"
    };
    if (trans[tagName]) klass = 'HTML' + trans[tagName] + 'Element';
    if (window[klass]) return window[klass];
    klass = 'HTML' + tagName + 'Element';
    if (window[klass]) return window[klass];
    klass = 'HTML' + tagName.capitalize() + 'Element';
    if (window[klass]) return window[klass];

    var element = document.createElement(tagName),
        proto = element['__proto__'] || element.constructor.prototype;

    element = null;
    return proto;
  }

  var elementPrototype = window.HTMLElement ? HTMLElement.prototype :
   Element.prototype;

  if (F.ElementExtensions) {
    copy(Element.Methods, elementPrototype);
    copy(Element.Methods.Simulated, elementPrototype, true);
  }

  if (F.SpecificElementExtensions) {
    for (var tag in Element.Methods.ByTag) {
      var klass = findDOMClass(tag);
      if (Object.isUndefined(klass)) continue;
      copy(T[tag], klass.prototype);
    }
  }

  Object.extend(Element, Element.Methods);
  delete Element.ByTag;

  if (Element.extend.refresh) Element.extend.refresh();
  Element.cache = { };
};


document.viewport = {

  getDimensions: function() {
    return { width: this.getWidth(), height: this.getHeight() };
  },

  getScrollOffsets: function() {
    return Element._returnOffset(
      window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft,
      window.pageYOffset || document.documentElement.scrollTop  || document.body.scrollTop);
  }
};

(function(viewport) {
  var B = Prototype.Browser, doc = document, element, property = {};

  function getRootElement() {
    if (B.WebKit && !doc.evaluate)
      return document;

    if (B.Opera && window.parseFloat(window.opera.version()) < 9.5)
      return document.body;

    return document.documentElement;
  }

  function define(D) {
    if (!element) element = getRootElement();

    property[D] = 'client' + D;

    viewport['get' + D] = function() { return element[property[D]] };
    return viewport['get' + D]();
  }

  viewport.getWidth  = define.curry('Width');

  viewport.getHeight = define.curry('Height');
})(document.viewport);


Element.Storage = {
  UID: 1
};

Element.addMethods({
  getStorage: function(element) {
    if (!(element = $(element))) return;

    var uid;
    if (element === window) {
      uid = 0;
    } else {
      if (typeof element._prototypeUID === "undefined")
        element._prototypeUID = Element.Storage.UID++;
      uid = element._prototypeUID;
    }

    if (!Element.Storage[uid])
      Element.Storage[uid] = $H();

    return Element.Storage[uid];
  },

  store: function(element, key, value) {
    if (!(element = $(element))) return;

    if (arguments.length === 2) {
      Element.getStorage(element).update(key);
    } else {
      Element.getStorage(element).set(key, value);
    }

    return element;
  },

  retrieve: function(element, key, defaultValue) {
    if (!(element = $(element))) return;
    var hash = Element.getStorage(element), value = hash.get(key);

    if (Object.isUndefined(value)) {
      hash.set(key, defaultValue);
      value = defaultValue;
    }

    return value;
  },

  clone: function(element, deep) {
    if (!(element = $(element))) return;
    var clone = element.cloneNode(deep);
    clone._prototypeUID = void 0;
    if (deep) {
      var descendants = Element.select(clone, '*'),
          i = descendants.length;
      while (i--) {
        descendants[i]._prototypeUID = void 0;
      }
    }
    return Element.extend(clone);
  },

  purge: function(element) {
    if (!(element = $(element))) return;
    var purgeElement = Element._purgeElement;

    purgeElement(element);

    var descendants = element.getElementsByTagName('*'),
     i = descendants.length;

    while (i--) purgeElement(descendants[i]);

    return null;
  }
});

(function() {

  function toDecimal(pctString) {
    var match = pctString.match(/^(\d+)%?$/i);
    if (!match) return null;
    return (Number(match[1]) / 100);
  }

  function getPixelValue(value, property, context) {
    var element = null;
    if (Object.isElement(value)) {
      element = value;
      value = element.getStyle(property);
    }

    if (value === null) {
      return null;
    }

    if ((/^(?:-)?\d+(\.\d+)?(px)?$/i).test(value)) {
      return window.parseFloat(value);
    }

    var isPercentage = value.include('%'), isViewport = (context === document.viewport);

    if (/\d/.test(value) && element && element.runtimeStyle && !(isPercentage && isViewport)) {
      var style = element.style.left, rStyle = element.runtimeStyle.left;
      element.runtimeStyle.left = element.currentStyle.left;
      element.style.left = value || 0;
      value = element.style.pixelLeft;
      element.style.left = style;
      element.runtimeStyle.left = rStyle;

      return value;
    }

    if (element && isPercentage) {
      context = context || element.parentNode;
      var decimal = toDecimal(value);
      var whole = null;
      var position = element.getStyle('position');

      var isHorizontal = property.include('left') || property.include('right') ||
       property.include('width');

      var isVertical =  property.include('top') || property.include('bottom') ||
        property.include('height');

      if (context === document.viewport) {
        if (isHorizontal) {
          whole = document.viewport.getWidth();
        } else if (isVertical) {
          whole = document.viewport.getHeight();
        }
      } else {
        if (isHorizontal) {
          whole = $(context).measure('width');
        } else if (isVertical) {
          whole = $(context).measure('height');
        }
      }

      return (whole === null) ? 0 : whole * decimal;
    }

    return 0;
  }

  function toCSSPixels(number) {
    if (Object.isString(number) && number.endsWith('px')) {
      return number;
    }
    return number + 'px';
  }

  function isDisplayed(element) {
    var originalElement = element;
    while (element && element.parentNode) {
      var display = element.getStyle('display');
      if (display === 'none') {
        return false;
      }
      element = $(element.parentNode);
    }
    return true;
  }

  var hasLayout = Prototype.K;
  if ('currentStyle' in document.documentElement) {
    hasLayout = function(element) {
      if (!element.currentStyle.hasLayout) {
        element.style.zoom = 1;
      }
      return element;
    };
  }

  function cssNameFor(key) {
    if (key.include('border')) key = key + '-width';
    return key.camelize();
  }

  Element.Layout = Class.create(Hash, {
    initialize: function($super, element, preCompute) {
      $super();
      this.element = $(element);

      Element.Layout.PROPERTIES.each( function(property) {
        this._set(property, null);
      }, this);

      if (preCompute) {
        this._preComputing = true;
        this._begin();
        Element.Layout.PROPERTIES.each( this._compute, this );
        this._end();
        this._preComputing = false;
      }
    },

    _set: function(property, value) {
      return Hash.prototype.set.call(this, property, value);
    },

    set: function(property, value) {
      throw "Properties of Element.Layout are read-only.";
    },

    get: function($super, property) {
      var value = $super(property);
      return value === null ? this._compute(property) : value;
    },

    _begin: function() {
      if (this._prepared) return;

      var element = this.element;
      if (isDisplayed(element)) {
        this._prepared = true;
        return;
      }

      var originalStyles = {
        position:   element.style.position   || '',
        width:      element.style.width      || '',
        visibility: element.style.visibility || '',
        display:    element.style.display    || ''
      };

      element.store('prototype_original_styles', originalStyles);

      var position = element.getStyle('position'),
       width = element.getStyle('width');

      if (width === "0px" || width === null) {
        element.style.display = 'block';
        width = element.getStyle('width');
      }

      var context = (position === 'fixed') ? document.viewport :
       element.parentNode;

      element.setStyle({
        position:   'absolute',
        visibility: 'hidden',
        display:    'block'
      });

      var positionedWidth = element.getStyle('width');

      var newWidth;
      if (width && (positionedWidth === width)) {
        newWidth = getPixelValue(element, 'width', context);
      } else if (position === 'absolute' || position === 'fixed') {
        newWidth = getPixelValue(element, 'width', context);
      } else {
        var parent = element.parentNode, pLayout = $(parent).getLayout();

        newWidth = pLayout.get('width') -
         this.get('margin-left') -
         this.get('border-left') -
         this.get('padding-left') -
         this.get('padding-right') -
         this.get('border-right') -
         this.get('margin-right');
      }

      element.setStyle({ width: newWidth + 'px' });

      this._prepared = true;
    },

    _end: function() {
      var element = this.element;
      var originalStyles = element.retrieve('prototype_original_styles');
      element.store('prototype_original_styles', null);
      element.setStyle(originalStyles);
      this._prepared = false;
    },

    _compute: function(property) {
      var COMPUTATIONS = Element.Layout.COMPUTATIONS;
      if (!(property in COMPUTATIONS)) {
        throw "Property not found.";
      }

      return this._set(property, COMPUTATIONS[property].call(this, this.element));
    },

    toObject: function() {
      var args = $A(arguments);
      var keys = (args.length === 0) ? Element.Layout.PROPERTIES :
       args.join(' ').split(' ');
      var obj = {};
      keys.each( function(key) {
        if (!Element.Layout.PROPERTIES.include(key)) return;
        var value = this.get(key);
        if (value != null) obj[key] = value;
      }, this);
      return obj;
    },

    toHash: function() {
      var obj = this.toObject.apply(this, arguments);
      return new Hash(obj);
    },

    toCSS: function() {
      var args = $A(arguments);
      var keys = (args.length === 0) ? Element.Layout.PROPERTIES :
       args.join(' ').split(' ');
      var css = {};

      keys.each( function(key) {
        if (!Element.Layout.PROPERTIES.include(key)) return;
        if (Element.Layout.COMPOSITE_PROPERTIES.include(key)) return;

        var value = this.get(key);
        if (value != null) css[cssNameFor(key)] = value + 'px';
      }, this);
      return css;
    },

    inspect: function() {
      return "#<Element.Layout>";
    }
  });

  Object.extend(Element.Layout, {
    PROPERTIES: $w('height width top left right bottom border-left border-right border-top border-bottom padding-left padding-right padding-top padding-bottom margin-top margin-bottom margin-left margin-right padding-box-width padding-box-height border-box-width border-box-height margin-box-width margin-box-height'),

    COMPOSITE_PROPERTIES: $w('padding-box-width padding-box-height margin-box-width margin-box-height border-box-width border-box-height'),

    COMPUTATIONS: {
      'height': function(element) {
        if (!this._preComputing) this._begin();

        var bHeight = this.get('border-box-height');
        if (bHeight <= 0) {
          if (!this._preComputing) this._end();
          return 0;
        }

        var bTop = this.get('border-top'),
         bBottom = this.get('border-bottom');

        var pTop = this.get('padding-top'),
         pBottom = this.get('padding-bottom');

        if (!this._preComputing) this._end();

        return bHeight - bTop - bBottom - pTop - pBottom;
      },

      'width': function(element) {
        if (!this._preComputing) this._begin();

        var bWidth = this.get('border-box-width');
        if (bWidth <= 0) {
          if (!this._preComputing) this._end();
          return 0;
        }

        var bLeft = this.get('border-left'),
         bRight = this.get('border-right');

        var pLeft = this.get('padding-left'),
         pRight = this.get('padding-right');

        if (!this._preComputing) this._end();

        return bWidth - bLeft - bRight - pLeft - pRight;
      },

      'padding-box-height': function(element) {
        var height = this.get('height'),
         pTop = this.get('padding-top'),
         pBottom = this.get('padding-bottom');

        return height + pTop + pBottom;
      },

      'padding-box-width': function(element) {
        var width = this.get('width'),
         pLeft = this.get('padding-left'),
         pRight = this.get('padding-right');

        return width + pLeft + pRight;
      },

      'border-box-height': function(element) {
        if (!this._preComputing) this._begin();
        var height = element.offsetHeight;
        if (!this._preComputing) this._end();
        return height;
      },

      'border-box-width': function(element) {
        if (!this._preComputing) this._begin();
        var width = element.offsetWidth;
        if (!this._preComputing) this._end();
        return width;
      },

      'margin-box-height': function(element) {
        var bHeight = this.get('border-box-height'),
         mTop = this.get('margin-top'),
         mBottom = this.get('margin-bottom');

        if (bHeight <= 0) return 0;

        return bHeight + mTop + mBottom;
      },

      'margin-box-width': function(element) {
        var bWidth = this.get('border-box-width'),
         mLeft = this.get('margin-left'),
         mRight = this.get('margin-right');

        if (bWidth <= 0) return 0;

        return bWidth + mLeft + mRight;
      },

      'top': function(element) {
        var offset = element.positionedOffset();
        return offset.top;
      },

      'bottom': function(element) {
        var offset = element.positionedOffset(),
         parent = element.getOffsetParent(),
         pHeight = parent.measure('height');

        var mHeight = this.get('border-box-height');

        return pHeight - mHeight - offset.top;
      },

      'left': function(element) {
        var offset = element.positionedOffset();
        return offset.left;
      },

      'right': function(element) {
        var offset = element.positionedOffset(),
         parent = element.getOffsetParent(),
         pWidth = parent.measure('width');

        var mWidth = this.get('border-box-width');

        return pWidth - mWidth - offset.left;
      },

      'padding-top': function(element) {
        return getPixelValue(element, 'paddingTop');
      },

      'padding-bottom': function(element) {
        return getPixelValue(element, 'paddingBottom');
      },

      'padding-left': function(element) {
        return getPixelValue(element, 'paddingLeft');
      },

      'padding-right': function(element) {
        return getPixelValue(element, 'paddingRight');
      },

      'border-top': function(element) {
        return getPixelValue(element, 'borderTopWidth');
      },

      'border-bottom': function(element) {
        return getPixelValue(element, 'borderBottomWidth');
      },

      'border-left': function(element) {
        return getPixelValue(element, 'borderLeftWidth');
      },

      'border-right': function(element) {
        return getPixelValue(element, 'borderRightWidth');
      },

      'margin-top': function(element) {
        return getPixelValue(element, 'marginTop');
      },

      'margin-bottom': function(element) {
        return getPixelValue(element, 'marginBottom');
      },

      'margin-left': function(element) {
        return getPixelValue(element, 'marginLeft');
      },

      'margin-right': function(element) {
        return getPixelValue(element, 'marginRight');
      }
    }
  });

  if ('getBoundingClientRect' in document.documentElement) {
    Object.extend(Element.Layout.COMPUTATIONS, {
      'right': function(element) {
        var parent = hasLayout(element.getOffsetParent());
        var rect = element.getBoundingClientRect(),
         pRect = parent.getBoundingClientRect();

        return (pRect.right - rect.right).round();
      },

      'bottom': function(element) {
        var parent = hasLayout(element.getOffsetParent());
        var rect = element.getBoundingClientRect(),
         pRect = parent.getBoundingClientRect();

        return (pRect.bottom - rect.bottom).round();
      }
    });
  }

  Element.Offset = Class.create({
    initialize: function(left, top) {
      this.left = left.round();
      this.top  = top.round();

      this[0] = this.left;
      this[1] = this.top;
    },

    relativeTo: function(offset) {
      return new Element.Offset(
        this.left - offset.left,
        this.top  - offset.top
      );
    },

    inspect: function() {
      return "#<Element.Offset left: #{left} top: #{top}>".interpolate(this);
    },

    toString: function() {
      return "[#{left}, #{top}]".interpolate(this);
    },

    toArray: function() {
      return [this.left, this.top];
    }
  });

  function getLayout(element, preCompute) {
    return new Element.Layout(element, preCompute);
  }

  function measure(element, property) {
    return $(element).getLayout().get(property);
  }

  function getDimensions(element) {
    element = $(element);
    var display = Element.getStyle(element, 'display');

    if (display && display !== 'none') {
      return { width: element.offsetWidth, height: element.offsetHeight };
    }

    var style = element.style;
    var originalStyles = {
      visibility: style.visibility,
      position:   style.position,
      display:    style.display
    };

    var newStyles = {
      visibility: 'hidden',
      display:    'block'
    };

    if (originalStyles.position !== 'fixed')
      newStyles.position = 'absolute';

    Element.setStyle(element, newStyles);

    var dimensions = {
      width:  element.offsetWidth,
      height: element.offsetHeight
    };

    Element.setStyle(element, originalStyles);

    return dimensions;
  }

  function getOffsetParent(element) {
    element = $(element);

    if (isDocument(element) || isDetached(element) || isBody(element) || isHtml(element))
      return $(document.body);

    var isInline = (Element.getStyle(element, 'display') === 'inline');
    if (!isInline && element.offsetParent) return $(element.offsetParent);

    while ((element = element.parentNode) && element !== document.body) {
      if (Element.getStyle(element, 'position') !== 'static') {
        return isHtml(element) ? $(document.body) : $(element);
      }
    }

    return $(document.body);
  }


  function cumulativeOffset(element) {
    element = $(element);
    var valueT = 0, valueL = 0;
    if (element.parentNode) {
      do {
        valueT += element.offsetTop  || 0;
        valueL += element.offsetLeft || 0;
        element = element.offsetParent;
      } while (element);
    }
    return new Element.Offset(valueL, valueT);
  }

  function positionedOffset(element) {
    element = $(element);

    var layout = element.getLayout();

    var valueT = 0, valueL = 0;
    do {
      valueT += element.offsetTop  || 0;
      valueL += element.offsetLeft || 0;
      element = element.offsetParent;
      if (element) {
        if (isBody(element)) break;
        var p = Element.getStyle(element, 'position');
        if (p !== 'static') break;
      }
    } while (element);

    valueL -= layout.get('margin-top');
    valueT -= layout.get('margin-left');

    return new Element.Offset(valueL, valueT);
  }

  function cumulativeScrollOffset(element) {
    var valueT = 0, valueL = 0;
    do {
      valueT += element.scrollTop  || 0;
      valueL += element.scrollLeft || 0;
      element = element.parentNode;
    } while (element);
    return new Element.Offset(valueL, valueT);
  }

  function viewportOffset(forElement) {
    element = $(element);
    var valueT = 0, valueL = 0, docBody = document.body;

    var element = forElement;
    do {
      valueT += element.offsetTop  || 0;
      valueL += element.offsetLeft || 0;
      if (element.offsetParent == docBody &&
        Element.getStyle(element, 'position') == 'absolute') break;
    } while (element = element.offsetParent);

    element = forElement;
    do {
      if (element != docBody) {
        valueT -= element.scrollTop  || 0;
        valueL -= element.scrollLeft || 0;
      }
    } while (element = element.parentNode);
    return new Element.Offset(valueL, valueT);
  }

  function absolutize(element) {
    element = $(element);

    if (Element.getStyle(element, 'position') === 'absolute') {
      return element;
    }

    var offsetParent = getOffsetParent(element);
    var eOffset = element.viewportOffset(),
     pOffset = offsetParent.viewportOffset();

    var offset = eOffset.relativeTo(pOffset);
    var layout = element.getLayout();

    element.store('prototype_absolutize_original_styles', {
      left:   element.getStyle('left'),
      top:    element.getStyle('top'),
      width:  element.getStyle('width'),
      height: element.getStyle('height')
    });

    element.setStyle({
      position: 'absolute',
      top:    offset.top + 'px',
      left:   offset.left + 'px',
      width:  layout.get('width') + 'px',
      height: layout.get('height') + 'px'
    });

    return element;
  }
  
  function absolutizeTransform(element) {
    element = $(element);
    
    var offsetParent = getOffsetParent(element);
    var eOffset = element.viewportOffset(),
     pOffset = offsetParent.viewportOffset();

    var offset = eOffset.relativeTo(pOffset);
    var layout = element.getLayout();

    element.store('prototype_absolutize_original_styles', {
      left:   element.getStyle('left'),
      top:    element.getStyle('top')
    });

    element.setStyle({
      position: 'absolute',
      top:    '0px',
      left:   '0px',
      webkitTransform:  'translate3d(' + offset.left + 'px, ' + offset.top + 'px, 0)'
    });

    return element;
  }

  function relativize(element) {
    element = $(element);
    if (Element.getStyle(element, 'position') === 'relative') {
      return element;
    }

    var originalStyles =
     element.retrieve('prototype_absolutize_original_styles');

    if (originalStyles) element.setStyle(originalStyles);
    return element;
  }

  if (Prototype.Browser.IE) {
    getOffsetParent = getOffsetParent.wrap(
      function(proceed, element) {
        element = $(element);

        if (isDocument(element) || isDetached(element) || isBody(element) || isHtml(element))
          return $(document.body);

        var position = element.getStyle('position');
        if (position !== 'static') return proceed(element);

        element.setStyle({ position: 'relative' });
        var value = proceed(element);
        element.setStyle({ position: position });
        return value;
      }
    );

    positionedOffset = positionedOffset.wrap(function(proceed, element) {
      element = $(element);
      if (!element.parentNode) return new Element.Offset(0, 0);
      var position = element.getStyle('position');
      if (position !== 'static') return proceed(element);

      var offsetParent = element.getOffsetParent();
      if (offsetParent && offsetParent.getStyle('position') === 'fixed')
        hasLayout(offsetParent);

      element.setStyle({ position: 'relative' });
      var value = proceed(element);
      element.setStyle({ position: position });
      return value;
    });
  } else if (Prototype.Browser.Webkit) {
    cumulativeOffset = function(element) {
      element = $(element);
      var valueT = 0, valueL = 0;
      do {
        valueT += element.offsetTop  || 0;
        valueL += element.offsetLeft || 0;
        if (element.offsetParent == document.body)
          if (Element.getStyle(element, 'position') == 'absolute') break;

        element = element.offsetParent;
      } while (element);

      return new Element.Offset(valueL, valueT);
    };
  }


  Element.addMethods({
    getLayout:              getLayout,
    measure:                measure,
    getDimensions:          getDimensions,
    getOffsetParent:        getOffsetParent,
    cumulativeOffset:       cumulativeOffset,
    positionedOffset:       positionedOffset,
    cumulativeScrollOffset: cumulativeScrollOffset,
    viewportOffset:         viewportOffset,
    absolutize:             absolutize,
	absolutizeTransform:    absolutizeTransform,
    relativize:             relativize
  });

  function isBody(element) {
    return element.nodeName.toUpperCase() === 'BODY';
  }

  function isHtml(element) {
    return element.nodeName.toUpperCase() === 'HTML';
  }

  function isDocument(element) {
    return element.nodeType === Node.DOCUMENT_NODE;
  }

  function isDetached(element) {
    return element !== document.body &&
     !Element.descendantOf(element, document.body);
  }

  if ('getBoundingClientRect' in document.documentElement) {
    Element.addMethods({
      viewportOffset: function(element) {
        element = $(element);
        if (isDetached(element)) return new Element.Offset(0, 0);

        var rect = element.getBoundingClientRect(),
         docEl = document.documentElement;
        return new Element.Offset(rect.left - docEl.clientLeft,
         rect.top - docEl.clientTop);
      }
    });
  }
})();
window.$$ = function() {
  var expression = $A(arguments).join(', ');
  return Prototype.Selector.select(expression, document);
};

Prototype.Selector = (function() {

  function select() {
    throw new Error('Method "Prototype.Selector.select" must be defined.');
  }

  function match() {
    throw new Error('Method "Prototype.Selector.match" must be defined.');
  }

  function find(elements, expression, index) {
    index = index || 0;
    var match = Prototype.Selector.match, length = elements.length, matchIndex = 0, i;

    for (i = 0; i < length; i++) {
      if (match(elements[i], expression) && index == matchIndex++) {
        return Element.extend(elements[i]);
      }
    }
  }

  function extendElements(elements) {
    for (var i = 0, length = elements.length; i < length; i++) {
      Element.extend(elements[i]);
    }
    return elements;
  }


  var K = Prototype.K;

  return {
    select: select,
    match: match,
    find: find,
    extendElements: (Element.extend === K) ? K : extendElements,
    extendElement: Element.extend
  };
})();
/*!
 * Sizzle CSS Selector Engine - v1.0
 *  Copyright 2009, The Dojo Foundation
 *  Released under the MIT, BSD, and GPL Licenses.
 *  More information: http://sizzlejs.com/
 */
(function(){

var chunker = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^[\]]*\]|['"][^'"]*['"]|[^[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,
	done = 0,
	toString = Object.prototype.toString,
	hasDuplicate = false,
	baseHasDuplicate = true;

[0, 0].sort(function(){
	baseHasDuplicate = false;
	return 0;
});

var Sizzle = function(selector, context, results, seed) {
	results = results || [];
	var origContext = context = context || document;

	if ( context.nodeType !== 1 && context.nodeType !== 9 ) {
		return [];
	}

	if ( !selector || typeof selector !== "string" ) {
		return results;
	}

	var parts = [], m, set, checkSet, check, mode, extra, prune = true, contextXML = isXML(context),
		soFar = selector;

	while ( (chunker.exec(""), m = chunker.exec(soFar)) !== null ) {
		soFar = m[3];

		parts.push( m[1] );

		if ( m[2] ) {
			extra = m[3];
			break;
		}
	}

	if ( parts.length > 1 && origPOS.exec( selector ) ) {
		if ( parts.length === 2 && Expr.relative[ parts[0] ] ) {
			set = posProcess( parts[0] + parts[1], context );
		} else {
			set = Expr.relative[ parts[0] ] ?
				[ context ] :
				Sizzle( parts.shift(), context );

			while ( parts.length ) {
				selector = parts.shift();

				if ( Expr.relative[ selector ] )
					selector += parts.shift();

				set = posProcess( selector, set );
			}
		}
	} else {
		if ( !seed && parts.length > 1 && context.nodeType === 9 && !contextXML &&
				Expr.match.ID.test(parts[0]) && !Expr.match.ID.test(parts[parts.length - 1]) ) {
			var ret = Sizzle.find( parts.shift(), context, contextXML );
			context = ret.expr ? Sizzle.filter( ret.expr, ret.set )[0] : ret.set[0];
		}

		if ( context ) {
			var ret = seed ?
				{ expr: parts.pop(), set: makeArray(seed) } :
				Sizzle.find( parts.pop(), parts.length === 1 && (parts[0] === "~" || parts[0] === "+") && context.parentNode ? context.parentNode : context, contextXML );
			set = ret.expr ? Sizzle.filter( ret.expr, ret.set ) : ret.set;

			if ( parts.length > 0 ) {
				checkSet = makeArray(set);
			} else {
				prune = false;
			}

			while ( parts.length ) {
				var cur = parts.pop(), pop = cur;

				if ( !Expr.relative[ cur ] ) {
					cur = "";
				} else {
					pop = parts.pop();
				}

				if ( pop == null ) {
					pop = context;
				}

				Expr.relative[ cur ]( checkSet, pop, contextXML );
			}
		} else {
			checkSet = parts = [];
		}
	}

	if ( !checkSet ) {
		checkSet = set;
	}

	if ( !checkSet ) {
		throw "Syntax error, unrecognized expression: " + (cur || selector);
	}

	if ( toString.call(checkSet) === "[object Array]" ) {
		if ( !prune ) {
			results.push.apply( results, checkSet );
		} else if ( context && context.nodeType === 1 ) {
			for ( var i = 0; checkSet[i] != null; i++ ) {
				if ( checkSet[i] && (checkSet[i] === true || checkSet[i].nodeType === 1 && contains(context, checkSet[i])) ) {
					results.push( set[i] );
				}
			}
		} else {
			for ( var i = 0; checkSet[i] != null; i++ ) {
				if ( checkSet[i] && checkSet[i].nodeType === 1 ) {
					results.push( set[i] );
				}
			}
		}
	} else {
		makeArray( checkSet, results );
	}

	if ( extra ) {
		Sizzle( extra, origContext, results, seed );
		Sizzle.uniqueSort( results );
	}

	return results;
};

Sizzle.uniqueSort = function(results){
	if ( sortOrder ) {
		hasDuplicate = baseHasDuplicate;
		results.sort(sortOrder);

		if ( hasDuplicate ) {
			for ( var i = 1; i < results.length; i++ ) {
				if ( results[i] === results[i-1] ) {
					results.splice(i--, 1);
				}
			}
		}
	}

	return results;
};

Sizzle.matches = function(expr, set){
	return Sizzle(expr, null, null, set);
};

Sizzle.find = function(expr, context, isXML){
	var set, match;

	if ( !expr ) {
		return [];
	}

	for ( var i = 0, l = Expr.order.length; i < l; i++ ) {
		var type = Expr.order[i], match;

		if ( (match = Expr.leftMatch[ type ].exec( expr )) ) {
			var left = match[1];
			match.splice(1,1);

			if ( left.substr( left.length - 1 ) !== "\\" ) {
				match[1] = (match[1] || "").replace(/\\/g, "");
				set = Expr.find[ type ]( match, context, isXML );
				if ( set != null ) {
					expr = expr.replace( Expr.match[ type ], "" );
					break;
				}
			}
		}
	}

	if ( !set ) {
		set = context.getElementsByTagName("*");
	}

	return {set: set, expr: expr};
};

Sizzle.filter = function(expr, set, inplace, not){
	var old = expr, result = [], curLoop = set, match, anyFound,
		isXMLFilter = set && set[0] && isXML(set[0]);

	while ( expr && set.length ) {
		for ( var type in Expr.filter ) {
			if ( (match = Expr.match[ type ].exec( expr )) != null ) {
				var filter = Expr.filter[ type ], found, item;
				anyFound = false;

				if ( curLoop == result ) {
					result = [];
				}

				if ( Expr.preFilter[ type ] ) {
					match = Expr.preFilter[ type ]( match, curLoop, inplace, result, not, isXMLFilter );

					if ( !match ) {
						anyFound = found = true;
					} else if ( match === true ) {
						continue;
					}
				}

				if ( match ) {
					for ( var i = 0; (item = curLoop[i]) != null; i++ ) {
						if ( item ) {
							found = filter( item, match, i, curLoop );
							var pass = not ^ !!found;

							if ( inplace && found != null ) {
								if ( pass ) {
									anyFound = true;
								} else {
									curLoop[i] = false;
								}
							} else if ( pass ) {
								result.push( item );
								anyFound = true;
							}
						}
					}
				}

				if ( found !== undefined ) {
					if ( !inplace ) {
						curLoop = result;
					}

					expr = expr.replace( Expr.match[ type ], "" );

					if ( !anyFound ) {
						return [];
					}

					break;
				}
			}
		}

		if ( expr == old ) {
			if ( anyFound == null ) {
				throw "Syntax error, unrecognized expression: " + expr;
			} else {
				break;
			}
		}

		old = expr;
	}

	return curLoop;
};

var Expr = Sizzle.selectors = {
	order: [ "ID", "NAME", "TAG" ],
	match: {
		ID: /#((?:[\w\u00c0-\uFFFF-]|\\.)+)/,
		CLASS: /\.((?:[\w\u00c0-\uFFFF-]|\\.)+)/,
		NAME: /\[name=['"]*((?:[\w\u00c0-\uFFFF-]|\\.)+)['"]*\]/,
		ATTR: /\[\s*((?:[\w\u00c0-\uFFFF-]|\\.)+)\s*(?:(\S?=)\s*(['"]*)(.*?)\3|)\s*\]/,
		TAG: /^((?:[\w\u00c0-\uFFFF\*-]|\\.)+)/,
		CHILD: /:(only|nth|last|first)-child(?:\((even|odd|[\dn+-]*)\))?/,
		POS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^-]|$)/,
		PSEUDO: /:((?:[\w\u00c0-\uFFFF-]|\\.)+)(?:\((['"]*)((?:\([^\)]+\)|[^\2\(\)]*)+)\2\))?/
	},
	leftMatch: {},
	attrMap: {
		"class": "className",
		"for": "htmlFor"
	},
	attrHandle: {
		href: function(elem){
			return elem.getAttribute("href");
		}
	},
	relative: {
		"+": function(checkSet, part, isXML){
			var isPartStr = typeof part === "string",
				isTag = isPartStr && !/\W/.test(part),
				isPartStrNotTag = isPartStr && !isTag;

			if ( isTag && !isXML ) {
				part = part.toUpperCase();
			}

			for ( var i = 0, l = checkSet.length, elem; i < l; i++ ) {
				if ( (elem = checkSet[i]) ) {
					while ( (elem = elem.previousSibling) && elem.nodeType !== 1 ) {}

					checkSet[i] = isPartStrNotTag || elem && elem.nodeName === part ?
						elem || false :
						elem === part;
				}
			}

			if ( isPartStrNotTag ) {
				Sizzle.filter( part, checkSet, true );
			}
		},
		">": function(checkSet, part, isXML){
			var isPartStr = typeof part === "string";

			if ( isPartStr && !/\W/.test(part) ) {
				part = isXML ? part : part.toUpperCase();

				for ( var i = 0, l = checkSet.length; i < l; i++ ) {
					var elem = checkSet[i];
					if ( elem ) {
						var parent = elem.parentNode;
						checkSet[i] = parent.nodeName === part ? parent : false;
					}
				}
			} else {
				for ( var i = 0, l = checkSet.length; i < l; i++ ) {
					var elem = checkSet[i];
					if ( elem ) {
						checkSet[i] = isPartStr ?
							elem.parentNode :
							elem.parentNode === part;
					}
				}

				if ( isPartStr ) {
					Sizzle.filter( part, checkSet, true );
				}
			}
		},
		"": function(checkSet, part, isXML){
			var doneName = done++, checkFn = dirCheck;

			if ( !/\W/.test(part) ) {
				var nodeCheck = part = isXML ? part : part.toUpperCase();
				checkFn = dirNodeCheck;
			}

			checkFn("parentNode", part, doneName, checkSet, nodeCheck, isXML);
		},
		"~": function(checkSet, part, isXML){
			var doneName = done++, checkFn = dirCheck;

			if ( typeof part === "string" && !/\W/.test(part) ) {
				var nodeCheck = part = isXML ? part : part.toUpperCase();
				checkFn = dirNodeCheck;
			}

			checkFn("previousSibling", part, doneName, checkSet, nodeCheck, isXML);
		}
	},
	find: {
		ID: function(match, context, isXML){
			if ( typeof context.getElementById !== "undefined" && !isXML ) {
				var m = context.getElementById(match[1]);
				return m ? [m] : [];
			}
		},
		NAME: function(match, context, isXML){
			if ( typeof context.getElementsByName !== "undefined" ) {
				var ret = [], results = context.getElementsByName(match[1]);

				for ( var i = 0, l = results.length; i < l; i++ ) {
					if ( results[i].getAttribute("name") === match[1] ) {
						ret.push( results[i] );
					}
				}

				return ret.length === 0 ? null : ret;
			}
		},
		TAG: function(match, context){
			return context.getElementsByTagName(match[1]);
		}
	},
	preFilter: {
		CLASS: function(match, curLoop, inplace, result, not, isXML){
			match = " " + match[1].replace(/\\/g, "") + " ";

			if ( isXML ) {
				return match;
			}

			for ( var i = 0, elem; (elem = curLoop[i]) != null; i++ ) {
				if ( elem ) {
					if ( not ^ (elem.className && (" " + elem.className + " ").indexOf(match) >= 0) ) {
						if ( !inplace )
							result.push( elem );
					} else if ( inplace ) {
						curLoop[i] = false;
					}
				}
			}

			return false;
		},
		ID: function(match){
			return match[1].replace(/\\/g, "");
		},
		TAG: function(match, curLoop){
			for ( var i = 0; curLoop[i] === false; i++ ){}
			return curLoop[i] && isXML(curLoop[i]) ? match[1] : match[1].toUpperCase();
		},
		CHILD: function(match){
			if ( match[1] == "nth" ) {
				var test = /(-?)(\d*)n((?:\+|-)?\d*)/.exec(
					match[2] == "even" && "2n" || match[2] == "odd" && "2n+1" ||
					!/\D/.test( match[2] ) && "0n+" + match[2] || match[2]);

				match[2] = (test[1] + (test[2] || 1)) - 0;
				match[3] = test[3] - 0;
			}

			match[0] = done++;

			return match;
		},
		ATTR: function(match, curLoop, inplace, result, not, isXML){
			var name = match[1].replace(/\\/g, "");

			if ( !isXML && Expr.attrMap[name] ) {
				match[1] = Expr.attrMap[name];
			}

			if ( match[2] === "~=" ) {
				match[4] = " " + match[4] + " ";
			}

			return match;
		},
		PSEUDO: function(match, curLoop, inplace, result, not){
			if ( match[1] === "not" ) {
				if ( ( chunker.exec(match[3]) || "" ).length > 1 || /^\w/.test(match[3]) ) {
					match[3] = Sizzle(match[3], null, null, curLoop);
				} else {
					var ret = Sizzle.filter(match[3], curLoop, inplace, true ^ not);
					if ( !inplace ) {
						result.push.apply( result, ret );
					}
					return false;
				}
			} else if ( Expr.match.POS.test( match[0] ) || Expr.match.CHILD.test( match[0] ) ) {
				return true;
			}

			return match;
		},
		POS: function(match){
			match.unshift( true );
			return match;
		}
	},
	filters: {
		enabled: function(elem){
			return elem.disabled === false && elem.type !== "hidden";
		},
		disabled: function(elem){
			return elem.disabled === true;
		},
		checked: function(elem){
			return elem.checked === true;
		},
		selected: function(elem){
			elem.parentNode.selectedIndex;
			return elem.selected === true;
		},
		parent: function(elem){
			return !!elem.firstChild;
		},
		empty: function(elem){
			return !elem.firstChild;
		},
		has: function(elem, i, match){
			return !!Sizzle( match[3], elem ).length;
		},
		header: function(elem){
			return /h\d/i.test( elem.nodeName );
		},
		text: function(elem){
			return "text" === elem.type;
		},
		radio: function(elem){
			return "radio" === elem.type;
		},
		checkbox: function(elem){
			return "checkbox" === elem.type;
		},
		file: function(elem){
			return "file" === elem.type;
		},
		password: function(elem){
			return "password" === elem.type;
		},
		submit: function(elem){
			return "submit" === elem.type;
		},
		image: function(elem){
			return "image" === elem.type;
		},
		reset: function(elem){
			return "reset" === elem.type;
		},
		button: function(elem){
			return "button" === elem.type || elem.nodeName.toUpperCase() === "BUTTON";
		},
		input: function(elem){
			return /input|select|textarea|button/i.test(elem.nodeName);
		}
	},
	setFilters: {
		first: function(elem, i){
			return i === 0;
		},
		last: function(elem, i, match, array){
			return i === array.length - 1;
		},
		even: function(elem, i){
			return i % 2 === 0;
		},
		odd: function(elem, i){
			return i % 2 === 1;
		},
		lt: function(elem, i, match){
			return i < match[3] - 0;
		},
		gt: function(elem, i, match){
			return i > match[3] - 0;
		},
		nth: function(elem, i, match){
			return match[3] - 0 == i;
		},
		eq: function(elem, i, match){
			return match[3] - 0 == i;
		}
	},
	filter: {
		PSEUDO: function(elem, match, i, array){
			var name = match[1], filter = Expr.filters[ name ];

			if ( filter ) {
				return filter( elem, i, match, array );
			} else if ( name === "contains" ) {
				return (elem.textContent || elem.innerText || "").indexOf(match[3]) >= 0;
			} else if ( name === "not" ) {
				var not = match[3];

				for ( var i = 0, l = not.length; i < l; i++ ) {
					if ( not[i] === elem ) {
						return false;
					}
				}

				return true;
			}
		},
		CHILD: function(elem, match){
			var type = match[1], node = elem;
			switch (type) {
				case 'only':
				case 'first':
					while ( (node = node.previousSibling) )  {
						if ( node.nodeType === 1 ) return false;
					}
					if ( type == 'first') return true;
					node = elem;
				case 'last':
					while ( (node = node.nextSibling) )  {
						if ( node.nodeType === 1 ) return false;
					}
					return true;
				case 'nth':
					var first = match[2], last = match[3];

					if ( first == 1 && last == 0 ) {
						return true;
					}

					var doneName = match[0],
						parent = elem.parentNode;

					if ( parent && (parent.sizcache !== doneName || !elem.nodeIndex) ) {
						var count = 0;
						for ( node = parent.firstChild; node; node = node.nextSibling ) {
							if ( node.nodeType === 1 ) {
								node.nodeIndex = ++count;
							}
						}
						parent.sizcache = doneName;
					}

					var diff = elem.nodeIndex - last;
					if ( first == 0 ) {
						return diff == 0;
					} else {
						return ( diff % first == 0 && diff / first >= 0 );
					}
			}
		},
		ID: function(elem, match){
			return elem.nodeType === 1 && elem.getAttribute("id") === match;
		},
		TAG: function(elem, match){
			return (match === "*" && elem.nodeType === 1) || elem.nodeName === match;
		},
		CLASS: function(elem, match){
			return (" " + (elem.className || elem.getAttribute("class")) + " ")
				.indexOf( match ) > -1;
		},
		ATTR: function(elem, match){
			var name = match[1],
				result = Expr.attrHandle[ name ] ?
					Expr.attrHandle[ name ]( elem ) :
					elem[ name ] != null ?
						elem[ name ] :
						elem.getAttribute( name ),
				value = result + "",
				type = match[2],
				check = match[4];

			return result == null ?
				type === "!=" :
				type === "=" ?
				value === check :
				type === "*=" ?
				value.indexOf(check) >= 0 :
				type === "~=" ?
				(" " + value + " ").indexOf(check) >= 0 :
				!check ?
				value && result !== false :
				type === "!=" ?
				value != check :
				type === "^=" ?
				value.indexOf(check) === 0 :
				type === "$=" ?
				value.substr(value.length - check.length) === check :
				type === "|=" ?
				value === check || value.substr(0, check.length + 1) === check + "-" :
				false;
		},
		POS: function(elem, match, i, array){
			var name = match[2], filter = Expr.setFilters[ name ];

			if ( filter ) {
				return filter( elem, i, match, array );
			}
		}
	}
};

var origPOS = Expr.match.POS;

for ( var type in Expr.match ) {
	Expr.match[ type ] = new RegExp( Expr.match[ type ].source + /(?![^\[]*\])(?![^\(]*\))/.source );
	Expr.leftMatch[ type ] = new RegExp( /(^(?:.|\r|\n)*?)/.source + Expr.match[ type ].source );
}

var makeArray = function(array, results) {
	array = Array.prototype.slice.call( array, 0 );

	if ( results ) {
		results.push.apply( results, array );
		return results;
	}

	return array;
};

try {
	Array.prototype.slice.call( document.documentElement.childNodes, 0 );

} catch(e){
	makeArray = function(array, results) {
		var ret = results || [];

		if ( toString.call(array) === "[object Array]" ) {
			Array.prototype.push.apply( ret, array );
		} else {
			if ( typeof array.length === "number" ) {
				for ( var i = 0, l = array.length; i < l; i++ ) {
					ret.push( array[i] );
				}
			} else {
				for ( var i = 0; array[i]; i++ ) {
					ret.push( array[i] );
				}
			}
		}

		return ret;
	};
}

var sortOrder;

if ( document.documentElement.compareDocumentPosition ) {
	sortOrder = function( a, b ) {
		if ( !a.compareDocumentPosition || !b.compareDocumentPosition ) {
			if ( a == b ) {
				hasDuplicate = true;
			}
			return 0;
		}

		var ret = a.compareDocumentPosition(b) & 4 ? -1 : a === b ? 0 : 1;
		if ( ret === 0 ) {
			hasDuplicate = true;
		}
		return ret;
	};
} else if ( "sourceIndex" in document.documentElement ) {
	sortOrder = function( a, b ) {
		if ( !a.sourceIndex || !b.sourceIndex ) {
			if ( a == b ) {
				hasDuplicate = true;
			}
			return 0;
		}

		var ret = a.sourceIndex - b.sourceIndex;
		if ( ret === 0 ) {
			hasDuplicate = true;
		}
		return ret;
	};
} else if ( document.createRange ) {
	sortOrder = function( a, b ) {
		if ( !a.ownerDocument || !b.ownerDocument ) {
			if ( a == b ) {
				hasDuplicate = true;
			}
			return 0;
		}

		var aRange = a.ownerDocument.createRange(), bRange = b.ownerDocument.createRange();
		aRange.setStart(a, 0);
		aRange.setEnd(a, 0);
		bRange.setStart(b, 0);
		bRange.setEnd(b, 0);
		var ret = aRange.compareBoundaryPoints(Range.START_TO_END, bRange);
		if ( ret === 0 ) {
			hasDuplicate = true;
		}
		return ret;
	};
}

(function(){
	var form = document.createElement("div"),
		id = "script" + (new Date).getTime();
	form.innerHTML = "<a name='" + id + "'/>";

	var root = document.documentElement;
	root.insertBefore( form, root.firstChild );

	if ( !!document.getElementById( id ) ) {
		Expr.find.ID = function(match, context, isXML){
			if ( typeof context.getElementById !== "undefined" && !isXML ) {
				var m = context.getElementById(match[1]);
				return m ? m.id === match[1] || typeof m.getAttributeNode !== "undefined" && m.getAttributeNode("id").nodeValue === match[1] ? [m] : undefined : [];
			}
		};

		Expr.filter.ID = function(elem, match){
			var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
			return elem.nodeType === 1 && node && node.nodeValue === match;
		};
	}

	root.removeChild( form );
	root = form = null; // release memory in IE
})();

(function(){

	var div = document.createElement("div");
	div.appendChild( document.createComment("") );

	if ( div.getElementsByTagName("*").length > 0 ) {
		Expr.find.TAG = function(match, context){
			var results = context.getElementsByTagName(match[1]);

			if ( match[1] === "*" ) {
				var tmp = [];

				for ( var i = 0; results[i]; i++ ) {
					if ( results[i].nodeType === 1 ) {
						tmp.push( results[i] );
					}
				}

				results = tmp;
			}

			return results;
		};
	}

	div.innerHTML = "<a href='#'></a>";
	if ( div.firstChild && typeof div.firstChild.getAttribute !== "undefined" &&
			div.firstChild.getAttribute("href") !== "#" ) {
		Expr.attrHandle.href = function(elem){
			return elem.getAttribute("href", 2);
		};
	}

	div = null; // release memory in IE
})();

if ( document.querySelectorAll ) (function(){
	var oldSizzle = Sizzle, div = document.createElement("div");
	div.innerHTML = "<p class='TEST'></p>";

	if ( div.querySelectorAll && div.querySelectorAll(".TEST").length === 0 ) {
		return;
	}

	Sizzle = function(query, context, extra, seed){
		context = context || document;

		if ( !seed && context.nodeType === 9 && !isXML(context) ) {
			try {
				return makeArray( context.querySelectorAll(query), extra );
			} catch(e){}
		}

		return oldSizzle(query, context, extra, seed);
	};

	for ( var prop in oldSizzle ) {
		Sizzle[ prop ] = oldSizzle[ prop ];
	}

	div = null; // release memory in IE
})();

if ( document.getElementsByClassName && document.documentElement.getElementsByClassName ) (function(){
	var div = document.createElement("div");
	div.innerHTML = "<div class='test e'></div><div class='test'></div>";

	if ( div.getElementsByClassName("e").length === 0 )
		return;

	div.lastChild.className = "e";

	if ( div.getElementsByClassName("e").length === 1 )
		return;

	Expr.order.splice(1, 0, "CLASS");
	Expr.find.CLASS = function(match, context, isXML) {
		if ( typeof context.getElementsByClassName !== "undefined" && !isXML ) {
			return context.getElementsByClassName(match[1]);
		}
	};

	div = null; // release memory in IE
})();

function dirNodeCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
	var sibDir = dir == "previousSibling" && !isXML;
	for ( var i = 0, l = checkSet.length; i < l; i++ ) {
		var elem = checkSet[i];
		if ( elem ) {
			if ( sibDir && elem.nodeType === 1 ){
				elem.sizcache = doneName;
				elem.sizset = i;
			}
			elem = elem[dir];
			var match = false;

			while ( elem ) {
				if ( elem.sizcache === doneName ) {
					match = checkSet[elem.sizset];
					break;
				}

				if ( elem.nodeType === 1 && !isXML ){
					elem.sizcache = doneName;
					elem.sizset = i;
				}

				if ( elem.nodeName === cur ) {
					match = elem;
					break;
				}

				elem = elem[dir];
			}

			checkSet[i] = match;
		}
	}
}

function dirCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
	var sibDir = dir == "previousSibling" && !isXML;
	for ( var i = 0, l = checkSet.length; i < l; i++ ) {
		var elem = checkSet[i];
		if ( elem ) {
			if ( sibDir && elem.nodeType === 1 ) {
				elem.sizcache = doneName;
				elem.sizset = i;
			}
			elem = elem[dir];
			var match = false;

			while ( elem ) {
				if ( elem.sizcache === doneName ) {
					match = checkSet[elem.sizset];
					break;
				}

				if ( elem.nodeType === 1 ) {
					if ( !isXML ) {
						elem.sizcache = doneName;
						elem.sizset = i;
					}
					if ( typeof cur !== "string" ) {
						if ( elem === cur ) {
							match = true;
							break;
						}

					} else if ( Sizzle.filter( cur, [elem] ).length > 0 ) {
						match = elem;
						break;
					}
				}

				elem = elem[dir];
			}

			checkSet[i] = match;
		}
	}
}

var contains = document.compareDocumentPosition ?  function(a, b){
	return a.compareDocumentPosition(b) & 16;
} : function(a, b){
	return a !== b && (a.contains ? a.contains(b) : true);
};

var isXML = function(elem){
	return elem.nodeType === 9 && elem.documentElement.nodeName !== "HTML" ||
		!!elem.ownerDocument && elem.ownerDocument.documentElement.nodeName !== "HTML";
};

var posProcess = function(selector, context){
	var tmpSet = [], later = "", match,
		root = context.nodeType ? [context] : context;

	while ( (match = Expr.match.PSEUDO.exec( selector )) ) {
		later += match[0];
		selector = selector.replace( Expr.match.PSEUDO, "" );
	}

	selector = Expr.relative[selector] ? selector + "*" : selector;

	for ( var i = 0, l = root.length; i < l; i++ ) {
		Sizzle( selector, root[i], tmpSet );
	}

	return Sizzle.filter( later, tmpSet );
};


window.Sizzle = Sizzle;

})();

Prototype._original_property = window.Sizzle;

;(function(engine) {
  var extendElements = Prototype.Selector.extendElements;

  function select(selector, scope) {
    return extendElements(engine(selector, scope || document));
  }

  function match(element, selector) {
    return engine.matches(selector, [element]).length == 1;
  }

  Prototype.Selector.engine = engine;
  Prototype.Selector.select = select;
  Prototype.Selector.match = match;
})(Sizzle);

window.Sizzle = Prototype._original_property;
delete Prototype._original_property;

var Form = {
  reset: function(form) {
    form = $(form);
    form.reset();
    return form;
  },

  serializeElements: function(elements, options) {
    if (typeof options != 'object') options = { hash: !!options };
    else if (Object.isUndefined(options.hash)) options.hash = true;
    var key, value, submitted = false, submit = options.submit, accumulator, initial;

    if (options.hash) {
      initial = {};
      accumulator = function(result, key, value) {
        if (key in result) {
          if (!Object.isArray(result[key])) result[key] = [result[key]];
          result[key].push(value);
        } else result[key] = value;
        return result;
      };
    } else {
      initial = '';
      accumulator = function(result, key, value) {
        return result + (result ? '&' : '') + encodeURIComponent(key) + '=' + encodeURIComponent(value);
      }
    }

    return elements.inject(initial, function(result, element) {
      if (!element.disabled && element.name) {
        key = element.name; value = $(element).getValue();
        if (value != null && element.type != 'file' && (element.type != 'submit' || (!submitted &&
            submit !== false && (!submit || key == submit) && (submitted = true)))) {
          result = accumulator(result, key, value);
        }
      }
      return result;
    });
  }
};

Form.Methods = {
  serialize: function(form, options) {
    return Form.serializeElements(Form.getElements(form), options);
  },

  getElements: function(form) {
    var elements = $(form).getElementsByTagName('*'),
        element,
        arr = [ ],
        serializers = Form.Element.Serializers;
    for (var i = 0; element = elements[i]; i++) {
      arr.push(element);
    }
    return arr.inject([], function(elements, child) {
      if (serializers[child.tagName.toLowerCase()])
        elements.push(Element.extend(child));
      return elements;
    })
  },

  getInputs: function(form, typeName, name) {
    form = $(form);
    var inputs = form.getElementsByTagName('input');

    if (!typeName && !name) return $A(inputs).map(Element.extend);

    for (var i = 0, matchingInputs = [], length = inputs.length; i < length; i++) {
      var input = inputs[i];
      if ((typeName && input.type != typeName) || (name && input.name != name))
        continue;
      matchingInputs.push(Element.extend(input));
    }

    return matchingInputs;
  },

  disable: function(form) {
    form = $(form);
    Form.getElements(form).invoke('disable');
    return form;
  },

  enable: function(form) {
    form = $(form);
    Form.getElements(form).invoke('enable');
    return form;
  },

  findFirstElement: function(form) {
    var elements = $(form).getElements().findAll(function(element) {
      return 'hidden' != element.type && !element.disabled;
    });
    var firstByIndex = elements.findAll(function(element) {
      return element.hasAttribute('tabIndex') && element.tabIndex >= 0;
    }).sortBy(function(element) { return element.tabIndex }).first();

    return firstByIndex ? firstByIndex : elements.find(function(element) {
      return /^(?:input|select|textarea)$/i.test(element.tagName);
    });
  },

  focusFirstElement: function(form) {
    form = $(form);
    var element = form.findFirstElement();
    if (element) element.activate();
    return form;
  },

  request: function(form, options) {
    form = $(form), options = Object.clone(options || { });

    var params = options.parameters, action = form.readAttribute('action') || '';
    if (action.blank()) action = window.location.href;
    options.parameters = form.serialize(true);

    if (params) {
      if (Object.isString(params)) params = params.toQueryParams();
      Object.extend(options.parameters, params);
    }

    if (form.hasAttribute('method') && !options.method)
      options.method = form.method;

    return new Ajax.Request(action, options);
  }
};

/*--------------------------------------------------------------------------*/


Form.Element = {
  focus: function(element) {
    $(element).focus();
    return element;
  },

  select: function(element) {
    $(element).select();
    return element;
  }
};

Form.Element.Methods = {

  serialize: function(element) {
    element = $(element);
    if (!element.disabled && element.name) {
      var value = element.getValue();
      if (value != undefined) {
        var pair = { };
        pair[element.name] = value;
        return Object.toQueryString(pair);
      }
    }
    return '';
  },

  getValue: function(element) {
    element = $(element);
    var method = element.tagName.toLowerCase();
    return Form.Element.Serializers[method](element);
  },

  setValue: function(element, value) {
    element = $(element);
    var method = element.tagName.toLowerCase();
    Form.Element.Serializers[method](element, value);
    return element;
  },

  clear: function(element) {
    $(element).value = '';
    return element;
  },

  present: function(element) {
    return $(element).value != '';
  },

  activate: function(element) {
    element = $(element);
    try {
      element.focus();
      if (element.select && (element.tagName.toLowerCase() != 'input' ||
          !(/^(?:button|reset|submit)$/i.test(element.type))))
        element.select();
    } catch (e) { }
    return element;
  },

  disable: function(element) {
    element = $(element);
    element.disabled = true;
    return element;
  },

  enable: function(element) {
    element = $(element);
    element.disabled = false;
    return element;
  }
};

/*--------------------------------------------------------------------------*/

var Field = Form.Element;

var $F = Form.Element.Methods.getValue;

/*--------------------------------------------------------------------------*/

Form.Element.Serializers = (function() {
  function input(element, value) {
    switch (element.type.toLowerCase()) {
      case 'checkbox':
      case 'radio':
        return inputSelector(element, value);
      default:
        return valueSelector(element, value);
    }
  }

  function inputSelector(element, value) {
    if (Object.isUndefined(value))
      return element.checked ? element.value : null;
    else element.checked = !!value;
  }

  function valueSelector(element, value) {
    if (Object.isUndefined(value)) return element.value;
    else element.value = value;
  }

  function select(element, value) {
    if (Object.isUndefined(value))
      return (element.type === 'select-one' ? selectOne : selectMany)(element);

    var opt, currentValue, single = !Object.isArray(value);
    for (var i = 0, length = element.length; i < length; i++) {
      opt = element.options[i];
      currentValue = this.optionValue(opt);
      if (single) {
        if (currentValue == value) {
          opt.selected = true;
          return;
        }
      }
      else opt.selected = value.include(currentValue);
    }
  }

  function selectOne(element) {
    var index = element.selectedIndex;
    return index >= 0 ? optionValue(element.options[index]) : null;
  }

  function selectMany(element) {
    var values, length = element.length;
    if (!length) return null;

    for (var i = 0, values = []; i < length; i++) {
      var opt = element.options[i];
      if (opt.selected) values.push(optionValue(opt));
    }
    return values;
  }

  function optionValue(opt) {
    return Element.hasAttribute(opt, 'value') ? opt.value : opt.text;
  }

  return {
    input:         input,
    inputSelector: inputSelector,
    textarea:      valueSelector,
    select:        select,
    selectOne:     selectOne,
    selectMany:    selectMany,
    optionValue:   optionValue,
    button:        valueSelector
  };
})();

/*--------------------------------------------------------------------------*/


Abstract.TimedObserver = Class.create(PeriodicalExecuter, {
  initialize: function($super, element, frequency, callback) {
    $super(callback, frequency);
    this.element   = $(element);
    this.lastValue = this.getValue();
  },

  execute: function() {
    var value = this.getValue();
    if (Object.isString(this.lastValue) && Object.isString(value) ?
        this.lastValue != value : String(this.lastValue) != String(value)) {
      this.callback(this.element, value);
      this.lastValue = value;
    }
  }
});

Form.Element.Observer = Class.create(Abstract.TimedObserver, {
  getValue: function() {
    return Form.Element.getValue(this.element);
  }
});

Form.Observer = Class.create(Abstract.TimedObserver, {
  getValue: function() {
    return Form.serialize(this.element);
  }
});

/*--------------------------------------------------------------------------*/

Abstract.EventObserver = Class.create({
  initialize: function(element, callback) {
    this.element  = $(element);
    this.callback = callback;

    this.lastValue = this.getValue();
    if (this.element.tagName.toLowerCase() == 'form')
      this.registerFormCallbacks();
    else
      this.registerCallback(this.element);
  },

  onElementEvent: function() {
    var value = this.getValue();
    if (this.lastValue != value) {
      this.callback(this.element, value);
      this.lastValue = value;
    }
  },

  registerFormCallbacks: function() {
    Form.getElements(this.element).each(this.registerCallback, this);
  },

  registerCallback: function(element) {
    if (element.type) {
      switch (element.type.toLowerCase()) {
        case 'checkbox':
        case 'radio':
          Event.observe(element, 'click', this.onElementEvent.bind(this));
          break;
        default:
          Event.observe(element, 'change', this.onElementEvent.bind(this));
          break;
      }
    }
  }
});

Form.Element.EventObserver = Class.create(Abstract.EventObserver, {
  getValue: function() {
    return Form.Element.getValue(this.element);
  }
});

Form.EventObserver = Class.create(Abstract.EventObserver, {
  getValue: function() {
    return Form.serialize(this.element);
  }
});
(function() {

  var Event = {
    KEY_BACKSPACE: 8,
    KEY_TAB:       9,
    KEY_RETURN:   13,
    KEY_ESC:      27,
    KEY_LEFT:     37,
    KEY_UP:       38,
    KEY_RIGHT:    39,
    KEY_DOWN:     40,
    KEY_DELETE:   46,
    KEY_HOME:     36,
    KEY_END:      35,
    KEY_PAGEUP:   33,
    KEY_PAGEDOWN: 34,
    KEY_INSERT:   45,

    cache: {}
  };

  var docEl = document.documentElement;
  var MOUSEENTER_MOUSELEAVE_EVENTS_SUPPORTED = 'onmouseenter' in docEl
    && 'onmouseleave' in docEl;



  var isIELegacyEvent = function(event) { return false; };

  if (window.attachEvent) {
    if (window.addEventListener) {
      isIELegacyEvent = function(event) {
        return !(event instanceof window.Event);
      };
    } else {
      isIELegacyEvent = function(event) { return true; };
    }
  }

  var _isButton;

  function _isButtonForDOMEvents(event, code) {
    return event.which ? (event.which === code + 1) : (event.button === code);
  }

  var legacyButtonMap = { 0: 1, 1: 4, 2: 2 };
  function _isButtonForLegacyEvents(event, code) {
    return event.button === legacyButtonMap[code];
  }

  function _isButtonForWebKit(event, code) {
    switch (code) {
      case 0: return event.which == 1 && !event.metaKey;
      case 1: return event.which == 2 || (event.which == 1 && event.metaKey);
      case 2: return event.which == 3;
      default: return false;
    }
  }

  if (window.attachEvent) {
    if (!window.addEventListener) {
      _isButton = _isButtonForLegacyEvents;
    } else {
      _isButton = function(event, code) {
        return isIELegacyEvent(event) ? _isButtonForLegacyEvents(event, code) :
         _isButtonForDOMEvents(event, code);
      }
    }
  } else if (Prototype.Browser.WebKit) {
    _isButton = _isButtonForWebKit;
  } else {
    _isButton = _isButtonForDOMEvents;
  }

  function isLeftClick(event)   { return _isButton(event, 0) }

  function isMiddleClick(event) { return _isButton(event, 1) }

  function isRightClick(event)  { return _isButton(event, 2) }

  function element(event) {
    event = Event.extend(event);

    var node = event.target, type = event.type,
     currentTarget = event.currentTarget;

    if (currentTarget && currentTarget.tagName) {
      if (type === 'load' || type === 'error' ||
        (type === 'click' && currentTarget.tagName.toLowerCase() === 'input'
          && currentTarget.type === 'radio'))
            node = currentTarget;
    }

    if (node.nodeType == Node.TEXT_NODE)
      node = node.parentNode;

    return Element.extend(node);
  }

  function findElement(event, expression) {
    var element = Event.element(event);

    if (!expression) return element;
    while (element) {
      if (Object.isElement(element) && Prototype.Selector.match(element, expression)) {
        return Element.extend(element);
      }
      element = element.parentNode;
    }
  }

  function pointer(event) {
    return { x: pointerX(event), y: pointerY(event) };
  }

  function pointerX(event) {
    var docElement = document.documentElement,
     body = document.body || { scrollLeft: 0 };

    return event.pageX || (event.clientX +
      (docElement.scrollLeft || body.scrollLeft) -
      (docElement.clientLeft || 0));
  }

  function pointerY(event) {
    var docElement = document.documentElement,
     body = document.body || { scrollTop: 0 };

    return  event.pageY || (event.clientY +
       (docElement.scrollTop || body.scrollTop) -
       (docElement.clientTop || 0));
  }


  function stop(event) {
    Event.extend(event);
    event.preventDefault();
    event.stopPropagation();

    event.stopped = true;
  }


  Event.Methods = {
    isLeftClick:   isLeftClick,
    isMiddleClick: isMiddleClick,
    isRightClick:  isRightClick,

    element:     element,
    findElement: findElement,

    pointer:  pointer,
    pointerX: pointerX,
    pointerY: pointerY,

    stop: stop
  };

  var methods = Object.keys(Event.Methods).inject({ }, function(m, name) {
    m[name] = Event.Methods[name].methodize();
    return m;
  });

  if (window.attachEvent) {
    function _relatedTarget(event) {
      var element;
      switch (event.type) {
        case 'mouseover':
        case 'mouseenter':
          element = event.fromElement;
          break;
        case 'mouseout':
        case 'mouseleave':
          element = event.toElement;
          break;
        default:
          return null;
      }
      return Element.extend(element);
    }

    var additionalMethods = {
      stopPropagation: function() { this.cancelBubble = true },
      preventDefault:  function() { this.returnValue = false },
      inspect: function() { return '[object Event]' }
    };

    Event.extend = function(event, element) {
      if (!event) return false;

      if (!isIELegacyEvent(event)) return event;

      if (event._extendedByPrototype) return event;
      event._extendedByPrototype = Prototype.emptyFunction;

      var pointer = Event.pointer(event);

      Object.extend(event, {
        target: event.srcElement || element,
        relatedTarget: _relatedTarget(event),
        pageX:  pointer.x,
        pageY:  pointer.y
      });

      Object.extend(event, methods);
      Object.extend(event, additionalMethods);

      return event;
    };
  } else {
    Event.extend = Prototype.K;
  }

  if (window.addEventListener) {
    Event.prototype = window.Event.prototype || document.createEvent('HTMLEvents').__proto__;
    Object.extend(Event.prototype, methods);
  }

  function _createResponder(element, eventName, handler) {
    var registry = Element.retrieve(element, 'prototype_event_registry');

    if (Object.isUndefined(registry)) {
      CACHE.push(element);
      registry = Element.retrieve(element, 'prototype_event_registry', $H());
    }

    var respondersForEvent = registry.get(eventName);
    if (Object.isUndefined(respondersForEvent)) {
      respondersForEvent = [];
      registry.set(eventName, respondersForEvent);
    }

    if (respondersForEvent.pluck('handler').include(handler)) return false;

    var responder;
    if (eventName.include(":")) {
      responder = function(event) {
        if (Object.isUndefined(event.eventName))
          return false;

        if (event.eventName !== eventName)
          return false;

        Event.extend(event, element);
        handler.call(element, event);
      };
    } else {
      if (!MOUSEENTER_MOUSELEAVE_EVENTS_SUPPORTED &&
       (eventName === "mouseenter" || eventName === "mouseleave")) {
        if (eventName === "mouseenter" || eventName === "mouseleave") {
          responder = function(event) {
            Event.extend(event, element);

            var parent = event.relatedTarget;
            while (parent && parent !== element) {
              try { parent = parent.parentNode; }
              catch(e) { parent = element; }
            }

            if (parent === element) return;

            handler.call(element, event);
          };
        }
      } else {
        responder = function(event) {
          Event.extend(event, element);
          handler.call(element, event);
        };
      }
    }

    responder.handler = handler;
    respondersForEvent.push(responder);
    return responder;
  }

  function _destroyCache() {
    for (var i = 0, length = CACHE.length; i < length; i++) {
      Event.stopObserving(CACHE[i]);
      CACHE[i] = null;
    }
  }

  var CACHE = [];

  if (Prototype.Browser.IE)
    window.attachEvent('onunload', _destroyCache);

  if (Prototype.Browser.WebKit)
    window.addEventListener('unload', Prototype.emptyFunction, false);


  var _getDOMEventName = Prototype.K,
      translations = { mouseenter: "mouseover", mouseleave: "mouseout" };

  if (!MOUSEENTER_MOUSELEAVE_EVENTS_SUPPORTED) {
    _getDOMEventName = function(eventName) {
      return (translations[eventName] || eventName);
    };
  }

  function observe(element, eventName, handler) {
    element = $(element);

    var responder = _createResponder(element, eventName, handler);

    if (!responder) return element;

    if (eventName.include(':')) {
      if (element.addEventListener)
        element.addEventListener("dataavailable", responder, false);
      else {
        element.attachEvent("ondataavailable", responder);
        element.attachEvent("onlosecapture", responder);
      }
    } else {
      var actualEventName = _getDOMEventName(eventName);

      if (element.addEventListener)
        element.addEventListener(actualEventName, responder, false);
      else
        element.attachEvent("on" + actualEventName, responder);
    }

    return element;
  }

  function stopObserving(element, eventName, handler) {
    element = $(element);

    var registry = Element.retrieve(element, 'prototype_event_registry');
    if (!registry) return element;

    if (!eventName) {
      registry.each( function(pair) {
        var eventName = pair.key;
        stopObserving(element, eventName);
      });
      return element;
    }

    var responders = registry.get(eventName);
    if (!responders) return element;

    if (!handler) {
      responders.each(function(r) {
        stopObserving(element, eventName, r.handler);
      });
      return element;
    }

    var i = responders.length, responder;
    while (i--) {
      if (responders[i].handler === handler) {
        responder = responders[i];
        break;
      }
    }
    if (!responder) return element;

    if (eventName.include(':')) {
      if (element.removeEventListener)
        element.removeEventListener("dataavailable", responder, false);
      else {
        element.detachEvent("ondataavailable", responder);
        element.detachEvent("onlosecapture", responder);
      }
    } else {
      var actualEventName = _getDOMEventName(eventName);
      if (element.removeEventListener)
        element.removeEventListener(actualEventName, responder, false);
      else
        element.detachEvent('on' + actualEventName, responder);
    }

    registry.set(eventName, responders.without(responder));

    return element;
  }

  function fire(element, eventName, memo, bubble) {
    element = $(element);

    if (Object.isUndefined(bubble))
      bubble = true;

    if (element == document && document.createEvent && !element.dispatchEvent)
      element = document.documentElement;

    var event;
    if (document.createEvent) {
      event = document.createEvent('HTMLEvents');
      event.initEvent('dataavailable', bubble, true);
    } else {
      event = document.createEventObject();
      event.eventType = bubble ? 'ondataavailable' : 'onlosecapture';
    }

    event.eventName = eventName;
    event.memo = memo || { };

    if (document.createEvent)
      element.dispatchEvent(event);
    else
      element.fireEvent(event.eventType, event);

    return Event.extend(event);
  }

  Event.Handler = Class.create({
    initialize: function(element, eventName, selector, callback) {
      this.element   = $(element);
      this.eventName = eventName;
      this.selector  = selector;
      this.callback  = callback;
      this.handler   = this.handleEvent.bind(this);
    },

    start: function() {
      Event.observe(this.element, this.eventName, this.handler);
      return this;
    },

    stop: function() {
      Event.stopObserving(this.element, this.eventName, this.handler);
      return this;
    },

    handleEvent: function(event) {
      var element = Event.findElement(event, this.selector);
      if (element) this.callback.call(this.element, event, element);
    }
  });

  function on(element, eventName, selector, callback) {
    element = $(element);
    if (Object.isFunction(selector) && Object.isUndefined(callback)) {
      callback = selector, selector = null;
    }

    return new Event.Handler(element, eventName, selector, callback).start();
  }

  Object.extend(Event, Event.Methods);

  Object.extend(Event, {
    fire:          fire,
    observe:       observe,
    stopObserving: stopObserving,
    on:            on
  });

  Element.addMethods({
    fire:          fire,

    observe:       observe,

    stopObserving: stopObserving,

    on:            on
  });

  Object.extend(document, {
    fire:          fire.methodize(),

    observe:       observe.methodize(),

    stopObserving: stopObserving.methodize(),

    on:            on.methodize(),

    loaded:        false
  });

  if (window.Event) Object.extend(window.Event, Event);
  else window.Event = Event;
})();

(function() {
  /* Support for the DOMContentLoaded event is based on work by Dan Webb,
     Matthias Miller, Dean Edwards, John Resig, and Diego Perini. */

  var timer;

  function fireContentLoadedEvent() {
    if (document.loaded) return;
    if (timer) window.clearTimeout(timer);
    document.loaded = true;
    document.fire('dom:loaded');
  }

  function checkReadyState() {
    if (document.readyState === 'complete') {
      document.stopObserving('readystatechange', checkReadyState);
      fireContentLoadedEvent();
    }
  }

  function pollDoScroll() {
    try { document.documentElement.doScroll('left'); }
    catch(e) {
      timer = pollDoScroll.defer();
      return;
    }
    fireContentLoadedEvent();
  }

  if (document.addEventListener) {
    document.addEventListener('DOMContentLoaded', fireContentLoadedEvent, false);
  } else {
    document.observe('readystatechange', checkReadyState);
    if (window == top)
      timer = pollDoScroll.defer();
  }

  Event.observe(window, 'load', fireContentLoadedEvent);
})();


Element.addMethods();
/*------------------------------- DEPRECATED -------------------------------*/

Hash.toQueryString = Object.toQueryString;

var Toggle = { display: Element.toggle };

Element.Methods.childOf = Element.Methods.descendantOf;

var Insertion = {
  Before: function(element, content) {
    return Element.insert(element, {before:content});
  },

  Top: function(element, content) {
    return Element.insert(element, {top:content});
  },

  Bottom: function(element, content) {
    return Element.insert(element, {bottom:content});
  },

  After: function(element, content) {
    return Element.insert(element, {after:content});
  }
};

var $continue = new Error('"throw $continue" is deprecated, use "return" instead');

var Position = {
  includeScrollOffsets: false,

  prepare: function() {
    this.deltaX =  window.pageXOffset
                || document.documentElement.scrollLeft
                || document.body.scrollLeft
                || 0;
    this.deltaY =  window.pageYOffset
                || document.documentElement.scrollTop
                || document.body.scrollTop
                || 0;
  },

  within: function(element, x, y) {
    if (this.includeScrollOffsets)
      return this.withinIncludingScrolloffsets(element, x, y);
    this.xcomp = x;
    this.ycomp = y;
    this.offset = Element.cumulativeOffset(element);

    return (y >= this.offset[1] &&
            y <  this.offset[1] + element.offsetHeight &&
            x >= this.offset[0] &&
            x <  this.offset[0] + element.offsetWidth);
  },

  withinIncludingScrolloffsets: function(element, x, y) {
    var offsetcache = Element.cumulativeScrollOffset(element);

    this.xcomp = x + offsetcache[0] - this.deltaX;
    this.ycomp = y + offsetcache[1] - this.deltaY;
    this.offset = Element.cumulativeOffset(element);

    return (this.ycomp >= this.offset[1] &&
            this.ycomp <  this.offset[1] + element.offsetHeight &&
            this.xcomp >= this.offset[0] &&
            this.xcomp <  this.offset[0] + element.offsetWidth);
  },

  overlap: function(mode, element) {
    if (!mode) return 0;
    if (mode == 'vertical')
      return ((this.offset[1] + element.offsetHeight) - this.ycomp) /
        element.offsetHeight;
    if (mode == 'horizontal')
      return ((this.offset[0] + element.offsetWidth) - this.xcomp) /
        element.offsetWidth;
  },


  cumulativeOffset: Element.Methods.cumulativeOffset,

  positionedOffset: Element.Methods.positionedOffset,

  absolutize: function(element) {
    Position.prepare();
    return Element.absolutize(element);
  },
  
  absolutizeTransform: function(element) {
      Position.prepare();
      return Element.absolutizeTransform(element);
  },

  relativize: function(element) {
    Position.prepare();
    return Element.relativize(element);
  },

  realOffset: Element.Methods.cumulativeScrollOffset,

  offsetParent: Element.Methods.getOffsetParent,

  page: Element.Methods.viewportOffset,

  clone: function(source, target, options) {
    options = options || { };
    return Element.clonePosition(target, source, options);
  }
};

/*--------------------------------------------------------------------------*/

if (!document.getElementsByClassName) document.getElementsByClassName = function(instanceMethods){
  function iter(name) {
    return name.blank() ? null : "[contains(concat(' ', @class, ' '), ' " + name + " ')]";
  }

  instanceMethods.getElementsByClassName = Prototype.BrowserFeatures.XPath ?
  function(element, className) {
    className = className.toString().strip();
    var cond = /\s/.test(className) ? $w(className).map(iter).join('') : iter(className);
    return cond ? document._getElementsByXPath('.//*' + cond, element) : [];
  } : function(element, className) {
    className = className.toString().strip();
    var elements = [], classNames = (/\s/.test(className) ? $w(className) : null);
    if (!classNames && !className) return elements;

    var nodes = $(element).getElementsByTagName('*');
    className = ' ' + className + ' ';

    for (var i = 0, child, cn; child = nodes[i]; i++) {
      if (child.className && (cn = ' ' + child.className + ' ') && (cn.include(className) ||
          (classNames && classNames.all(function(name) {
            return !name.toString().blank() && cn.include(' ' + name + ' ');
          }))))
        elements.push(Element.extend(child));
    }
    return elements;
  };

  return function(className, parentElement) {
    return $(parentElement || document.body).getElementsByClassName(className);
  };
}(Element.Methods);

/*--------------------------------------------------------------------------*/

Element.ClassNames = Class.create();
Element.ClassNames.prototype = {
  initialize: function(element) {
    this.element = $(element);
  },

  _each: function(iterator) {
    this.element.className.split(/\s+/).select(function(name) {
      return name.length > 0;
    })._each(iterator);
  },

  set: function(className) {
    this.element.className = className;
  },

  add: function(classNameToAdd) {
    if (this.include(classNameToAdd)) return;
    this.set($A(this).concat(classNameToAdd).join(' '));
  },

  remove: function(classNameToRemove) {
    if (!this.include(classNameToRemove)) return;
    this.set($A(this).without(classNameToRemove).join(' '));
  },

  toString: function() {
    return $A(this).join(' ');
  }
};

Object.extend(Element.ClassNames.prototype, Enumerable);

/*--------------------------------------------------------------------------*/

(function() {
  window.Selector = Class.create({
    initialize: function(expression) {
      this.expression = expression.strip();
    },

    findElements: function(rootElement) {
      return Prototype.Selector.select(this.expression, rootElement);
    },

    match: function(element) {
      return Prototype.Selector.match(element, this.expression);
    },

    toString: function() {
      return this.expression;
    },

    inspect: function() {
      return "#<Selector: " + this.expression + ">";
    }
  });

  Object.extend(Selector, {
    matchElements: function(elements, expression) {
      var match = Prototype.Selector.match,
          results = [];

      for (var i = 0, length = elements.length; i < length; i++) {
        var element = elements[i];
        if (match(element, expression)) {
          results.push(Element.extend(element));
        }
      }
      return results;
    },

    findElement: function(elements, expression, index) {
      index = index || 0;
      var matchIndex = 0, element;
      for (var i = 0, length = elements.length; i < length; i++) {
        element = elements[i];
        if (Prototype.Selector.match(element, expression) && index === matchIndex++) {
          return Element.extend(element);
        }
      }
    },

    findChildElements: function(element, expressions) {
      var selector = expressions.toArray().join(', ');
      return Prototype.Selector.select(selector, element || document);
    }
  });
})();
// script.aculo.us builder.js v1.9.0, Thu Dec 23 16:54:48 -0500 2010

// Copyright (c) 2005-2010 Thomas Fuchs (http://script.aculo.us, http://mir.aculo.us)
//
// script.aculo.us is freely distributable under the terms of an MIT-style license.
// For details, see the script.aculo.us web site: http://script.aculo.us/

var Builder = {
  NODEMAP: {
    AREA: 'map',
    CAPTION: 'table',
    COL: 'table',
    COLGROUP: 'table',
    LEGEND: 'fieldset',
    OPTGROUP: 'select',
    OPTION: 'select',
    PARAM: 'object',
    TBODY: 'table',
    TD: 'table',
    TFOOT: 'table',
    TH: 'table',
    THEAD: 'table',
    TR: 'table'
  },
  // note: For Firefox < 1.5, OPTION and OPTGROUP tags are currently broken,
  //       due to a Firefox bug
  node: function(elementName) {
    elementName = elementName.toUpperCase();

    // try innerHTML approach
    var parentTag = this.NODEMAP[elementName] || 'div';
    var parentElement = document.createElement(parentTag);
    try { // prevent IE "feature": http://dev.rubyonrails.org/ticket/2707
      parentElement.innerHTML = "<" + elementName + "></" + elementName + ">";
    } catch(e) {}
    var element = parentElement.firstChild || null;

    // see if browser added wrapping tags
    if(element && (element.tagName.toUpperCase() != elementName))
      element = element.getElementsByTagName(elementName)[0];

    // fallback to createElement approach
    if(!element) element = document.createElement(elementName);

    // abort if nothing could be created
    if(!element) return;

    // attributes (or text)
    if(arguments[1])
      if(this._isStringOrNumber(arguments[1]) ||
        (arguments[1] instanceof Array) ||
        arguments[1].tagName) {
          this._children(element, arguments[1]);
        } else {
          var attrs = this._attributes(arguments[1]);
          if(attrs.length) {
            try { // prevent IE "feature": http://dev.rubyonrails.org/ticket/2707
              parentElement.innerHTML = "<" +elementName + " " +
                attrs + "></" + elementName + ">";
            } catch(e) {}
            element = parentElement.firstChild || null;
            // workaround firefox 1.0.X bug
            if(!element) {
              element = document.createElement(elementName);
              for(attr in arguments[1])
                element[attr == 'class' ? 'className' : attr] = arguments[1][attr];
            }
            if(element.tagName.toUpperCase() != elementName)
              element = parentElement.getElementsByTagName(elementName)[0];
          }
        }

    // text, or array of children
    if(arguments[2])
      this._children(element, arguments[2]);

     return $(element);
  },
  _text: function(text) {
     return document.createTextNode(text);
  },

  ATTR_MAP: {
    'className': 'class',
    'htmlFor': 'for'
  },

  _attributes: function(attributes) {
    var attrs = [];
    for(attribute in attributes)
      attrs.push((attribute in this.ATTR_MAP ? this.ATTR_MAP[attribute] : attribute) +
          '="' + attributes[attribute].toString().escapeHTML().gsub(/"/,'&quot;') + '"');
    return attrs.join(" ");
  },
  _children: function(element, children) {
    if(children.tagName) {
      element.appendChild(children);
      return;
    }
    if(typeof children=='object') { // array can hold nodes and text
      children.flatten().each( function(e) {
        if(typeof e=='object')
          element.appendChild(e);
        else
          if(Builder._isStringOrNumber(e))
            element.appendChild(Builder._text(e));
      });
    } else
      if(Builder._isStringOrNumber(children))
        element.appendChild(Builder._text(children));
  },
  _isStringOrNumber: function(param) {
    return(typeof param=='string' || typeof param=='number');
  },
  build: function(html) {
    var element = this.node('div');
    $(element).update(html.strip());
    return element.down();
  },
  dump: function(scope) {
    if(typeof scope != 'object' && typeof scope != 'function') scope = window; //global scope

    var tags = ("A ABBR ACRONYM ADDRESS APPLET AREA B BASE BASEFONT BDO BIG BLOCKQUOTE BODY " +
      "BR BUTTON CAPTION CENTER CITE CODE COL COLGROUP DD DEL DFN DIR DIV DL DT EM FIELDSET " +
      "FONT FORM FRAME FRAMESET H1 H2 H3 H4 H5 H6 HEAD HR HTML I IFRAME IMG INPUT INS ISINDEX "+
      "KBD LABEL LEGEND LI LINK MAP MENU META NOFRAMES NOSCRIPT OBJECT OL OPTGROUP OPTION P "+
      "PARAM PRE Q S SAMP SCRIPT SELECT SMALL SPAN STRIKE STRONG STYLE SUB SUP TABLE TBODY TD "+
      "TEXTAREA TFOOT TH THEAD TITLE TR TT U UL VAR").split(/\s+/);

    tags.each( function(tag){
      scope[tag] = function() {
        return Builder.node.apply(Builder, [tag].concat($A(arguments)));
      };
    });
  }
};
// script.aculo.us effects.js v1.9.0, Thu Dec 23 16:54:48 -0500 2010

// Copyright (c) 2005-2010 Thomas Fuchs (http://script.aculo.us, http://mir.aculo.us)
// Contributors:
//  Justin Palmer (http://encytemedia.com/)
//  Mark Pilgrim (http://diveintomark.org/)
//  Martin Bialasinki
//
// script.aculo.us is freely distributable under the terms of an MIT-style license.
// For details, see the script.aculo.us web site: http://script.aculo.us/

// converts rgb() and #xxx to #xxxxxx format,
// returns self (or first argument) if not convertable
String.prototype.parseColor = function() {
  var color = '#';
  if (this.slice(0,4) == 'rgb(') {
    var cols = this.slice(4,this.length-1).split(',');
    var i=0; do { color += parseInt(cols[i]).toColorPart() } while (++i<3);
  } else {
    if (this.slice(0,1) == '#') {
      if (this.length==4) for(var i=1;i<4;i++) color += (this.charAt(i) + this.charAt(i)).toLowerCase();
      if (this.length==7) color = this.toLowerCase();
    }
  }
  return (color.length==7 ? color : (arguments[0] || this));
};

/*--------------------------------------------------------------------------*/

Element.collectTextNodes = function(element) {
  return $A($(element).childNodes).collect( function(node) {
    return (node.nodeType==3 ? node.nodeValue :
      (node.hasChildNodes() ? Element.collectTextNodes(node) : ''));
  }).flatten().join('');
};

Element.collectTextNodesIgnoreClass = function(element, className) {
  return $A($(element).childNodes).collect( function(node) {
    return (node.nodeType==3 ? node.nodeValue :
      ((node.hasChildNodes() && !Element.hasClassName(node,className)) ?
        Element.collectTextNodesIgnoreClass(node, className) : ''));
  }).flatten().join('');
};

Element.setContentZoom = function(element, percent) {
  element = $(element);
  element.setStyle({fontSize: (percent/100) + 'em'});
  if (Prototype.Browser.WebKit) window.scrollBy(0,0);
  return element;
};

Element.getInlineOpacity = function(element){
  return $(element).style.opacity || '';
};

Element.forceRerendering = function(element) {
  try {
    element = $(element);
    var n = document.createTextNode(' ');
    element.appendChild(n);
    element.removeChild(n);
  } catch(e) { }
};

/*--------------------------------------------------------------------------*/

var Effect = {
  _elementDoesNotExistError: {
    name: 'ElementDoesNotExistError',
    message: 'The specified DOM element does not exist, but is required for this effect to operate'
  },
  Transitions: {
    linear: Prototype.K,
    sinoidal: function(pos) {
      return (-Math.cos(pos*Math.PI)/2) + .5;
    },
    reverse: function(pos) {
      return 1-pos;
    },
    flicker: function(pos) {
      var pos = ((-Math.cos(pos*Math.PI)/4) + .75) + Math.random()/4;
      return pos > 1 ? 1 : pos;
    },
    wobble: function(pos) {
      return (-Math.cos(pos*Math.PI*(9*pos))/2) + .5;
    },
    pulse: function(pos, pulses) {
      return (-Math.cos((pos*((pulses||5)-.5)*2)*Math.PI)/2) + .5;
    },
    spring: function(pos) {
      return 1 - (Math.cos(pos * 4.5 * Math.PI) * Math.exp(-pos * 6));
    },
    none: function(pos) {
      return 0;
    },
    full: function(pos) {
      return 1;
    }
  },
  DefaultOptions: {
    duration:   1.0,   // seconds
    fps:        100,   // 100= assume 66fps max.
    sync:       false, // true for combining
    from:       0.0,
    to:         1.0,
    delay:      0.0,
    queue:      'parallel'
  },
  tagifyText: function(element) {
    var tagifyStyle = 'position:relative';
    if (Prototype.Browser.IE) tagifyStyle += ';zoom:1';

    element = $(element);
    $A(element.childNodes).each( function(child) {
      if (child.nodeType==3) {
        child.nodeValue.toArray().each( function(character) {
          element.insertBefore(
            new Element('span', {style: tagifyStyle}).update(
              character == ' ' ? String.fromCharCode(160) : character),
              child);
        });
        Element.remove(child);
      }
    });
  },
  multiple: function(element, effect) {
    var elements;
    if (((typeof element == 'object') ||
        Object.isFunction(element)) &&
       (element.length))
      elements = element;
    else
      elements = $(element).childNodes;

    var options = Object.extend({
      speed: 0.1,
      delay: 0.0
    }, arguments[2] || { });
    var masterDelay = options.delay;

    $A(elements).each( function(element, index) {
      new effect(element, Object.extend(options, { delay: index * options.speed + masterDelay }));
    });
  },
  PAIRS: {
    'slide':  ['SlideDown','SlideUp'],
    'blind':  ['BlindDown','BlindUp'],
    'appear': ['Appear','Fade']
  },
  toggle: function(element, effect, options) {
    element = $(element);
    effect  = (effect || 'appear').toLowerCase();
    
    return Effect[ Effect.PAIRS[ effect ][ element.visible() ? 1 : 0 ] ](element, Object.extend({
      queue: { position:'end', scope:(element.id || 'global'), limit: 1 }
    }, options || {}));
  }
};

Effect.DefaultOptions.transition = Effect.Transitions.sinoidal;

/* ------------- core effects ------------- */

Effect.ScopedQueue = Class.create(Enumerable, {
  initialize: function() {
    this.effects  = [];
    this.interval = null;
  },
  _each: function(iterator) {
    this.effects._each(iterator);
  },
  add: function(effect) {
    var timestamp = new Date().getTime();

    var position = Object.isString(effect.options.queue) ?
      effect.options.queue : effect.options.queue.position;

    switch(position) {
      case 'front':
        // move unstarted effects after this effect
        this.effects.findAll(function(e){ return e.state=='idle' }).each( function(e) {
            e.startOn  += effect.finishOn;
            e.finishOn += effect.finishOn;
          });
        break;
      case 'with-last':
        timestamp = this.effects.pluck('startOn').max() || timestamp;
        break;
      case 'end':
        // start effect after last queued effect has finished
        timestamp = this.effects.pluck('finishOn').max() || timestamp;
        break;
    }

    effect.startOn  += timestamp;
    effect.finishOn += timestamp;

    if (!effect.options.queue.limit || (this.effects.length < effect.options.queue.limit))
      this.effects.push(effect);

    if (!this.interval)
      this.interval = setInterval(this.loop.bind(this), 15);
  },
  remove: function(effect) {
    this.effects = this.effects.reject(function(e) { return e==effect });
    if (this.effects.length == 0) {
      clearInterval(this.interval);
      this.interval = null;
    }
  },
  loop: function() {
    var timePos = new Date().getTime();
    for(var i=0, len=this.effects.length;i<len;i++)
      this.effects[i] && this.effects[i].loop(timePos);
  }
});

Effect.Queues = {
  instances: $H(),
  get: function(queueName) {
    if (!Object.isString(queueName)) return queueName;

    return this.instances.get(queueName) ||
      this.instances.set(queueName, new Effect.ScopedQueue());
  }
};
Effect.Queue = Effect.Queues.get('global');

Effect.Base = Class.create({
  position: null,
  start: function(options) {
    if (options && options.transition === false) options.transition = Effect.Transitions.linear;
    this.options      = Object.extend(Object.extend({ },Effect.DefaultOptions), options || { });
    this.currentFrame = 0;
    this.state        = 'idle';
    this.startOn      = this.options.delay*1000;
    this.finishOn     = this.startOn+(this.options.duration*1000);
    this.fromToDelta  = this.options.to-this.options.from;
    this.totalTime    = this.finishOn-this.startOn;
    this.totalFrames  = this.options.fps*this.options.duration;

    this.render = (function() {
      function dispatch(effect, eventName) {
        if (effect.options[eventName + 'Internal'])
          effect.options[eventName + 'Internal'](effect);
        if (effect.options[eventName])
          effect.options[eventName](effect);
      }

      return function(pos) {
        if (this.state === "idle") {
          this.state = "running";
          dispatch(this, 'beforeSetup');
          if (this.setup) this.setup();
          dispatch(this, 'afterSetup');
        }
        if (this.state === "running") {
          pos = (this.options.transition(pos) * this.fromToDelta) + this.options.from;
          this.position = pos;
          dispatch(this, 'beforeUpdate');
          if (this.update) this.update(pos);
          dispatch(this, 'afterUpdate');
        }
      };
    })();

    this.event('beforeStart');
    if (!this.options.sync)
      Effect.Queues.get(Object.isString(this.options.queue) ?
        'global' : this.options.queue.scope).add(this);
  },
  loop: function(timePos) {
    if (timePos >= this.startOn) {
      if (timePos >= this.finishOn) {
        this.render(1.0);
        this.cancel();
        this.event('beforeFinish');
        if (this.finish) this.finish();
        this.event('afterFinish');
        return;
      }
      var pos   = (timePos - this.startOn) / this.totalTime,
          frame = (pos * this.totalFrames).round();
      if (frame > this.currentFrame) {
        this.render(pos);
        this.currentFrame = frame;
      }
    }
  },
  cancel: function() {
    if (!this.options.sync)
      Effect.Queues.get(Object.isString(this.options.queue) ?
        'global' : this.options.queue.scope).remove(this);
    this.state = 'finished';
  },
  event: function(eventName) {
    if (this.options[eventName + 'Internal']) this.options[eventName + 'Internal'](this);
    if (this.options[eventName]) this.options[eventName](this);
  },
  inspect: function() {
    var data = $H();
    for(property in this)
      if (!Object.isFunction(this[property])) data.set(property, this[property]);
    return '#<Effect:' + data.inspect() + ',options:' + $H(this.options).inspect() + '>';
  }
});

Effect.Parallel = Class.create(Effect.Base, {
  initialize: function(effects) {
    this.effects = effects || [];
    this.start(arguments[1]);
  },
  update: function(position) {
    this.effects.invoke('render', position);
  },
  finish: function(position) {
    this.effects.each( function(effect) {
      effect.render(1.0);
      effect.cancel();
      effect.event('beforeFinish');
      if (effect.finish) effect.finish(position);
      effect.event('afterFinish');
    });
  }
});

Effect.Tween = Class.create(Effect.Base, {
  initialize: function(object, from, to) {
    object = Object.isString(object) ? $(object) : object;
    var args = $A(arguments), method = args.last(),
      options = args.length == 5 ? args[3] : null;
    this.method = Object.isFunction(method) ? method.bind(object) :
      Object.isFunction(object[method]) ? object[method].bind(object) :
      function(value) { object[method] = value };
    this.start(Object.extend({ from: from, to: to }, options || { }));
  },
  update: function(position) {
    this.method(position);
  }
});

Effect.Event = Class.create(Effect.Base, {
  initialize: function() {
    this.start(Object.extend({ duration: 0 }, arguments[0] || { }));
  },
  update: Prototype.emptyFunction
});

Effect.Opacity = Class.create(Effect.Base, {
  initialize: function(element) {
    this.element = $(element);
    if (!this.element) throw(Effect._elementDoesNotExistError);
    // make this work on IE on elements without 'layout'
    if (Prototype.Browser.IE && (!this.element.currentStyle.hasLayout))
      this.element.setStyle({zoom: 1});
    var options = Object.extend({
      from: this.element.getOpacity() || 0.0,
      to:   1.0
    }, arguments[1] || { });
    this.start(options);
  },
  update: function(position) {
    this.element.setOpacity(position);
  }
});

Effect.Move = Class.create(Effect.Base, {
  initialize: function(element) {
    this.element = $(element);
    if (!this.element) throw(Effect._elementDoesNotExistError);
    var options = Object.extend({
      x:    0,
      y:    0,
      mode: 'relative'
    }, arguments[1] || { });
    this.start(options);
  },
  setup: function() {
    this.element.makePositioned();
    this.originalLeft = parseFloat(this.element.getStyle('left') || '0');
    this.originalTop  = parseFloat(this.element.getStyle('top')  || '0');
    if (this.options.mode == 'absolute') {
      this.options.x = this.options.x - this.originalLeft;
      this.options.y = this.options.y - this.originalTop;
    }
  },
  update: function(position) {
    this.element.setStyle({
      left: (this.options.x  * position + this.originalLeft).round() + 'px',
      top:  (this.options.y  * position + this.originalTop).round()  + 'px'
    });
  }
});

// for backwards compatibility
Effect.MoveBy = function(element, toTop, toLeft) {
  return new Effect.Move(element,
    Object.extend({ x: toLeft, y: toTop }, arguments[3] || { }));
};

Effect.Scale = Class.create(Effect.Base, {
  initialize: function(element, percent) {
    this.element = $(element);
    if (!this.element) throw(Effect._elementDoesNotExistError);
    var options = Object.extend({
      scaleX: true,
      scaleY: true,
      scaleContent: true,
      scaleFromCenter: false,
      scaleMode: 'box',        // 'box' or 'contents' or { } with provided values
      scaleFrom: 100.0,
      scaleTo:   percent
    }, arguments[2] || { });
    this.start(options);
  },
  setup: function() {
    this.restoreAfterFinish = this.options.restoreAfterFinish || false;
    this.elementPositioning = this.element.getStyle('position');

    this.originalStyle = { };
    ['top','left','width','height','fontSize'].each( function(k) {
      this.originalStyle[k] = this.element.style[k];
    }.bind(this));

    this.originalTop  = this.element.offsetTop;
    this.originalLeft = this.element.offsetLeft;

    var fontSize = this.element.getStyle('font-size') || '100%';
    ['em','px','%','pt'].each( function(fontSizeType) {
      if (fontSize.indexOf(fontSizeType)>0) {
        this.fontSize     = parseFloat(fontSize);
        this.fontSizeType = fontSizeType;
      }
    }.bind(this));

    this.factor = (this.options.scaleTo - this.options.scaleFrom)/100;

    this.dims = null;
    if (this.options.scaleMode=='box')
      this.dims = [this.element.offsetHeight, this.element.offsetWidth];
    if (/^content/.test(this.options.scaleMode))
      this.dims = [this.element.scrollHeight, this.element.scrollWidth];
    if (!this.dims)
      this.dims = [this.options.scaleMode.originalHeight,
                   this.options.scaleMode.originalWidth];
  },
  update: function(position) {
    var currentScale = (this.options.scaleFrom/100.0) + (this.factor * position);
    if (this.options.scaleContent && this.fontSize)
      this.element.setStyle({fontSize: this.fontSize * currentScale + this.fontSizeType });
    this.setDimensions(this.dims[0] * currentScale, this.dims[1] * currentScale);
  },
  finish: function(position) {
    if (this.restoreAfterFinish) this.element.setStyle(this.originalStyle);
  },
  setDimensions: function(height, width) {
    var d = { };
    if (this.options.scaleX) d.width = width.round() + 'px';
    if (this.options.scaleY) d.height = height.round() + 'px';
    if (this.options.scaleFromCenter) {
      var topd  = (height - this.dims[0])/2;
      var leftd = (width  - this.dims[1])/2;
      if (this.elementPositioning == 'absolute') {
        if (this.options.scaleY) d.top = this.originalTop-topd + 'px';
        if (this.options.scaleX) d.left = this.originalLeft-leftd + 'px';
      } else {
        if (this.options.scaleY) d.top = -topd + 'px';
        if (this.options.scaleX) d.left = -leftd + 'px';
      }
    }
    this.element.setStyle(d);
  }
});

Effect.Highlight = Class.create(Effect.Base, {
  initialize: function(element) {
    this.element = $(element);
    if (!this.element) throw(Effect._elementDoesNotExistError);
    var options = Object.extend({ startcolor: '#ffff99' }, arguments[1] || { });
    this.start(options);
  },
  setup: function() {
    // Prevent executing on elements not in the layout flow
    if (this.element.getStyle('display')=='none') { this.cancel(); return; }
    // Disable background image during the effect
    this.oldStyle = { };
    if (!this.options.keepBackgroundImage) {
      this.oldStyle.backgroundImage = this.element.getStyle('background-image');
      this.element.setStyle({backgroundImage: 'none'});
    }
    if (!this.options.endcolor)
      this.options.endcolor = this.element.getStyle('background-color').parseColor('#ffffff');
    if (!this.options.restorecolor)
      this.options.restorecolor = this.element.getStyle('background-color');
    // init color calculations
    this._base  = $R(0,2).map(function(i){ return parseInt(this.options.startcolor.slice(i*2+1,i*2+3),16) }.bind(this));
    this._delta = $R(0,2).map(function(i){ return parseInt(this.options.endcolor.slice(i*2+1,i*2+3),16)-this._base[i] }.bind(this));
  },
  update: function(position) {
    this.element.setStyle({backgroundColor: $R(0,2).inject('#',function(m,v,i){
      return m+((this._base[i]+(this._delta[i]*position)).round().toColorPart()); }.bind(this)) });
  },
  finish: function() {
    this.element.setStyle(Object.extend(this.oldStyle, {
      backgroundColor: this.options.restorecolor
    }));
  }
});

Effect.ScrollTo = function(element) {
  var options = arguments[1] || { },
  scrollOffsets = document.viewport.getScrollOffsets(),
  elementOffsets = $(element).cumulativeOffset();

  if (options.offset) elementOffsets[1] += options.offset;

  return new Effect.Tween(null,
    scrollOffsets.top,
    elementOffsets[1],
    options,
    function(p){ scrollTo(scrollOffsets.left, p.round()); }
  );
};

/* ------------- combination effects ------------- */

Effect.Fade = function(element) {
  element = $(element);
  var oldOpacity = element.getInlineOpacity();
  var options = Object.extend({
    from: element.getOpacity() || 1.0,
    to:   0.0,
    afterFinishInternal: function(effect) {
      if (effect.options.to!=0) return;
      effect.element.hide().setStyle({opacity: oldOpacity});
    }
  }, arguments[1] || { });
  return new Effect.Opacity(element,options);
};

Effect.Appear = function(element) {
  element = $(element);
  var options = Object.extend({
  from: (element.getStyle('display') == 'none' ? 0.0 : element.getOpacity() || 0.0),
  to:   1.0,
  // force Safari to render floated elements properly
  afterFinishInternal: function(effect) {
    effect.element.forceRerendering();
  },
  beforeSetup: function(effect) {
    effect.element.setOpacity(effect.options.from).show();
  }}, arguments[1] || { });
  return new Effect.Opacity(element,options);
};

Effect.Puff = function(element) {
  element = $(element);
  var oldStyle = {
    opacity: element.getInlineOpacity(),
    position: element.getStyle('position'),
    top:  element.style.top,
    left: element.style.left,
    width: element.style.width,
    height: element.style.height
  };
  return new Effect.Parallel(
   [ new Effect.Scale(element, 200,
      { sync: true, scaleFromCenter: true, scaleContent: true, restoreAfterFinish: true }),
     new Effect.Opacity(element, { sync: true, to: 0.0 } ) ],
     Object.extend({ duration: 1.0,
      beforeSetupInternal: function(effect) {
        Position.absolutize(effect.effects[0].element);
      },
      afterFinishInternal: function(effect) {
         effect.effects[0].element.hide().setStyle(oldStyle); }
     }, arguments[1] || { })
   );
};

Effect.BlindUp = function(element) {
  element = $(element);
  element.makeClipping();
  return new Effect.Scale(element, 0,
    Object.extend({ scaleContent: false,
      scaleX: false,
      restoreAfterFinish: true,
      afterFinishInternal: function(effect) {
        effect.element.hide().undoClipping();
      }
    }, arguments[1] || { })
  );
};

Effect.BlindDown = function(element) {
  element = $(element);
  var elementDimensions = element.getDimensions();
  return new Effect.Scale(element, 100, Object.extend({
    scaleContent: false,
    scaleX: false,
    scaleFrom: 0,
    scaleMode: {originalHeight: elementDimensions.height, originalWidth: elementDimensions.width},
    restoreAfterFinish: true,
    afterSetup: function(effect) {
      effect.element.makeClipping().setStyle({height: '0px'}).show();
    },
    afterFinishInternal: function(effect) {
      effect.element.undoClipping();
    }
  }, arguments[1] || { }));
};

Effect.SwitchOff = function(element) {
  element = $(element);
  var oldOpacity = element.getInlineOpacity();
  return new Effect.Appear(element, Object.extend({
    duration: 0.4,
    from: 0,
    transition: Effect.Transitions.flicker,
    afterFinishInternal: function(effect) {
      new Effect.Scale(effect.element, 1, {
        duration: 0.3, scaleFromCenter: true,
        scaleX: false, scaleContent: false, restoreAfterFinish: true,
        beforeSetup: function(effect) {
          effect.element.makePositioned().makeClipping();
        },
        afterFinishInternal: function(effect) {
          effect.element.hide().undoClipping().undoPositioned().setStyle({opacity: oldOpacity});
        }
      });
    }
  }, arguments[1] || { }));
};

Effect.DropOut = function(element) {
  element = $(element);
  var oldStyle = {
    top: element.getStyle('top'),
    left: element.getStyle('left'),
    opacity: element.getInlineOpacity() };
  return new Effect.Parallel(
    [ new Effect.Move(element, {x: 0, y: 100, sync: true }),
      new Effect.Opacity(element, { sync: true, to: 0.0 }) ],
    Object.extend(
      { duration: 0.5,
        beforeSetup: function(effect) {
          effect.effects[0].element.makePositioned();
        },
        afterFinishInternal: function(effect) {
          effect.effects[0].element.hide().undoPositioned().setStyle(oldStyle);
        }
      }, arguments[1] || { }));
};

Effect.Shake = function(element) {
  element = $(element);
  var options = Object.extend({
    distance: 20,
    duration: 0.5
  }, arguments[1] || {});
  var distance = parseFloat(options.distance);
  var split = parseFloat(options.duration) / 10.0;
  var oldStyle = {
    top: element.getStyle('top'),
    left: element.getStyle('left') };
    return new Effect.Move(element,
      { x:  distance, y: 0, duration: split, afterFinishInternal: function(effect) {
    new Effect.Move(effect.element,
      { x: -distance*2, y: 0, duration: split*2,  afterFinishInternal: function(effect) {
    new Effect.Move(effect.element,
      { x:  distance*2, y: 0, duration: split*2,  afterFinishInternal: function(effect) {
    new Effect.Move(effect.element,
      { x: -distance*2, y: 0, duration: split*2,  afterFinishInternal: function(effect) {
    new Effect.Move(effect.element,
      { x:  distance*2, y: 0, duration: split*2,  afterFinishInternal: function(effect) {
    new Effect.Move(effect.element,
      { x: -distance, y: 0, duration: split, afterFinishInternal: function(effect) {
        effect.element.undoPositioned().setStyle(oldStyle);
  }}); }}); }}); }}); }}); }});
};

Effect.SlideDown = function(element) {
  element = $(element).cleanWhitespace();
  // SlideDown need to have the content of the element wrapped in a container element with fixed height!
  var oldInnerBottom = element.down().getStyle('bottom');
  var elementDimensions = element.getDimensions();
  return new Effect.Scale(element, 100, Object.extend({
    scaleContent: false,
    scaleX: false,
    scaleFrom: window.opera ? 0 : 1,
    scaleMode: {originalHeight: elementDimensions.height, originalWidth: elementDimensions.width},
    restoreAfterFinish: true,
    afterSetup: function(effect) {
      effect.element.makePositioned();
      effect.element.down().makePositioned();
      if (window.opera) effect.element.setStyle({top: ''});
      effect.element.makeClipping().setStyle({height: '0px'}).show();
    },
    afterUpdateInternal: function(effect) {
      effect.element.down().setStyle({bottom:
        (effect.dims[0] - effect.element.clientHeight) + 'px' });
    },
    afterFinishInternal: function(effect) {
      effect.element.undoClipping().undoPositioned();
      effect.element.down().undoPositioned().setStyle({bottom: oldInnerBottom}); }
    }, arguments[1] || { })
  );
};

Effect.SlideUp = function(element) {
  element = $(element).cleanWhitespace();
  var oldInnerBottom = element.down().getStyle('bottom');
  var elementDimensions = element.getDimensions();
  return new Effect.Scale(element, window.opera ? 0 : 1,
   Object.extend({ scaleContent: false,
    scaleX: false,
    scaleMode: 'box',
    scaleFrom: 100,
    scaleMode: {originalHeight: elementDimensions.height, originalWidth: elementDimensions.width},
    restoreAfterFinish: true,
    afterSetup: function(effect) {
      effect.element.makePositioned();
      effect.element.down().makePositioned();
      if (window.opera) effect.element.setStyle({top: ''});
      effect.element.makeClipping().show();
    },
    afterUpdateInternal: function(effect) {
      effect.element.down().setStyle({bottom:
        (effect.dims[0] - effect.element.clientHeight) + 'px' });
    },
    afterFinishInternal: function(effect) {
      effect.element.hide().undoClipping().undoPositioned();
      effect.element.down().undoPositioned().setStyle({bottom: oldInnerBottom});
    }
   }, arguments[1] || { })
  );
};

// Bug in opera makes the TD containing this element expand for a instance after finish
Effect.Squish = function(element) {
  return new Effect.Scale(element, window.opera ? 1 : 0, {
    restoreAfterFinish: true,
    beforeSetup: function(effect) {
      effect.element.makeClipping();
    },
    afterFinishInternal: function(effect) {
      effect.element.hide().undoClipping();
    }
  });
};

Effect.Grow = function(element) {
  element = $(element);
  var options = Object.extend({
    direction: 'center',
    moveTransition: Effect.Transitions.sinoidal,
    scaleTransition: Effect.Transitions.sinoidal,
    opacityTransition: Effect.Transitions.full
  }, arguments[1] || { });
  var oldStyle = {
    top: element.style.top,
    left: element.style.left,
    height: element.style.height,
    width: element.style.width,
    opacity: element.getInlineOpacity() };

  var dims = element.getDimensions();
  var initialMoveX, initialMoveY;
  var moveX, moveY;

  switch (options.direction) {
    case 'top-left':
      initialMoveX = initialMoveY = moveX = moveY = 0;
      break;
    case 'top-right':
      initialMoveX = dims.width;
      initialMoveY = moveY = 0;
      moveX = -dims.width;
      break;
    case 'bottom-left':
      initialMoveX = moveX = 0;
      initialMoveY = dims.height;
      moveY = -dims.height;
      break;
    case 'bottom-right':
      initialMoveX = dims.width;
      initialMoveY = dims.height;
      moveX = -dims.width;
      moveY = -dims.height;
      break;
    case 'center':
      initialMoveX = dims.width / 2;
      initialMoveY = dims.height / 2;
      moveX = -dims.width / 2;
      moveY = -dims.height / 2;
      break;
  }

  return new Effect.Move(element, {
    x: initialMoveX,
    y: initialMoveY,
    duration: 0.01,
    beforeSetup: function(effect) {
      effect.element.hide().makeClipping().makePositioned();
    },
    afterFinishInternal: function(effect) {
      new Effect.Parallel(
        [ new Effect.Opacity(effect.element, { sync: true, to: 1.0, from: 0.0, transition: options.opacityTransition }),
          new Effect.Move(effect.element, { x: moveX, y: moveY, sync: true, transition: options.moveTransition }),
          new Effect.Scale(effect.element, 100, {
            scaleMode: { originalHeight: dims.height, originalWidth: dims.width },
            sync: true, scaleFrom: window.opera ? 1 : 0, transition: options.scaleTransition, restoreAfterFinish: true})
        ], Object.extend({
             beforeSetup: function(effect) {
               effect.effects[0].element.setStyle({height: '0px'}).show();
             },
             afterFinishInternal: function(effect) {
               effect.effects[0].element.undoClipping().undoPositioned().setStyle(oldStyle);
             }
           }, options)
      );
    }
  });
};

Effect.Shrink = function(element) {
  element = $(element);
  var options = Object.extend({
    direction: 'center',
    moveTransition: Effect.Transitions.sinoidal,
    scaleTransition: Effect.Transitions.sinoidal,
    opacityTransition: Effect.Transitions.none
  }, arguments[1] || { });
  var oldStyle = {
    top: element.style.top,
    left: element.style.left,
    height: element.style.height,
    width: element.style.width,
    opacity: element.getInlineOpacity() };

  var dims = element.getDimensions();
  var moveX, moveY;

  switch (options.direction) {
    case 'top-left':
      moveX = moveY = 0;
      break;
    case 'top-right':
      moveX = dims.width;
      moveY = 0;
      break;
    case 'bottom-left':
      moveX = 0;
      moveY = dims.height;
      break;
    case 'bottom-right':
      moveX = dims.width;
      moveY = dims.height;
      break;
    case 'center':
      moveX = dims.width / 2;
      moveY = dims.height / 2;
      break;
  }

  return new Effect.Parallel(
    [ new Effect.Opacity(element, { sync: true, to: 0.0, from: 1.0, transition: options.opacityTransition }),
      new Effect.Scale(element, window.opera ? 1 : 0, { sync: true, transition: options.scaleTransition, restoreAfterFinish: true}),
      new Effect.Move(element, { x: moveX, y: moveY, sync: true, transition: options.moveTransition })
    ], Object.extend({
         beforeStartInternal: function(effect) {
           effect.effects[0].element.makePositioned().makeClipping();
         },
         afterFinishInternal: function(effect) {
           effect.effects[0].element.hide().undoClipping().undoPositioned().setStyle(oldStyle); }
       }, options)
  );
};

Effect.Pulsate = function(element) {
  element = $(element);
  var options    = arguments[1] || { },
    oldOpacity = element.getInlineOpacity(),
    transition = options.transition || Effect.Transitions.linear,
    reverser   = function(pos){
      return 1 - transition((-Math.cos((pos*(options.pulses||5)*2)*Math.PI)/2) + .5);
    };

  return new Effect.Opacity(element,
    Object.extend(Object.extend({  duration: 2.0, from: 0,
      afterFinishInternal: function(effect) { effect.element.setStyle({opacity: oldOpacity}); }
    }, options), {transition: reverser}));
};

Effect.Fold = function(element) {
  element = $(element);
  var oldStyle = {
    top: element.style.top,
    left: element.style.left,
    width: element.style.width,
    height: element.style.height };
  element.makeClipping();
  return new Effect.Scale(element, 5, Object.extend({
    scaleContent: false,
    scaleX: false,
    afterFinishInternal: function(effect) {
    new Effect.Scale(element, 1, {
      scaleContent: false,
      scaleY: false,
      afterFinishInternal: function(effect) {
        effect.element.hide().undoClipping().setStyle(oldStyle);
      } });
  }}, arguments[1] || { }));
};

Effect.Morph = Class.create(Effect.Base, {
  initialize: function(element) {
    this.element = $(element);
    if (!this.element) throw(Effect._elementDoesNotExistError);
    var options = Object.extend({
      style: { }
    }, arguments[1] || { });

    if (!Object.isString(options.style)) this.style = $H(options.style);
    else {
      if (options.style.include(':'))
        this.style = options.style.parseStyle();
      else {
        this.element.addClassName(options.style);
        this.style = $H(this.element.getStyles());
        this.element.removeClassName(options.style);
        var css = this.element.getStyles();
        this.style = this.style.reject(function(style) {
          return style.value == css[style.key];
        });
        options.afterFinishInternal = function(effect) {
          effect.element.addClassName(effect.options.style);
          effect.transforms.each(function(transform) {
            effect.element.style[transform.style] = '';
          });
        };
      }
    }
    this.start(options);
  },

  setup: function(){
    function parseColor(color){
      if (!color || ['rgba(0, 0, 0, 0)','transparent'].include(color)) color = '#ffffff';
      color = color.parseColor();
      return $R(0,2).map(function(i){
        return parseInt( color.slice(i*2+1,i*2+3), 16 );
      });
    }
    this.transforms = this.style.map(function(pair){
      var property = pair[0], value = pair[1], unit = null;

      if (value.parseColor('#zzzzzz') != '#zzzzzz') {
        value = value.parseColor();
        unit  = 'color';
      } else if (property == 'opacity') {
        value = parseFloat(value);
        if (Prototype.Browser.IE && (!this.element.currentStyle.hasLayout))
          this.element.setStyle({zoom: 1});
      } else if (Element.CSS_LENGTH.test(value)) {
          var components = value.match(/^([\+\-]?[0-9\.]+)(.*)$/);
          value = parseFloat(components[1]);
          unit = (components.length == 3) ? components[2] : null;
      }

      var originalValue = this.element.getStyle(property);
      return {
        style: property.camelize(),
        originalValue: unit=='color' ? parseColor(originalValue) : parseFloat(originalValue || 0),
        targetValue: unit=='color' ? parseColor(value) : value,
        unit: unit
      };
    }.bind(this)).reject(function(transform){
      return (
        (transform.originalValue == transform.targetValue) ||
        (
          transform.unit != 'color' &&
          (isNaN(transform.originalValue) || isNaN(transform.targetValue))
        )
      );
    });
  },
  update: function(position) {
    var style = { }, transform, i = this.transforms.length;
    while(i--)
      style[(transform = this.transforms[i]).style] =
        transform.unit=='color' ? '#'+
          (Math.round(transform.originalValue[0]+
            (transform.targetValue[0]-transform.originalValue[0])*position)).toColorPart() +
          (Math.round(transform.originalValue[1]+
            (transform.targetValue[1]-transform.originalValue[1])*position)).toColorPart() +
          (Math.round(transform.originalValue[2]+
            (transform.targetValue[2]-transform.originalValue[2])*position)).toColorPart() :
        (transform.originalValue +
          (transform.targetValue - transform.originalValue) * position).toFixed(3) +
            (transform.unit === null ? '' : transform.unit);
    this.element.setStyle(style, true);
  }
});

Effect.Transform = Class.create({
  initialize: function(tracks){
    this.tracks  = [];
    this.options = arguments[1] || { };
    this.addTracks(tracks);
  },
  addTracks: function(tracks){
    tracks.each(function(track){
      track = $H(track);
      var data = track.values().first();
      this.tracks.push($H({
        ids:     track.keys().first(),
        effect:  Effect.Morph,
        options: { style: data }
      }));
    }.bind(this));
    return this;
  },
  play: function(){
    return new Effect.Parallel(
      this.tracks.map(function(track){
        var ids = track.get('ids'), effect = track.get('effect'), options = track.get('options');
        var elements = [$(ids) || $$(ids)].flatten();
        return elements.map(function(e){ return new effect(e, Object.extend({ sync:true }, options)) });
      }).flatten(),
      this.options
    );
  }
});

Element.CSS_PROPERTIES = $w(
  'backgroundColor backgroundPosition borderBottomColor borderBottomStyle ' +
  'borderBottomWidth borderLeftColor borderLeftStyle borderLeftWidth ' +
  'borderRightColor borderRightStyle borderRightWidth borderSpacing ' +
  'borderTopColor borderTopStyle borderTopWidth bottom clip color ' +
  'fontSize fontWeight height left letterSpacing lineHeight ' +
  'marginBottom marginLeft marginRight marginTop markerOffset maxHeight '+
  'maxWidth minHeight minWidth opacity outlineColor outlineOffset ' +
  'outlineWidth paddingBottom paddingLeft paddingRight paddingTop ' +
  'right textIndent top width wordSpacing zIndex');

Element.CSS_LENGTH = /^(([\+\-]?[0-9\.]+)(em|ex|px|in|cm|mm|pt|pc|\%))|0$/;

String.__parseStyleElement = document.createElement('div');
String.prototype.parseStyle = function(){
  var style, styleRules = $H();
  if (Prototype.Browser.WebKit)
    style = new Element('div',{style:this}).style;
  else {
    String.__parseStyleElement.innerHTML = '<div style="' + this + '"></div>';
    style = String.__parseStyleElement.childNodes[0].style;
  }

  Element.CSS_PROPERTIES.each(function(property){
    if (style[property]) styleRules.set(property, style[property]);
  });

  if (Prototype.Browser.IE && this.include('opacity'))
    styleRules.set('opacity', this.match(/opacity:\s*((?:0|1)?(?:\.\d*)?)/)[1]);

  return styleRules;
};

if (document.defaultView && document.defaultView.getComputedStyle) {
  Element.getStyles = function(element) {
    var css = document.defaultView.getComputedStyle($(element), null);
    return Element.CSS_PROPERTIES.inject({ }, function(styles, property) {
      styles[property] = css[property];
      return styles;
    });
  };
} else {
  Element.getStyles = function(element) {
    element = $(element);
    var css = element.currentStyle, styles;
    styles = Element.CSS_PROPERTIES.inject({ }, function(results, property) {
      results[property] = css[property];
      return results;
    });
    if (!styles.opacity) styles.opacity = element.getOpacity();
    return styles;
  };
}

Effect.Methods = {
  morph: function(element, style) {
    element = $(element);
    new Effect.Morph(element, Object.extend({ style: style }, arguments[2] || { }));
    return element;
  },
  visualEffect: function(element, effect, options) {
    element = $(element);
    var s = effect.dasherize().camelize(), klass = s.charAt(0).toUpperCase() + s.substring(1);
    new Effect[klass](element, options);
    return element;
  },
  highlight: function(element, options) {
    element = $(element);
    new Effect.Highlight(element, options);
    return element;
  }
};

$w('fade appear grow shrink fold blindUp blindDown slideUp slideDown '+
  'pulsate shake puff squish switchOff dropOut').each(
  function(effect) {
    Effect.Methods[effect] = function(element, options){
      element = $(element);
      Effect[effect.charAt(0).toUpperCase() + effect.substring(1)](element, options);
      return element;
    };
  }
);

$w('getInlineOpacity forceRerendering setContentZoom collectTextNodes collectTextNodesIgnoreClass getStyles').each(
  function(f) { Effect.Methods[f] = Element[f]; }
);

Element.addMethods(Effect.Methods);
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.



var CC = CC || new Object();
var CoreCollaboration = CoreCollaboration || CC;

// Warn about disabled cookies.

if (!navigator.cookieEnabled) {
	alert("_Cookies.NoCookiesUnsupported".loc());
}

// Called once the document object is available.

var d;
document.observe("dom:loaded", function() {
	d = document;
	// Signal any shared instances and delegates to be created.
	globalNotificationCenter().publish('PAGE_INITIALIZE_FINISHED', document);
});

// Creates a global that you can use to refer to an instance of a class.  Shared
// instances are referenced using a supplied name, and can be created on-demand or on
// page load (depending on the value of inOptInstantiateOnAwakeFromPage).  Auto-creating
// happens as soon as the document object is available, instead of waiting around for the
// window onload event.

function invalidate() {
	return false;
}

Class.createWithSharedInstance = function(inOptInstanceShortcutName, inOptInstantiateOnAwakeFromPage) {
	var cls = null;
	cls = function() {
		var result = this.initialize.apply(this, arguments);
		if (result == invalidate) {
			var timeoutCallback = function() {
				try {
					if (this && this['_parentClass'] && this['_parentClass']['_sharedInstance'] == this) {
						this['_parentClass']['_sharedInstance'] = null;
					}
				}
				catch(e) {
					throw e;
				}
			}
			setTimeout(timeoutCallback.bind(this), 200);
		}
	}
	cls.autocreate = inOptInstantiateOnAwakeFromPage;
	cls.sharedInstance = function() {
		if (!cls['_sharedInstance']) {
			cls['_sharedInstance'] = new cls();
			cls['_sharedInstance']['_parentClass'] = cls;
		}
		return cls['_sharedInstance'];
	}
	if (inOptInstanceShortcutName) window[inOptInstanceShortcutName] = cls.sharedInstance;
	if (inOptInstantiateOnAwakeFromPage) {
		globalNotificationCenter().subscribe('PAGE_INITIALIZE_FINISHED', function() {
			if (cls.autocreate) cls.sharedInstance();
		});
	}
	return cls;
};

// A nextTick method which ensures that the passed function will be run on the next
// iteration of the event loop. Uses setTimeout(..., 0) as a fallback, but on supporting
// browsers, uses window.postMessage, which is significantly more efficient: http://jsperf.com/postmessage
CC.RunLoop = CC.RunLoop || new Object();
CC.RunLoop._usePostMessage = (window.postMessage != null);
CC.RunLoop._pendingMessages = [];
CC.RunLoop.nextTick = function(inCallback, inOptContext) {
   if (CC.RunLoop._usePostMessage) {
       CC.RunLoop._pendingMessages.push([inCallback, inOptContext]);
       window.postMessage('__cc-nextTick', '*');
   } else {
       if (inOptContext != null) {
           setTimeout(function() {
               inCallback.call(inOptContext);
           }, 0);
       } else {
           setTimeout(inCallback, 0);
       }
   }
};

if (browserSupportsAddEventListener()) {
	window.addEventListener('message', function(e){
	   if (e.source == window && e.data == '__cc-nextTick') {
	       e.stopPropagation();

	       while (CC.RunLoop._pendingMessages.length > 0) {
	           var fn = CC.RunLoop._pendingMessages.shift();
	           if (fn[1] != null)
	               fn[0].call(fn[1]);
	           else
	               fn[0]();
	       }
	   }
	}, false);
}

// Javascript port of NSNotificationCenter allowing you to broadcasting notifications.
// Basically a notification dispatch table where callback functions can be registered
// and executed when a notification is received matching a given name from a given sender.
// Delivers notifications to observers synchronously.

CC.Notifications = CC.Notifications || new Object();
CC.Notifications.Mixins = CC.Notifications.Mixins || new Object();

// Optimization when broadcasting notifications to a large number of recipients.

CC.Notifications.Mixins.SupportsOptimizedNotifications = {
	mSupportsOptimizedNotifications: true,
	// Returns a unique string identifier representation for this object. Allows us
	// to look up notification recievers for a targeted notification in linear time.
	getNotificationsIdentifer: function() { /* Interface */ }
};

CC.Notifications.GlobalNotificationCenter = Class.createWithSharedInstance('globalNotificationCenter');
CC.Notifications.GlobalNotificationCenter.prototype = {
	initialize: function() {
		// A hash of callback functions keyed by notification identifier.
		this.mGenericSubscribers = {};
		// A hash of targeted callbacks keyed by notification identifer.
		this.mTargetedSubscribers = {};
		// An optimized hash of targeted callbacks keyed by message name and notification identifier.
		this.mOptimizedTargetedSubscribers = {};
	},
	publish: function(inMessage, inObject, inOptExtras) {
		if (!inMessage) return false;
		var shouldNotifyGenericSubscribers = true;
		if (inObject != undefined) {
			// Notify any targeted subscribers.
			if (inObject.mSupportsOptimizedNotifications) {
				var optimized = this.mOptimizedTargetedSubscribers[inMessage];
				if (optimized) {
					var optimizedSubscriber = optimized[inObject.getNotificationsIdentifer()];
					if (optimizedSubscriber) optimizedSubscriber(inMessage, inObject, inOptExtras);
					shouldNotifyGenericSubscribers = false;
				}
			} else {
				var targetedSubscribers = this.mTargetedSubscribers[inMessage];
				if (targetedSubscribers) {
					var targetedIdx, targetedSubscriber, callback;
					for (targetedIdx = 0; targetedIdx < targetedSubscribers.length; targetedIdx++) {
						targetedSubscriber = targetedSubscribers[targetedIdx];
						callback = targetedSubscriber[0], o = targetedSubscriber[1];
						if (o == inObject && callback) callback(inMessage, inObject, inOptExtras);
					}
					shouldNotifyGenericSubscribers = false;
				}
			}
		}
		// Notify any generic subscribers (if we need to)
		if (shouldNotifyGenericSubscribers) {
			var callbacks = this.mGenericSubscribers[inMessage], callbackIdx, callback;
			if (callbacks) {
				for (callbackIdx = 0; callbackIdx < callbacks.length; callbackIdx++) {
					callback = callbacks[callbackIdx];
					callback(inMessage, inObject, inOptExtras);
				}
			}
		}
		// Always signal the test tool where it exists.
		if (window.parent && window.parent.AppleUnitTester) {
			window.parent.AppleUnitTester.sharedTester().publishMessage(inMessage);
		}
		return true;
	},
	subscribe: function(inMessage, inCallback, inOptObject) {
		if (!inMessage || !inCallback) return false;
		// Is this subscription targeted?
		if (inOptObject != undefined) {
			if (inOptObject.mSupportsOptimizedNotifications) {
				if (!this.mOptimizedTargetedSubscribers[inMessage]) this.mOptimizedTargetedSubscribers[inMessage] = {};
				var notificationID = inOptObject.getNotificationsIdentifer();
				var targetedSubscribersForMessage = this.mOptimizedTargetedSubscribers[inMessage];
				targetedSubscribersForMessage[notificationID] = inCallback;
			} else {
				if (!this.mTargetedSubscribers[inMessage]) this.mTargetedSubscribers[inMessage] = new Array();
				this.mTargetedSubscribers[inMessage].push([inCallback, inOptObject]);
			}
		} else {
			if (!this.mGenericSubscribers[inMessage]) this.mGenericSubscribers[inMessage] = new Array();
			this.mGenericSubscribers[inMessage].push(inCallback);
		}
	},
	unsubscribe: function(inMessage, inCallback, inOptObject) {
		if (inOptObject) {
			if (inOptObject.mSupportsOptimizedNotifications) {
				var optimized = this.mOptimizedTargetedSubscribers[inMessage];
				if (optimized) return optimized.unset(inOptObject.getNotificationsIdentifer());
				return true;
			}
			var targeted = this.mTargetedSubscribers[inMessage]
			if (targeted) {
				this.mTargetedSubscribers = this.mTargetedSubscribers[inMessage].reject(function(subscriber) {
					return (subscriber[0] == inCallback && subscriber[1] == inOptObject);
				});
			}
		}
		if (!this.mGenericSubscribers[inMessage]) return false;
		this.mGenericSubscribers = this.mGenericSubscribers[inMessage].without(inCallback);
		return true;
	}
};

var prototypeEventObserve = Event.observe;
Event.observe = function(elem, strEvent, callback) {
	var isMobile = /Mobile/.test(navigator.userAgent);
	if (strEvent == 'click' && isMobile) {
		strEvent = 'touchstart';
	}
	prototypeEventObserve(elem, strEvent, callback);
}

// Binds a series of event handlers to a given source.

function bindEventListeners(inParentObject, inFunctionArray) {
	if (!inParentObject || !inFunctionArray) return this;
	inFunctionArray.each(function(f) {
		inParentObject[f] = inParentObject[f].bindAsEventListener(inParentObject);
	});
}

function observeEvents(inParentObj, inElement, inFnNameArray, inOptStopObserving) {
	var elm = $(inElement);
	$H(inFnNameArray).each(function(handler) {
		if (inOptStopObserving) Event.stopObserving(elm, handler.key, inParentObj[handler.value]);
		else Event.observe(elm, handler.key, inParentObj[handler.value]);
	});
}

function stopObservingEvents(inParentObj, inElement, inFnNameArray) {
	observeEvents(inParentObj, inElement, inFnNameArray, true);
}

// Removes every child node from a given parent.

function removeAllChildNodes(inParent) {
	inParent = $(inParent);
	while (inParent.childNodes.length > 0) {
		inParent.removeChild(inParent.firstChild);
	}
}

// Replaces the contents of an element with a string or another element. Passing inEvaluate
// as true raises the safety flag for using innerHTML for the replacement.

function replaceElementContents(inElement, inStringOrObj, inEvaluate) {
	var elm = $(inElement);
	if (typeof inStringOrObj == 'string' && inEvaluate) {
		elm.innerHTML = inStringOrObj;
	}
	else {
		removeAllChildNodes(elm);
		if (typeof inStringOrObj == 'string') {
			elm.appendChild(elm.ownerDocument.createTextNode(inStringOrObj));
		} else if (inStringOrObj) {
			elm.appendChild(inStringOrObj);
		}
	}
}

function insertAtBeginning(inElement, inParentElement) {
	var elm = $(inParentElement);
	if (!elm) return false;
	if (elm.childNodes.length > 0) elm.insertBefore($(inElement), elm.firstChild);
	else elm.appendChild($(inElement));
}

function insertAfter(inElement, inSibling) {
	var elm = $(inElement);
	var sibling = $(inSibling);
	var nextSibling = sibling.nextSibling;
	if (nextSibling) nextSibling.parentNode.insertBefore(elm, nextSibling);
	else sibling.parentNode.appendChild(inElement);
}

function insertBefore(inElement, inReferenceElement) {
	var elm = $(inElement);
	var ref = $(inReferenceElement);
	ref.parentNode.insertBefore(elm, ref);
}

// Moves all children of an element before the parent, and removes the unwanted parent.

function promoteElementChildren(inParent) {
	var fragment = document.createDocumentFragment(), currentChild;
	while (inParent && inParent.hasChildNodes()) {
		currentChild = inParent.firstChild;
		inParent.removeChild(currentChild);
		fragment.appendChild(currentChild);
	}
	inParent.parentNode.insertBefore(fragment, inParent);
	inParent.parentNode.removeChild(inParent);
}

function boundsForDiv(theDiv) {
	return offsetBoundsForDiv(theDiv); // IE can't handle fixed positioning so we can't depend on this
}

function offsetBoundsForDiv(theDiv) {
	return new Array(Element.getLeft(theDiv), Element.getTop(theDiv), theDiv.offsetWidth, theDiv.offsetHeight);
}

function blur() {
	try {
		var anchors = $A(d.getElementsByTagName('a'));
		if(anchors.length){
			var firstLink = anchors.detect(function(elm) {return elm.href});
			firstLink.focus();
			firstLink.blur();
		}
	}
	catch(e) {}
}

// Does the browser support localStorage?

function browserSupportsLocalStorage() {
	try {
		return (('localStorage' in window) && window['localStorage'] != null);
	} catch (e) {
		return false;
	}
}


// Does the browser support addEventListener?

function browserSupportsAddEventListener() {
	try {
		return (('addEventListener' in window) && window['addEventListener'] != null);
	} catch (e) {
		return false;
	}
}

function browserSupportsModifyBodyClassName() {
	try {
		return (document && document.body && ('addClassName' in document.body) && document.body['addClassName'] != null);
	} catch (e) {
		return false;
	}
}

function browserSupportsJSON() {
	try {
		return (JSON !== undefined);
	} catch (e) {
		return false;
	}
}

function alphabeticalSort(a, b) {
	var aUp = a.toUpperCase(), bUp = b.toUpperCase();
	for (i = 0; i < aUp.length; i++) {
		if (aUp[i] < bUp[i]) {
			return -1;
		}
		if (aUp[i] > bUp[i]) {
			return 1;
		}
	}
	return 0;
}
;
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.

CC.Accessibility = CC.Accessibility || new Object();

// Tab index name constants.

/* Header menu items */
CC.Accessibility.TAB_INDEX_NAME_NAV_GENERAL 			= 'cc-tab-index-header-general';
CC.Accessibility.TAB_INDEX_NAME_NAV_EDIT 				= 'cc-tab-index-header-edit';
CC.Accessibility.TAB_INDEX_NAME_NAV_DOWNLOAD 			= 'cc-tab-index-header-download';
CC.Accessibility.TAB_INDEX_NAME_NAV_SCOREBOARD 			= 'cc-tab-index-header-scoreboard';
CC.Accessibility.TAB_INDEX_NAME_NAV_PLUS 				= 'cc-tab-index-header-plus';
CC.Accessibility.TAB_INDEX_NAME_NAV_PLUS_NEW_BOT		= 'cc-tab-index-header-plus-new-bot';
CC.Accessibility.TAB_INDEX_NAME_NAV_GEAR 				= 'cc-tab-index-header-gear';
CC.Accessibility.TAB_INDEX_NAME_NAV_GEAR_MOVE 			= 'cc-tab-index-header-gear-move';
CC.Accessibility.TAB_INDEX_NAME_NAV_GEAR_APPROVE 		= 'cc-tab-index-header-gear-approve';
CC.Accessibility.TAB_INDEX_NAME_NAV_GEAR_DELETE 		= 'cc-tab-index-header-gear-delete';
CC.Accessibility.TAB_INDEX_NAME_NAV_GEAR_HIDE 			= 'cc-tab-index-header-gear-hide';
CC.Accessibility.TAB_INDEX_NAME_NAV_GEAR_WIKI_SETTINGS 	= 'cc-tab-index-header-gear-wiki-settings';
CC.Accessibility.TAB_INDEX_NAME_NAV_GEAR_REPLACE 		= 'cc-tab-index-header-gear-wiki-replace';
CC.Accessibility.TAB_INDEX_NAME_NAV_GEAR_USER_SETTINGS 	= 'cc-tab-index-header-gear-user-settings';
CC.Accessibility.TAB_INDEX_NAME_NAV_GEAR_BOT_DELETE 	= 'cc-tab-index-header-gear-bot-delete';
CC.Accessibility.TAB_INDEX_NAME_NAV_GEAR_BOT_SETTINGS 	= 'cc-tab-index-header-gear-bot-settings';
CC.Accessibility.TAB_INDEX_NAME_NAV_GEAR_ABOUT 			= 'cc-tab-index-header-gear-about';
CC.Accessibility.TAB_INDEX_NAME_NAV_GEAR_HELP 			= 'cc-tab-index-header-gear-help';
CC.Accessibility.TAB_INDEX_NAME_NAV_LOGIN 				= 'cc-tab-index-header-login';
CC.Accessibility.TAB_INDEX_NAME_NAV_LOGOUT 				= 'cc-tab-index-header-logout';
CC.Accessibility.TAB_INDEX_NAME_NAV_SEARCH 				= 'cc-tab-index-header-search';

/* Banner menu items */
CC.Accessibility.TAB_INDEX_NAME_BANNER_HOME 			= 'cc-tab-index-banner-home';
CC.Accessibility.TAB_INDEX_NAME_BANNER_ACTIVITY 		= 'cc-tab-index-banner-activity';
CC.Accessibility.TAB_INDEX_NAME_BANNER_DOCUMENTS 		= 'cc-tab-index-banner-documents';
CC.Accessibility.TAB_INDEX_NAME_BANNER_TAGS 			= 'cc-tab-index-banner-tags';
CC.Accessibility.TAB_INDEX_NAME_BANNER_CALENDAR 		= 'cc-tab-index-banner-calendar';
CC.Accessibility.TAB_INDEX_NAME_BANNER_BLOG 			= 'cc-tab-index-banner-blog';

/* Filter menu items */
CC.Accessibility.TAB_INDEX_NAME_FILTER_MAIN 			= 'cc-tab-index-filter-main';
CC.Accessibility.TAB_INDEX_NAME_FILTER_SORT_BY 			= 'cc-tab-index-filter-sort-by';
CC.Accessibility.TAB_INDEX_NAME_FILTER_SORT_BY_TYPE 	= 'cc-tab-index-filter-sort-by-type';
CC.Accessibility.TAB_INDEX_NAME_FILTER_KEYWORD 			= 'cc-tab-index-filter-keyword';
CC.Accessibility.TAB_INDEX_NAME_FILTER_SAVE 			= 'cc-tab-index-filter-save';
CC.Accessibility.TAB_INDEX_NAME_FILTER_DONE				= 'cc-tab-index-filter-done';

/* Sidebar menu items */
CC.Accessibility.TAB_INDEX_NAME_SIDEBAR_TAGS 						= 'cc-tab-index-sidebar-tags';
CC.Accessibility.TAB_INDEX_NAME_SIDEBAR_TAGS_TEXTBOX 				= 'cc-tab-index-sidebar-tags-textbox';
CC.Accessibility.TAB_INDEX_NAME_SIDEBAR_TAGS_COLLECTION 			= 'cc-tab-index-sidebar-tags-collection';
CC.Accessibility.TAB_INDEX_NAME_SIDEBAR_RELATED 					= 'cc-tab-index-sidebar-related';
CC.Accessibility.TAB_INDEX_NAME_SIDEBAR_RELATED_SEARCH 				= 'cc-tab-index-sidebar-related-search';
CC.Accessibility.TAB_INDEX_NAME_SIDEBAR_RELATED_RECENT 				= 'cc-tab-index-sidebar-related-recent';
CC.Accessibility.TAB_INDEX_NAME_SIDEBAR_COMMENTS 					= 'cc-tab-index-sidebar-comments';
CC.Accessibility.TAB_INDEX_NAME_SIDEBAR_NOTIFICATIONS 				= 'cc-tab-index-sidebar-notifications';
CC.Accessibility.TAB_INDEX_NAME_SIDEBAR_HISTORY 					= 'cc-tab-index-sidebar-history';
CC.Accessibility.TAB_INDEX_NAME_SIDEBAR_HISTORY_SHOWMORE			= 'cc-tab-index-sidebar-history-showmore';
CC.Accessibility.TAB_INDEX_NAME_SIDEBAR_HISTORY_ACTION_CLOSE 		= 'cc-tab-index-sidebar-history-action-close';
CC.Accessibility.TAB_INDEX_NAME_SIDEBAR_HISTORY_ACTION_RESTORE	 	= 'cc-tab-index-sidebar-history-action-restore';
CC.Accessibility.TAB_INDEX_NAME_SIDEBAR_HISTORY_ACTION_SHOWCHANGES 	= 'cc-tab-index-sidebar-history-action-showchanges';
CC.Accessibility.TAB_INDEX_NAME_SIDEBAR_HISTORY_ACTION_HIDECHANGES 	= 'cc-tab-index-sidebar-history-action-hidechanges';
CC.Accessibility.TAB_INDEX_NAME_SIDEBAR_SHARING 					= 'cc-tab-index-sidebar-sharing';

/* Popup items - Settings */
CC.Accessibility.TAB_INDEX_NAME_POPUP_SETTINGS_GENERAL 					= 'cc-tab-index-popup-settings-general';
CC.Accessibility.TAB_INDEX_NAME_POPUP_SETTINGS_APPEARANCE 				= 'cc-tab-index-popup-settings-appearance';
CC.Accessibility.TAB_INDEX_NAME_POPUP_SETTINGS_APPEARANCE_PARAMS		= 'cc-tab-index-popup-settings-appearance-params';
CC.Accessibility.TAB_INDEX_NAME_POPUP_SETTINGS_PERMISSIONS 				= 'cc-tab-index-popup-settings-permissions';
CC.Accessibility.TAB_INDEX_NAME_POPUP_SETTINGS_PERMISSIONS_NAME 		= 'cc-tab-index-popup-settings-permissions-name';
CC.Accessibility.TAB_INDEX_NAME_POPUP_SETTINGS_PERMISSIONS_ACCESS 		= 'cc-tab-index-popup-settings-permissions-access';
CC.Accessibility.TAB_INDEX_NAME_POPUP_SETTINGS_PERMISSIONS_COMMENTS		= 'cc-tab-index-popup-settings-permissions-comments';
CC.Accessibility.TAB_INDEX_NAME_POPUP_SETTINGS_PERMISSIONS_MODERATION	= 'cc-tab-index-popup-settings-permissions-moderation';
CC.Accessibility.TAB_INDEX_NAME_POPUP_SETTINGS_BUTTON_SAVE				= 'cc-tab-index-popup-settings-button-save';
CC.Accessibility.TAB_INDEX_NAME_POPUP_SETTINGS_BUTTON_CANCEL			= 'cc-tab-index-popup-settings-button-cancel';

/* Popup items - Dialog */
CC.Accessibility.TAB_INDEX_NAME_POPUP_DIALOG_NEW_PAGE		 			= 'cc-tab-index-popup-new-page';
CC.Accessibility.TAB_INDEX_NAME_POPUP_DIALOG_DELETE_PAGE				= 'cc-tab-index-popup-move-delete-page';
CC.Accessibility.TAB_INDEX_NAME_POPUP_DIALOG_UPLOAD_FILE_TO_DOCUMENTS	= 'cc-tab-index-popup-upload-file-to-documents';
CC.Accessibility.TAB_INDEX_NAME_POPUP_DIALOG_MOVE_TO_WIKI_NAME			= 'cc-tab-index-popup-move-to-wiki-name';
CC.Accessibility.TAB_INDEX_NAME_POPUP_DIALOG_MOVE_TO_WIKI_RESULT		= 'cc-tab-index-popup-move-to-wiki-result';
CC.Accessibility.TAB_INDEX_NAME_POPUP_DIALOG_MOVE_SIMPLETEXT			= 'cc-tab-index-popup-move-simpletext';
CC.Accessibility.TAB_INDEX_NAME_POPUP_DIALOG_OK_BUTTON 					= 'cc-tab-index-popup-ok-button';
CC.Accessibility.TAB_INDEX_NAME_POPUP_DIALOG_CANCEL_BUTTON 				= 'cc-tab-index-popup-cancel-button';

/* Popup items - Dialog */
CC.Accessibility.TAB_INDEX_NAME_POPUP_CREATE_BOT_SETTINGS_TABS					= 'cc-tab-index-popup-create-bot-settings-tabs';
CC.Accessibility.TAB_INDEX_NAME_POPUP_CREATE_NEW_BOT_INFO_VIEW					= 'cc-tab-index-popup-create-new-bot-info-view';			// (Step 1/4)
CC.Accessibility.TAB_INDEX_NAME_POPUP_CREATE_NEW_BOT_SCHEDULE_VIEW				= 'cc-tab-index-popup-create-new-bot-schedule-view';		// (Step 2/4)
CC.Accessibility.TAB_INDEX_NAME_POPUP_CREATE_NEW_BOT_TESTING_VIEW				= 'cc-tab-index-popup-create-new-bot-testing-view';			// (Step 3/4)
CC.Accessibility.TAB_INDEX_NAME_POPUP_CREATE_NEW_BOT_NOTIFICATION_VIEW			= 'cc-tab-index-popup-create-new-bot-notification-view';	// (Step 4/4)
CC.Accessibility.TAB_INDEX_NAME_POPUP_CREATE_NEW_BOT_TESTING_VIEW_DEVICES		= 'cc-tab-index-popup-create-new-bot-testing-view-devices';
CC.Accessibility.TAB_INDEX_NAME_POPUP_CREATE_NEW_BOT_SCHEDULE_VIEW_SELECT_BOX	= 'cc-tab-index-popup-create-new-bot-schedule-view-select-box';
CC.Accessibility.TAB_INDEX_NAME_POPUP_CREATE_NEW_BOT_BUTTON_CANCEL				= 'cc-tab-index-popup-create-new-bot-button-cancel';
CC.Accessibility.TAB_INDEX_NAME_POPUP_CREATE_NEW_BOT_BUTTON_PREVIOUS 			= 'cc-tab-index-popup-create-new-bot-button-previous';
CC.Accessibility.TAB_INDEX_NAME_POPUP_CREATE_NEW_BOT_BUTTON_NEXT 				= 'cc-tab-index-popup-create-new-bot-button-next';

/* List of items (Activities, Documents) */
CC.Accessibility.TAB_INDEX_NAME_LIST_ITEMS 	= 'cc-tab-index-list-items';

/* Bot Header View items */
CC.Accessibility.TAB_INDEX_NAME_BOT_HEADER_VIEW_ENTITY_TITLE 					= 'cc-tab-index-bot-header-view-entity-title';
CC.Accessibility.TAB_INDEX_NAME_BOT_HEADER_VIEW_SUMMARY 						= 'cc-tab-index-bot-header-view-summary';
CC.Accessibility.TAB_INDEX_NAME_BOT_HEADER_VIEW_SUMMARY_INFO 					= 'cc-tab-index-bot-header-view-summary-info';
CC.Accessibility.TAB_INDEX_NAME_BOT_HEADER_VIEW_SUMMARY_RESULTS 				= 'cc-tab-index-bot-header-view-summary-results';
CC.Accessibility.TAB_INDEX_NAME_BOT_HEADER_VIEW_SUMMARY_RESULTS_ERRORS 			= 'cc-tab-index-bot-header-view-summary-results-errors';
CC.Accessibility.TAB_INDEX_NAME_BOT_HEADER_VIEW_SUMMARY_RESULTS_WARNINGS 		= 'cc-tab-index-bot-header-view-summary-results-warnings';
CC.Accessibility.TAB_INDEX_NAME_BOT_HEADER_VIEW_SUMMARY_RESULTS_ISSUES 			= 'cc-tab-index-bot-header-view-summary-results-issues';
CC.Accessibility.TAB_INDEX_NAME_BOT_HEADER_VIEW_SUMMARY_RESULTS_TESTS_SUMMARY 	= 'cc-tab-index-bot-header-view-summary-results-tests-summary';
CC.Accessibility.TAB_INDEX_NAME_BOT_HEADER_VIEW_SUMMARY_DOWNLOADS 				= 'cc-tab-index-bot-header-view-summary-downloads';
CC.Accessibility.TAB_INDEX_NAME_BOT_HEADER_VIEW_TESTS 							= 'cc-tab-index-bot-header-view-tests';
CC.Accessibility.TAB_INDEX_NAME_BOT_HEADER_VIEW_TESTS_HEADER					= 'cc-tab-index-bot-header-view-tests-header';
CC.Accessibility.TAB_INDEX_NAME_BOT_HEADER_VIEW_TESTS_DETAILS					= 'cc-tab-index-bot-header-view-tests-details';
CC.Accessibility.TAB_INDEX_NAME_BOT_HEADER_VIEW_TESTS_DEVICE					= 'cc-tab-index-bot-header-view-tests-device';
CC.Accessibility.TAB_INDEX_NAME_BOT_HEADER_VIEW_TESTS_BOTTOM					= 'cc-tab-index-bot-header-view-tests-bottom';
CC.Accessibility.TAB_INDEX_NAME_BOT_HEADER_VIEW_TESTS_INFO 						= 'cc-tab-index-bot-header-view-tests-info';
CC.Accessibility.TAB_INDEX_NAME_BOT_HEADER_VIEW_TESTS_RESULTS					= 'cc-tab-index-bot-header-view-tests-results';
CC.Accessibility.TAB_INDEX_NAME_BOT_HEADER_VIEW_TESTS_RESULTS_TOTALS			= 'cc-tab-index-bot-header-view-tests-results-total';
CC.Accessibility.TAB_INDEX_NAME_BOT_HEADER_VIEW_TESTS_RESULTS_TESTS_FAILED 		= 'cc-tab-index-bot-header-view-tests-results-tests-failed';
CC.Accessibility.TAB_INDEX_NAME_BOT_HEADER_VIEW_TESTS_RESULTS_TESTS_PASSED 		= 'cc-tab-index-bot-header-view-tests-results-tests-passed';
CC.Accessibility.TAB_INDEX_NAME_BOT_HEADER_VIEW_COMMITS 						= 'cc-tab-index-bot-header-view-commits';
CC.Accessibility.TAB_INDEX_NAME_BOT_HEADER_VIEW_LOGS 							= 'cc-tab-index-bot-header-view-logs';
CC.Accessibility.TAB_INDEX_NAME_BOT_HEADER_VIEW_ARCHIVES 						= 'cc-tab-index-bot-header-view-archives';
CC.Accessibility.TAB_INDEX_NAME_BOT_HEADER_VIEW_INTEGRATE						= 'cc-tab-index-bot-header-view-integrate';

CC.Accessibility.TAB_INDEX_NAME_BOT_SUMMARY_TOP									= 'cc-tab-index-bot-summary-top';
CC.Accessibility.TAB_INDEX_NAME_BOT_SUMMARY_TOP_LAST_INTEGRATION				= 'cc-tab-index-bot-summary-top-last-integration';
CC.Accessibility.TAB_INDEX_NAME_BOT_SUMMARY_TOP_LAST_INTEGRATION_VIEW_SUMMARY 	= 'cc-tab-index-bot-summary-top-last-integration-view-summary';
CC.Accessibility.TAB_INDEX_NAME_BOT_SUMMARY_TOP_NEXT_INTEGRATION				= 'cc-tab-index-bot-summary-top-next-integration';
CC.Accessibility.TAB_INDEX_NAME_BOT_SUMMARY_TOP_NEXT_INTEGRATION_INTEGRATE_NOW	= 'cc-tab-index-bot-summary-top-next-integration-integrate-now';
CC.Accessibility.TAB_INDEX_NAME_BOT_SUMMARY_TOP_DOWNLOADS						= 'cc-tab-index-bot-summary-top-downloads';
CC.Accessibility.TAB_INDEX_NAME_BOT_SUMMARY_TOP_DOWNLOADS_VIEW_ARCHIVES			= 'cc-tab-index-bot-summary-top-downloads-view-archives';
CC.Accessibility.TAB_INDEX_NAME_BOT_SUMMARY_TOP_DOWNLOADS_ARCHIVE_LINK			= 'cc-tab-index-bot-summary-top-downloads-archive-link';
CC.Accessibility.TAB_INDEX_NAME_BOT_SUMMARY_BOTTOM								= 'cc-tab-index-bot-summary-bottom';
CC.Accessibility.TAB_INDEX_NAME_BOT_SUMMARY_BOTTOM_LIST 						= 'cc-tab-index-bot-summary-bottom-list';

CC.Accessibility.TAB_INDEX_NAME_MAP = {};
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_NAV_GENERAL] = '10';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_NAV_EDIT] = '20';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_NAV_DOWNLOAD] = '30';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_NAV_SCOREBOARD] = '40';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_NAV_PLUS] = '50';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_NAV_PLUS_NEW_BOT] = '51';

CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_NAV_GEAR] = '60';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_NAV_GEAR_MOVE] = '70';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_NAV_GEAR_APPROVE] = '80';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_NAV_GEAR_DELETE] = '90';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_NAV_GEAR_HIDE] = '100';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_NAV_GEAR_WIKI_SETTINGS] = '110';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_NAV_GEAR_REPLACE] = '120';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_NAV_GEAR_USER_SETTINGS] = '130';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_NAV_GEAR_BOT_DELETE] = '131';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_NAV_GEAR_BOT_SETTINGS] = '132';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_NAV_GEAR_ABOUT] = '140';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_NAV_GEAR_HELP] = '150';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_NAV_LOGIN] = '160';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_NAV_LOGOUT] = '170';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_NAV_SEARCH] = '180';

CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_BANNER_HOME] = '200';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_BANNER_ACTIVITY] = '210';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_BANNER_DOCUMENTS] = '220';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_BANNER_TAGS] = '230';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_BANNER_CALENDAR] = '240';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_BANNER_BLOG] = '250';

CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_FILTER_MAIN] = '260';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_FILTER_SORT_BY] = '270';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_FILTER_SORT_BY_TYPE] = '280';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_FILTER_KEYWORD] = '290';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_FILTER_SAVE] = '291';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_FILTER_DONE] = '292';

CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_SIDEBAR_TAGS] = '300';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_SIDEBAR_TAGS_TEXTBOX] = '310';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_SIDEBAR_TAGS_COLLECTION] = '320';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_SIDEBAR_RELATED] = '330';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_SIDEBAR_RELATED_SEARCH] = '340';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_SIDEBAR_RELATED_RECENT] = '350';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_SIDEBAR_COMMENTS] = '360';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_SIDEBAR_NOTIFICATIONS] = '370';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_SIDEBAR_HISTORY] = '380';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_SIDEBAR_HISTORY_SHOWMORE] = '390';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_SIDEBAR_HISTORY_ACTION_CLOSE] = '501';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_SIDEBAR_HISTORY_ACTION_RESTORE] = '502';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_SIDEBAR_HISTORY_ACTION_SHOWCHANGES] = '503';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_SIDEBAR_HISTORY_ACTION_HIDECHANGES] = '504';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_SIDEBAR_SHARING] = '600';

// used for list of tags in the side bar
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_TAGS_COLLECTION] = '700';

// used for list of documents, activities, etc
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_LIST_ITEMS] = '1000'; 

/* Popups */
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_POPUP_SETTINGS_GENERAL] = '2000';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_POPUP_SETTINGS_APPEARANCE] = '2100';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_POPUP_SETTINGS_APPEARANCE_PARAMS] = '2101';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_POPUP_SETTINGS_PERMISSIONS] = '2200';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_POPUP_SETTINGS_PERMISSIONS_NAME] ='2210';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_POPUP_SETTINGS_PERMISSIONS_ACCESS] ='2220';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_POPUP_SETTINGS_PERMISSIONS_COMMENTS] ='2230';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_POPUP_SETTINGS_PERMISSIONS_MODERATION] ='2240';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_POPUP_SETTINGS_BUTTON_SAVE] = '2301';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_POPUP_SETTINGS_BUTTON_CANCEL] = '2302';

CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_POPUP_DIALOG_NEW_PAGE] = '2400'; 					// Popup: New Page in My Documents...
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_POPUP_DIALOG_DELETE_PAGE] = '2410';					// Popup: Delet Page...
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_POPUP_DIALOG_UPLOAD_FILE_TO_DOCUMENTS] = '2420'; 	// Popup: Upload File to My Documents...
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_POPUP_DIALOG_MOVE_TO_WIKI_NAME] = '2430'; 			// Popup: Move to Wiki...
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_POPUP_DIALOG_MOVE_TO_WIKI_RESULT] = '2440';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_POPUP_DIALOG_MOVE_SIMPLETEXT] = '2450';				// Popups: Log out, About, etc..
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_POPUP_DIALOG_OK_BUTTON] = '2901'; 					// Popup Buttons: OK, CANCEL
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_POPUP_DIALOG_CANCEL_BUTTON] = '2902';

CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_POPUP_CREATE_BOT_SETTINGS_TABS] = '2900';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_POPUP_CREATE_NEW_BOT_INFO_VIEW] = '2910';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_POPUP_CREATE_NEW_BOT_SCHEDULE_VIEW] = '2920';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_POPUP_CREATE_NEW_BOT_SCHEDULE_VIEW_SELECT_BOX] = '2921';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_POPUP_CREATE_NEW_BOT_TESTING_VIEW] = '2940';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_POPUP_CREATE_NEW_BOT_TESTING_VIEW_DEVICES] = '2945';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_POPUP_CREATE_NEW_BOT_NOTIFICATION_VIEW] = '2960';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_POPUP_CREATE_NEW_BOT_BUTTON_CANCEL] = '2970';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_POPUP_CREATE_NEW_BOT_BUTTON_PREVIOUS] = '2980';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_POPUP_CREATE_NEW_BOT_BUTTON_NEXT] = '2990';

// Used for traveling through list of bots on the left side bar
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_BOT_LIST] = '3000';

CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_BOT_HEADER_VIEW_ENTITY_TITLE] = '3100';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_BOT_HEADER_VIEW_SUMMARY] = '3200';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_BOT_HEADER_VIEW_SUMMARY_INFO] = '3210';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_BOT_HEADER_VIEW_SUMMARY_RESULTS] = '3220';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_BOT_HEADER_VIEW_SUMMARY_RESULTS_ERRORS] = '3221';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_BOT_HEADER_VIEW_SUMMARY_RESULTS_WARNINGS] = '3222';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_BOT_HEADER_VIEW_SUMMARY_RESULTS_ISSUES] = '3223';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_BOT_HEADER_VIEW_SUMMARY_RESULTS_TESTS_SUMMARY] = '3224';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_BOT_HEADER_VIEW_SUMMARY_DOWNLOADS] = '3230';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_BOT_HEADER_VIEW_TESTS] = '3300';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_BOT_HEADER_VIEW_TESTS_HEADER] = '3301';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_BOT_HEADER_VIEW_TESTS_INFO] = '3310';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_BOT_HEADER_VIEW_TESTS_RESULTS] = '3320';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_BOT_HEADER_VIEW_TESTS_RESULTS_TOTAL] = '3321';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_BOT_HEADER_VIEW_TESTS_RESULTS_TESTS_FAILED] = '3322';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_BOT_HEADER_VIEW_TESTS_RESULTS_TESTS_PASSED] = '3323';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_BOT_HEADER_VIEW_TESTS_DETAILS] = '3400';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_BOT_HEADER_VIEW_TESTS_DEVICE] = '3410';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_BOT_HEADER_VIEW_TESTS_BOTTOM] = '3500';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_BOT_HEADER_VIEW_COMMITS] = '3600';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_BOT_HEADER_VIEW_LOGS] = '3700';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_BOT_HEADER_VIEW_ARCHIVES] = '3800';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_BOT_HEADER_VIEW_INTEGRATE] = '4100';

// Summary Bot View
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_BOT_SUMMARY_TOP] = '3211';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_BOT_SUMMARY_TOP_LAST_INTEGRATION] = '3213';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_BOT_SUMMARY_TOP_LAST_INTEGRATION_VIEW_SUMMARY] = '3214';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_BOT_SUMMARY_TOP_NEXT_INTEGRATION] = '3225';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_BOT_SUMMARY_TOP_NEXT_INTEGRATION_INTEGRATE_NOW] = '3226';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_BOT_SUMMARY_TOP_DOWNLOADS] = '3231';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_BOT_SUMMARY_TOP_DOWNLOADS_VIEW_ARCHIVES] = '3232';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_BOT_SUMMARY_TOP_DOWNLOADS_ARCHIVE_LINK] = '3233';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_BOT_SUMMARY_BOTTOM] = '4000';
CC.Accessibility.TAB_INDEX_NAME_MAP[CC.Accessibility.TAB_INDEX_NAME_BOT_SUMMARY_BOTTOM_LIST] = '4010';

CC.Accessibility.TabIndexerElements = [];
CC.Accessibility.TabIndexerElements_Panel = [];

CC.Accessibility.accessibility = Class.createWithSharedInstance('accessibility', true);

CC.Accessibility.accessibility.prototype = {
	initialize: function() {
		CC.Accessibility.TabIndexerElements.push('root');
		CC.Accessibility.TabIndexerElements.push('quicksearch');
		CC.Accessibility.TabIndexerElements.push('table_block_settings_dialog');
		CC.Accessibility.TabIndexerElements.push('dialog_mask');
		CC.Accessibility.TabIndexerElements.push('table_block_inline_popup');
		CC.Accessibility.TabIndexerElements.push('progress_message_dialog');
		CC.Accessibility.TabIndexerElements.push('search');		 
		
		CC.Accessibility.TabIndexerElements_Panel.push('header');
		CC.Accessibility.TabIndexerElements_Panel.push('main');
		CC.Accessibility.TabIndexerElements_Panel.push('dialog_mask');
		CC.Accessibility.TabIndexerElements_Panel.push('table_block_inline_popup');
		CC.Accessibility.TabIndexerElements_Panel.push('progress_message_dialog');
		CC.Accessibility.TabIndexerElements_Panel.push('search');
	},
	
	/* Return tabIndex for a given element name */
	requestTabIndex: function(inName) {
		return CC.Accessibility.TAB_INDEX_NAME_MAP[inName];
	},
	/* Disable all the parents elements behind a popup. */
	makeRootViewsAriaHidden: function(isPanel) {	
		if (!isPanel) {
			for (i=0; i < CC.Accessibility.TabIndexerElements.length; i++) {
				if ($(CC.Accessibility.TabIndexerElements[i]))
					$(CC.Accessibility.TabIndexerElements[i]).writeAttribute('aria-hidden', 'true');
			}			
		} else {
			for (i=0; i < CC.Accessibility.TabIndexerElements_Panel.length; i++) {
				if ($(CC.Accessibility.TabIndexerElements_Panel[i]))
					$(CC.Accessibility.TabIndexerElements_Panel[i]).writeAttribute('aria-hidden', 'true');
			}			
		}
	},
	makeRootViewsAriaVisible: function(isPanel) {
		if (!isPanel) {	
			for (i=0; i < CC.Accessibility.TabIndexerElements.length; i++) {
				if ($(CC.Accessibility.TabIndexerElements[i]))
					$(CC.Accessibility.TabIndexerElements[i]).writeAttribute('aria-hidden', 'false');
			}
		} else {
			for (i=0; i < CC.Accessibility.TabIndexerElements_Panel.length; i++) {
				if ($(CC.Accessibility.TabIndexerElements_Panel[i]))
					$(CC.Accessibility.TabIndexerElements_Panel[i]).writeAttribute('aria-hidden', 'false');
			}			
		}
	}
};
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.

function createDateObjFromISO8601(inISOString, inOptIsGMT) {
	if (!inISOString) return null;
	var str = inISOString.match(/[Tt]/) ? inISOString : inISOString+'T000000Z';
	var d = str.match(/(\d{4})-?(\d{2})-?(\d{2})\s*[Tt]?(\d{2}):?(\d{2}):?(\d{2})/);
	if (!d) return null; // bail if the format doesn't match
	var dt = new Date(d[1], d[2]-1, d[3], d[4], d[5], d[6]);
	if (inOptIsGMT) dt.setHours(dt.getHours()-(dt.getTimezoneOffset() / 60));
	return dt;
}

// Copied from calendar_widget_core
function padNumberStr(theNumber, digits) {
	var padder = ((arguments.length > 2) ? arguments[2] : '0');
	var theString = "";
	theString += theNumber;
	
	for (var i = 0; i < (digits-theString.length); i++) {
		theString = padder + theString;
	}
	
	return theString;
}

function dateObjToISO8601(inDateObj, inOptMakeGMT, inIncludeZ) {
	if (!inDateObj) return null;
	var includeZ = (arguments.length > 2 ? inIncludeZ : true);
	var dt = new Date(inDateObj.getTime()); // copy the incoming date
	if (inOptMakeGMT) dt.setHours(dt.getHours()-(dt.getTimezoneOffset() / (-60)));
	var iso_string = '';
	iso_string += dt.getFullYear()
				+ padNumberStr(dt.getMonth()+1, 2)
				+ padNumberStr(dt.getDate(), 2)
				+ 'T'
				+ padNumberStr(dt.getHours(), 2)
				+ padNumberStr(dt.getMinutes(), 2)
				+ padNumberStr(dt.getSeconds(), 2)
				+ (includeZ ? 'Z' : '');
	return iso_string;
}

function getEndDateUsingDuration(inDate, inDuration) {
	var dt = new Date(inDate.getTime());
	if (inDuration.days) dt.setDate(dt.getDate() + inDuration.days);
	if (inDuration.hours) dt.setHours(dt.getHours() + inDuration.hours);
	if (inDuration.minutes) dt.setMinutes(dt.getMinutes() + inDuration.minutes);
	if (inDuration.seconds) dt.setMinutes(dt.getSeconds() + inDuration.seconds);
	return dt;
}

function getDurationUsingEndDate(inStartDate, inEndDate) {
	var time = Math.floor((inEndDate.getTime() - inStartDate.getTime()) / 1000);
	var whole = (time < 0 ? Math.ceil : Math.floor);
	var duration = {days:whole(time / 86400)};
	time = time % 86400;
	duration.hours = whole(time / 3600);
	time = time % 3600;
	duration.minutes = whole(time / 60);
	duration.seconds = time % 60;
	return duration;
}

function durationFromISO8601(inISOString) {
	if (!inISOString) return null; // bail if we're not being handed a string
	var dt = inISOString.match(/^P([^T]*)T?(.*)$/);
	if (!dt) return null; // bail if string isn't a valid format
	var duration = new Object();
	['years', 'months', 'days', 'hours', 'minutes', 'seconds'].each(function(key, i) {
		var mat = dt[Math.floor(i/3)+1].match("([0-9]+)"+key.charAt(0).toUpperCase());
		duration[key] = mat ? parseInt(mat[1]) : 0;
	});
	return duration;
}

function durationToISO8601(inDuration) {
	var str = 'P';
	if (inDuration.years && inDuration.years > 0) str += inDuration.years+'Y';
	if (inDuration.months && inDuration.months > 0) str += inDuration.months+'M';
	if (inDuration.days && inDuration.days > 0) str += inDuration.days+'D';
	str += 'T';
	if (inDuration.hours && inDuration.hours > 0) str += inDuration.hours+'H';
	if (inDuration.minutes && inDuration.minutes > 0) str += inDuration.minutes+'M';
	if (inDuration.seconds && inDuration.seconds > 0) str += inDuration.seconds+'S';
	return str;
}

function getLocalizedHourKey(inHours, inOptMinutes) {
	var dt = new Date();
	dt.setHours(inHours);
	dt.setMinutes(inOptMinutes||0);
	var formatString = (inOptMinutes && inOptMinutes > 0 ? '_Dates.DateFormats.HourAndMinutes' : '_Dates.DateFormats.Hour');
	return dt.formatDate(formatString.loc());
}

function getTimeRangeDisplayString(inStartDate, inDuration) {
	if (inDuration.days > 0 && inDuration.hours == 0 && inDuration.minutes == 0) {
		var str = inStartDate.formatDate('_Dates.DateFormats.MediumDate'.loc());
		if (inDuration.days > 1) {
			var endDate = getEndDateUsingDuration(inStartDate, inDuration);
			endDate.setDate(endDate.getDate()-1);
			str += ' - ' + endDate.formatDate('_Dates.DateFormats.MediumDate'.loc());
		}
		return str;
	}
	var time_string = getLocalizedHourKey(inStartDate.getHours(), inStartDate.getMinutes());
	var endDate = getEndDateUsingDuration(inStartDate, inDuration);
	return inStartDate.formatDate('_Dates.DateFormats.MediumDate'.loc()) + '; ' + time_string + ' - ' + getLocalizedHourKey(endDate.getHours(), endDate.getMinutes());
}
;
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.

// formatDate :
// a PHP date like function, for formatting date strings
// authored by Svend Tofte <www.svendtofte.com>
// the code is in the public domain
//
// see http://www.svendtofte.com/code/date_format/
// and http://www.php.net/date
//
// thanks to 
//  - Daniel Berlin <mail@daniel-berlin.de>,
//    major overhaul and improvements
//  - Matt Bannon,
//    correcting some stupid bugs in my days-in-the-months list!
//
// input : format string
// time : epoch time (seconds, and optional)
//
// if time is not passed, formatting is based on 
// the current "this" date object's set time.
//
// supported switches are
// a, A, B, c, d, D, F, g, G, h, H, i, I (uppercase i), j, l (lowercase L),
// L, m, M, n, N, O, P, r, s, S, t, U, w, W, y, Y, z, Z
// 
// unsupported (as compared to date in PHP 5.1.3)
// T, e, o

Date.prototype.formatDate = function (input,time) {
	
	// removed their hard-coded string arrays and moved to loc
	var daysLong = '_Dates.Weekdays'.loc().split(',');
	var daysFull = '_Dates.LongWeekdays'.loc().split(',');
	var daysShort = '_Dates.ShortWeekdays'.loc().split(',');
	var monthsShort = '_Dates.Months'.loc().split(',');
	var monthsLong = '_Dates.LongMonths'.loc().split(',');
	var ampm = '_Dates.AMPM'.loc().split(',');

	var switches = { // switches object
		
		a : function () {
			// Lowercase Ante meridiem and Post meridiem
			// modified to use loc array
			return ampm[Math.floor(date.getHours()/12)];
		},
		
		A : function () {
			// Uppercase Ante meridiem and Post meridiem
			return (this.a().toUpperCase());
		},
	
		B : function (){
			// Swatch internet time. code simply grabbed from ppk,
			// since I was feeling lazy:
			// http://www.xs4all.nl/~ppk/js/beat.html
			var off = (date.getTimezoneOffset() + 60)*60;
			var theSeconds = (date.getHours() * 3600) + 
							 (date.getMinutes() * 60) + 
							  date.getSeconds() + off;
			var beat = Math.floor(theSeconds/86.4);
			if (beat > 1000) beat -= 1000;
			if (beat < 0) beat += 1000;
			if ((String(beat)).length == 1) beat = "00"+beat;
			if ((String(beat)).length == 2) beat = "0"+beat;
			return beat;
		},
		
		c : function () {
			// ISO 8601 date (e.g.: "2004-02-12T15:19:21+00:00"), as per
			// http://www.cl.cam.ac.uk/~mgk25/iso-time.html
			return (this.Y() + "-" + this.m() + "-" + this.d() + "T" + 
					this.h() + ":" + this.i() + ":" + this.s() + this.P());
		},
		
		d : function () {
			// Day of the month, 2 digits with leading zeros
			var j = String(this.j());
			return (j.length == 1 ? "0"+j : j);
		},
		
		D : function () {
			// A textual representation of a day, three letters
			return daysShort[date.getDay()];
		},
		
		F : function () {
			// A full textual representation of a month
			return monthsLong[date.getMonth()];
		},
		
		g : function () {
			// 12-hour format of an hour without leading zeros
			return date.getHours() > 12? date.getHours()-12 : (date.getHours()==0?12:date.getHours());
		},
		
		G : function () {
			// 24-hour format of an hour without leading zeros
			return date.getHours();
		},
		
		h : function () {
			// 12-hour format of an hour with leading zeros
			var g = String(this.g());
			return (g.length == 1 ? "0"+g : g);
		},
		
		H : function () {
			// 24-hour format of an hour with leading zeros
			var G = String(this.G());
			return (G.length == 1 ? "0"+G : G);
		},
		
		i : function () {
			// Minutes with leading zeros
			var min = String (date.getMinutes ());
			return (min.length == 1 ? "0" + min : min);
		},
		
		I : function () {
			// Whether or not the date is in daylight saving time (DST)
			// note that this has no bearing in actual DST mechanics,
			// and is just a pure guess. buyer beware.
			var noDST = new Date ("January 1 " + this.Y() + " 00:00:00");
			return (noDST.getTimezoneOffset () == 
					date.getTimezoneOffset () ? 0 : 1);
		},
		
		j : function () {
			// Day of the month without leading zeros
			return date.getDate();
		},
		
		l : function () {
			// A full textual representation of the day of the week
			return daysLong[date.getDay()];
		},
		
		x : function () {
			// Overload x to get proper full textual representation of the day of the week.
			return daysFull[date.getDay()];
		},
		
		L : function () {
			// leap year or not. 1 if leap year, 0 if not.
			// the logic should match iso's 8601 standard.
			// http://www.uic.edu/depts/accc/software/isodates/leapyear.html
			var Y = this.Y();
			if (         
				(Y % 4 == 0 && Y % 100 != 0) ||
				(Y % 4 == 0 && Y % 100 == 0 && Y % 400 == 0)
				) {
				return 1;
			} else {
				return 0;
			}
		},
		
		m : function () {
			// Numeric representation of a month, with leading zeros
			var n = String(this.n());
			return (n.length == 1 ? "0"+n : n);
		},
		
		M : function () {
			// A short textual representation of a month, three letters
			return monthsShort[date.getMonth()];
		},
		
		n : function () {
			// Numeric representation of a month, without leading zeros
			return date.getMonth()+1;
		},
		
		N : function () {
			// ISO-8601 numeric representation of the day of the week
			var w = this.w();
			return (w == 0 ? 7 : w);
		},
		
		O : function () {
			// Difference to Greenwich time (GMT) in hours
			var os = Math.abs(date.getTimezoneOffset());
			var h = String(Math.floor(os/60));
			var m = String(os%60);
			h.length == 1? h = "0"+h:1;
			m.length == 1? m = "0"+m:1;
			return date.getTimezoneOffset() < 0 ? "+"+h+m : "-"+h+m;
		},
		
		P : function () {
			// Difference to GMT, with colon between hours and minutes
			var O = this.O();
			return (O.substr(0, 3) + ":" + O.substr(3, 2));
		},      
		
		r : function () {
			// RFC 822 formatted date
			var r; // result
			//  Thu         ,     21               Dec              2000
			r = this.D() + ", " + this.d() + " " + this.M() + " " + this.Y() +
			//    16          :    01          :    07               0200
			" " + this.H() + ":" + this.i() + ":" + this.s() + " " + this.O();
			return r;
		},

		s : function () {
			// Seconds, with leading zeros
			var sec = String (date.getSeconds ());
			return (sec.length == 1 ? "0" + sec : sec);
		},        
		
		S : function () {
			// English ordinal suffix for the day of the month, 2 characters
			switch (date.getDate ()) {
				case  1: return ("st"); 
				case  2: return ("nd"); 
				case  3: return ("rd");
				case 21: return ("st"); 
				case 22: return ("nd"); 
				case 23: return ("rd");
				case 31: return ("st");
				default: return ("th");
			}
		},
		
		t : function () {
			// thanks to Matt Bannon for some much needed code-fixes here!
			var daysinmonths = [null,31,28,31,30,31,30,31,31,30,31,30,31];
			if (this.L()==1 && this.n()==2) return 29; // ~leap day
			return daysinmonths[this.n()];
		},
		
		U : function () {
			// Seconds since the Unix Epoch (January 1 1970 00:00:00 GMT)
			return Math.round(date.getTime()/1000);
		},

		w : function () {
			// Numeric representation of the day of the week
			return date.getDay();
		},
		
		W : function () {
			// Weeknumber, as per ISO specification:
			// http://www.cl.cam.ac.uk/~mgk25/iso-time.html
		
			var DoW = this.N ();
			var DoY = this.z ();

			// If the day is 3 days before New Year's Eve and is Thursday or earlier,
			// it's week 1 of next year.
			var daysToNY = 364 + this.L () - DoY;
			if (daysToNY <= 2 && DoW <= (3 - daysToNY)) {
				return 1;
			}

			// If the day is within 3 days after New Year's Eve and is Friday or later,
			// it belongs to the old year.
			if (DoY <= 2 && DoW >= 5) {
				return new Date (this.Y () - 1, 11, 31).formatDate ("W");
			}
			
			var nyDoW = new Date (this.Y (), 0, 1).getDay ();
			nyDoW = nyDoW != 0 ? nyDoW - 1 : 6;

			if (nyDoW <= 3) { // First day of the year is a Thursday or earlier
				return (1 + Math.floor ((DoY + nyDoW) / 7));
			} else {  // First day of the year is a Friday or later
				return (1 + Math.floor ((DoY - (7 - nyDoW)) / 7));
			}
		},
		
		y : function () {
			// A two-digit representation of a year
			var y = String(this.Y());
			return y.substring(y.length-2,y.length);
		},        
		
		Y : function () {
			// A full numeric representation of a year, 4 digits
	
			// we first check, if getFullYear is supported. if it
			// is, we just use that. ppks code is nice, but wont
			// work with dates outside 1900-2038, or something like that
			if (date.getFullYear) {
				var newDate = new Date("January 1 2001 00:00:00 +0000");
				var x = newDate .getFullYear();
				if (x == 2001) {              
					// i trust the method now
					return date.getFullYear();
				}
			}
			// else, do this:
			// codes thanks to ppk:
			// http://www.xs4all.nl/~ppk/js/introdate.html
			var x = date.getYear();
			var y = x % 100;
			y += (y < 38) ? 2000 : 1900;
			return y;
		},

		
		z : function () {
			// The day of the year, zero indexed! 0 through 366
			var t = new Date("January 1 " + this.Y() + " 00:00:00");
			var diff = date.getTime() - t.getTime();
			return Math.floor(diff/1000/60/60/24);
		},

		Z : function () {
			// Timezone offset in seconds
			return (date.getTimezoneOffset () * -60);
		}        
	
	}

	function getSwitch(str) {
		if (switches[str] != undefined) {
			return switches[str]();
		} else {
			return str;
		}
	}

	var date;
	if (time) {
		var date = new Date (time);
	} else {
		var date = this;
	}

	var formatString = input.split("");
	var i = 0;
	while (i < formatString.length) {
		if (formatString[i] == "\\") {
			// this is our way of allowing users to escape stuff
			formatString.splice(i,1);
		} else {
			formatString[i] = getSwitch(formatString[i]);
		}
		i++;
	}
	
	return formatString.join("");
}


// Some (not all) predefined format strings from PHP 5.1.1, which 
// offer standard date representations.
// See: http://www.php.net/manual/en/ref.datetime.php#datetime.constants
//

// Atom      "2005-08-15T15:52:01+00:00"
Date.DATE_ATOM    = "Y-m-d\\TH:i:sP";
// ISO-8601  "2005-08-15T15:52:01+0000"
Date.DATE_ISO8601 = "Y-m-d\\TH:i:sO";
// RFC 2822  "Mon, 15 Aug 2005 15:52:01 +0000"
Date.DATE_RFC2822 = "D, d M Y H:i:s O";
// W3C       "2005-08-15T15:52:01+00:00"
Date.DATE_W3C     = "Y-m-d\\TH:i:sP";
if (window.loaded) loaded('formatDate.js');
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
//
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.





var apple_loc_strings = apple_loc_strings || {};

CC.LocalizationManager = Class.createWithSharedInstance('globalLocalizationManager', false);
CC.LocalizationManager.prototype = {
	_strings: {},
	initialize: function() {
	    this.setStrings(apple_loc_strings);
	},
	setStrings: function(stringsHash) {
	    Object.extend(this._strings, stringsHash);
	},
	localize: function(key) {
		return this._strings[key] || key;
	},
	getLprojLocale: function() {
		var LANGUAGE_TO_LPROJ_MAP = {
		  'de': 'de',
		  'en': 'en',
		  'es': 'es',
		  'fr': 'fr',
		  'it': 'it',
		  'ja': 'ja',
		  'ko': 'ko',
		  'nl': 'nl',
		  'zh-cn': 'zh_CN',
		  'zh-tw': 'zh_TW'
		};
		var browserLocale = navigator.language || navigator.browserLanguage || 'en';
		var lProjLocale = LANGUAGE_TO_LPROJ_MAP[browserLocale];
		if (!lProjLocale) {
			// If we can't find an exact match on language AND region, try language alone.
			// For ex, browser can return zh-cn, but also fr-fr or ja-jp, and in the last 2 cases we need to match on fr and ja.
			lProjLocale = LANGUAGE_TO_LPROJ_MAP[browserLocale.split('-')[0]];
		}
		return lProjLocale || 'en';
	},
	localizedDay: function(inDate, inOptUseShortFormat) {
		var adjustedDate = this.adjustDateForUTCOffset(inDate);
		if (adjustedDate) {
			var day_index = adjustedDate.getDay();
			if (day_index < 7) {
				if (inOptUseShortFormat) {
					return "_Date.Short.Day.Names".loc().split(',')[day_index];
				} else {
					return "_Date.Day.Names".loc().split(',')[day_index];
				}
			}
		}
		return "_Date.Unknown".loc();
	},
	localizedDate: function(inDate, inOptUseShortFormat) {
		var adjustedDate = this.adjustDateForUTCOffset(inDate);
		if (adjustedDate) {
			var day_delta = this.calculateDayDeltaForDateFromToday(adjustedDate);
			if (day_delta == 0) {
				return "_Date.Today".loc();
			} else if (day_delta == -1) {
				return "_Date.Yesterday".loc();
			} else if (day_delta == 1) {
				return "_Date.Tomorrow".loc();
			} else {
				var month = adjustedDate.getMonth();
				var localizedMonth;
				if (inOptUseShortFormat) {
					localizedMonth = "_Date.Short.Month.Names".loc().split(',')[month % 12];
				} else {
					localizedMonth = "_Date.Month.Names".loc().split(',')[month % 12];
				}
				var day = adjustedDate.getDate();
				if (Math.abs(day_delta) <= 365) {
					return "_Date.Short.Format".loc(localizedMonth, day);
				} else {
					var year = adjustedDate.getFullYear();
					return "_Date.Long.Format".loc(localizedMonth, day, year);
				}
			}
		}
		return "_Date.Unknown".loc();
	},
	localizedDateWithTime: function(inDate, inOptUseShortFormat) {
		if (inDate) {
			return "_DateTime.Format".loc(this.localizedDate(inDate, inOptUseShortFormat), this.localizedTime(inDate));
		}
		return "_DateTime.Unknown".loc();
	},
	localizedTime: function(inDate) {
		var adjustedDate = this.adjustDateForUTCOffset(inDate);
		if (adjustedDate) {
			var hours = adjustedDate.getHours();
			var am = false;
			if (hours == 0) {
				hours = 12;
				am = true;
			} else if (hours < 12) {
				if (hours > 0) am = true;
			} else if (hours > 12) {
				hours -= 12;
			}
			var minutes = adjustedDate.getMinutes();
			if (minutes < 10) minutes = "0" + minutes;
			return "_Time.Default.Format".loc(hours, minutes, (am ? "_Time.AM".loc() : "_Time.PM".loc()));
		}
		return "_Time.Unknown".loc();
	},
	// Returns a "Today", "Yesterday", "XX at YY:ZZ PM" UTC-adjusted formatted date string.
	localizedDateTime: function(inDate) {
		if (inDate) {
			var adjustedDate = this.adjustDateForUTCOffset(inDate);
			if (adjustedDate) {
				var date = this.localizedDate(adjustedDate);
				var time = this.localizedTime(adjustedDate);
				return "_DateTime.Format".loc(date, time);
			}
		}
		return "_DateTime.Unknown".loc();
	},
	// Returns a "Day at YY:ZZ PM" date string.
	localizedDayAndTime: function(inDate) {
		if (inDate) {
			var adjustedDate = this.adjustDateForUTCOffset(inDate);
			if (adjustedDate) {
				var localizedDay = this.localizedDay(adjustedDate);
				var localizedTime = this.localizedTime(adjustedDate);
				return "_DateTime.Format".loc(localizedDay, localizedTime);
			}
		}
		return "_DateTime.Unknown".loc();
	},
	// Returns the time if the given date is today, otherwise a XX/YY/ZZZZ at AA:BB UTC-adjusted formatted date time string.
	shortLocalizedDateTime: function(inDate) {
		if (inDate) {
			var adjustedDate = this.adjustDateForUTCOffset(inDate);
			if (adjustedDate) {
				var day_delta = this.calculateDayDeltaForDateFromToday(adjustedDate);
				if (day_delta == 0) {
					return this.localizedTime(adjustedDate);
				} else {
					// Remember to increment the month value since they're zero-indexed.
					var localizedDate = "_Date.Default.Format".loc((adjustedDate.getMonth() + 1), adjustedDate.getDate(), adjustedDate.getFullYear());
					var localizedTime = this.localizedTime(adjustedDate);
					return "_DateTime.Format".loc(localizedDate, localizedTime);
				}
			}
		}
		return "_DateTime.Unknown".loc();
	},
	// Returns a "XX/YY/ZZZZ" date string.
	shortLocalizedDate: function(inDate) {
		if (inDate) {
			var adjustedDate = this.adjustDateForUTCOffset(inDate);
			if (adjustedDate) {
				// Remember to increment the month value since they're zero-indexed.
				return "_Date.Default.Format".loc((adjustedDate.getMonth() + 1), adjustedDate.getDate(), adjustedDate.getFullYear());
			}
		}
		return "_DateTime.Unknown".loc();
	},
	// Returns a "XX/YY/ZZZZ HH:MM AM" date time string.
	shortLocalizedDateAndTime: function(inDate) {
		if (inDate) {
			return "_DateTime.NoAt.Format".loc(this.shortLocalizedDate(inDate), this.localizedTime(inDate));
		}
		return "_DateTime.Unknown".loc();
	},
	// Returns a "Mon DD YYYY" date time string.
	shortLocalizedDateWithMonthAsString: function(inDate) {
		var adjustedDate = this.adjustDateForUTCOffset(inDate);
		if (adjustedDate) {
			var month = adjustedDate.getMonth();
			var localizedMonth = "_Date.Short.Month.Names".loc().split(',')[month % 12];
			var day = adjustedDate.getDate();
			var year = adjustedDate.getFullYear();
			return "_Date.Long.Format".loc(localizedMonth, day, year);
		}
		return "_Date.Unknown".loc();
	},
	// Returns a "Mon DD YYYY HH:MM AM" if torday, or "Mon DD YYYY" date time string.
	shortLocalizedDateWithMonthAsStringWithTodaysTime: function(inDate) {
		var adjustedDate = this.adjustDateForUTCOffset(inDate);		
		if (adjustedDate) {
			var day_delta = this.calculateDayDeltaForDateFromToday(adjustedDate);
			var month = adjustedDate.getMonth();
			var day = adjustedDate.getDate();
			var year = adjustedDate.getFullYear();
			var localizedMonth = "_Date.Short.Month.Names".loc().split(',')[month % 12];
			
			if (day_delta == 0) {
				var time = this.localizedTime(adjustedDate);
				return "_Date.Long.WithTime.Format".loc(localizedMonth, day, year,time);
			}
			else {
				return "_Date.Long.Format".loc(localizedMonth, day, year);
			}
		}
		return "_Date.Unknown".loc();
	},
	calculateDayDeltaForDateFromToday: function(inDate) {
		return this.calculateDayDeltaForDateFromDate(inDate, new Date());
	},
	calculateDayDeltaForDateFromDate: function(inDate, inSecondDate) {
		if (!inDate || !inSecondDate) return undefined;
		// Strip everything but the day/month/year from the supplied dates.
		var inSecondDateStripped = new Date(inSecondDate.getFullYear(), inSecondDate.getMonth(), inSecondDate.getDate());
		var inDateStripped = new Date(inDate.getFullYear(), inDate.getMonth(), inDate.getDate());
		// If the difference between the two dates is zero, the day delta is 0.
		var dateDifference = inSecondDateStripped.getTime() - inDateStripped.getTime();
		// If the difference is greater than zero, the supplied date is before the stripped today date.
		// Otherwise if the difference is less than zero, the supplied date is after the stripped today
		// date. We negate the result here so one full day in the past is returned as -1.
		if (dateDifference > 0) {
			return -1 * ((dateDifference / (1000 * 60 * 60)) / 24)
		} else if (dateDifference < 0) {
			return ((Math.abs(dateDifference) / (1000 * 60 * 60)) / 24)
		} else {
			return 0;
		}
	},
	adjustDateForUTCOffset: function(inDate) {
		if (!inDate) return undefined;
		var dt = new Date();
		var offset = dt.getTimezoneOffset();
		var gmt_offset = inDate.getTimezoneOffset();
		var minutes_delta = offset - gmt_offset;
		inDate.setMinutes(inDate.getMinutes() + minutes_delta);
		return inDate;
	},
	localizedFileSize: function(inBytes) {
		if (!inBytes) return inBytes;
		if (inBytes < 1024) {
			return Math.round(inBytes) + " Bytes";
		} else if (inBytes < 1048576) {
			return Math.round(((inBytes / 1024) * 100) / 100)  + " KB";
		} else if (inBytes < 1073741824) {
			return  Math.round(((inBytes / 1048576) * 100) / 100) + " MB";
		} else {
			return  Math.round(((inBytes / 1073741824) * 100) / 100) + " GB";
		}
	},
	localizedDuration: function(inStartDate, inEndDate) {
		if (!inStartDate || !inEndDate) return;
		var delta = Math.abs(inEndDate.getTime() - inStartDate.getTime());
		var dayDifference = Math.floor(delta / (1000 * 60 * 60 * 24));
		delta = (delta % (1000 * 60 * 60 * 24));
		
		if (dayDifference > 1) {
			return "_Duration.MoreThanADay".loc();
		}
		
		var hourDifference = Math.floor(delta / (1000 * 60 * 60));
		delta = (delta % (1000 * 60 * 60));
		
		var minuteDifference = Math.floor(delta / (1000 * 60));
		delta = (delta % (1000 * 60));
		
		var secondDifference = Math.floor(delta / 1000);
		
		if (hourDifference >= 1) {
			if (hourDifference == 1) {
				if (minuteDifference == 1) {
					return "_Duration.SingleHourSingleMinutes".loc();
				} else {
					return "_Duration.SingleHourMinutes".loc(minuteDifference);
				}
			} else {
				if (minuteDifference == 1) {
					return "_Duration.PluralHourSingleMinutes".loc(hourDifference);
				} else {
					return "_Duration.PluralHourMinutes".loc(hourDifference, minuteDifference);
				}
			}
		}
		if (minuteDifference <= 1) {
			return "_Duration.LessThanAMinute".loc();
		} else {
			return "_Duration.Minutes".loc(minuteDifference);
		}
	},
	// Returns something like "Just now", "5 min ago", or "In 2 hrs"
	localizedTimeShift: function(inDate) {
		if (!inDate) return;
		var delta = Date.now() - inDate.getTime();
		var future = (delta < 0);
		delta = Math.abs(delta);
		
		// if we're in the future, and have non-zero seconds, add a minute for more "natural" countdowns
		if (future && Math.floor((delta % (1000 * 60)) / 1000) > 0)
			delta += (1000 * 60);
		
		var dayDifference = Math.floor(delta / (1000 * 60 * 60 * 24));
		delta = (delta % (1000 * 60 * 60 * 24));
		
		if (dayDifference >= 1) {
			if (dayDifference == 1) {
				return (future) ? "_TimeDifference.InSingleDays".loc() : "_TimeDifference.SingleDaysAgo".loc();
			} else {
				return (future) ? "_TimeDifference.InPluralDays".loc(dayDifference) : "_TimeDifference.PluralDaysAgo".loc(dayDifference);
			}
		}
		
		var hourDifference = Math.floor(delta / (1000 * 60 * 60));
		delta = (delta % (1000 * 60 * 60));
		
		var minuteDifference = Math.floor(delta / (1000 * 60));
		delta = (delta % (1000 * 60));
		
		var secondDifference = Math.floor(delta / 1000);
		
		if (hourDifference >= 1) {
			if (hourDifference == 1) {
				return (future) ? "_TimeDifference.InSingleHours".loc() : "_TimeDifference.SingleHoursAgo".loc();
			} else {
				return (future) ? "_TimeDifference.InPluralHours".loc(hourDifference) : "_TimeDifference.PluralHoursAgo".loc(hourDifference);
			}
		}
		
		if (minuteDifference < 1) {
			return (future) ? "_TimeDifference.InSingleMinutes".loc() : "_TimeDifference.LessThanAMinuteAgo".loc();
		} else if (minuteDifference == 1) {
			return (future) ? "_TimeDifference.InSingleMinutes".loc() : "_TimeDifference.SingleMinutesAgo".loc();
		} else {
			return (future) ? "_TimeDifference.InPluralMinutes".loc(minuteDifference) : "_TimeDifference.PluralMinutesAgo".loc(minuteDifference);
		}
	}
};

// Localizes a string.

String.prototype.loc = function() {
	var str = globalLocalizationManager().localize(this);
	return str.fmt.apply(str, arguments);
};
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.

// Breaks a string into an array of tokens.

String.prototype.w = function() {
	var result = [], parts = this.split(' '), length = parts.length;
	for (var idx = 0; idx < length; idx++) {
		var part = parts[idx] ;
		if (part.length !== 0) result.push(part);
	}
	return result;
};

// Returns true if a string is just whitespace.

String.prototype.isWhitespace = function() {
	return this.match(/^[ \t\r\n]+$/);
};

// Substitutes into a string. Borrowed from SproutCore.

String.prototype.fmt = function() {
	var args = arguments;
	var idx  = 0;
	return this.replace(/%@([0-9]+)?/g, function(s, argIndex) {
		argIndex = (argIndex) ? parseInt(argIndex,0) - 1 : idx++;
		s = args[argIndex];
		return ((s === null) ? '(null)' : (s === undefined) ? '' : s).toString(); 
	});
};

// Returns a string with the first character uppercased. We have a seperate method for this
// versus Prototype#capitalize method because Prototype downcases the entire string before
// uppercasing the first character.

String.prototype.capitalizeFirstCharacter = function() {
	return this.charAt(0).toUpperCase() + this.slice(1);
};

String.prototype.trim = function() {
	return this.toString().replace(/^[\s\t\n\r]*|[\s\t\n\r]*$/g,'');
};

// Returns a random string.

var buildRandomString = function(inLength) {
	var result = "";
	var alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
	for (var idx = 0; idx < (inLength || 5); idx++) {
		result += alphabet.charAt(Math.floor(Math.random() * alphabet.length));
	}
	return result;
};

// Does a string look like a GUID?

var looksLikeGUID = function(inString) {
	return (inString || "").match(/^\w{8}-\w{4}-\w{4}-\w{4}-\w{12}$/);
};

// Returns the intersection of an array of strings and a given array of strings (an array of items
// where items exist in both arrays). Accepts an optional inDifferenceInstead flag where the difference
// between the first and second arrays will be returned instead (an array of items in the second
// array but NOT in the first).

var stringArrayIntersection = function(firstArray, secondArray, inDifferenceInstead) {
	var shortestArray = firstArray, longestArray = secondArray;
	if (firstArray.length > secondArray.length) {
		longestArray = firstArray;
		shortestArray = secondArray;
	}
	// If we're building the intersection, loop over the shortest array and build
	// a result of keys that exist in the shortest array and the hash we just built.
	// If we're building the difference, do the opposite.
	var hashingArray = (inDifferenceInstead ? shortestArray : longestArray);
	var hash = {}, idx, length = hashingArray.length;
	for (idx = 0; idx < length; idx++) {
		hash[hashingArray[idx]] = true;
	}
	var loopingArray = shortestArray;
	if (inDifferenceInstead) loopingArray = longestArray;
	var value, length = loopingArray.length, result = [];
	for (idx = 0; idx < length; idx++) {
		value = loopingArray[idx];
		if ((value in hash) && !inDifferenceInstead) {
			result.push(value);
		}
		if (inDifferenceInstead && !(value in hash)) {
			result.push(value);
		}
	}
	return result;
};

var stringArrayDifference = function(firstArray, secondArray) {
	return stringArrayIntersection(firstArray, secondArray, true);
};
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.

// Simple CSDateTime utility functions.

function csDateTimeFromDate(inDate) {
	return {
		'type': 'com.apple.DateTime',
		'epochValue': (inDate.getTime() / 1000),
		'isoValue': inDate.toISOString()
	}
};

function dateFromCSDateTime(inCSDateTime) {
	return new Date(inCSDateTime.epochValue * 1000);
};
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.

Element.addMethods({
	getDataAttributes: function(element) {
		var hash = {};
		var attributes = element.attributes;
		var regex = /^data-/;
		for (var i=0, n=attributes.length; i < n; i++) {
			var attribute = attributes[i].name;
			if (regex.match(attribute)) {
				var key = attribute.gsub(regex,'');
				var value = element.readAttribute(attribute);
				hash[key] = value;
			}
		}
		return hash;
	},
	setDataAttributes: function(element, hash) {
		$H(hash).each(function(item) {
			element.writeAttribute('data-' + item.key, item.value);
		});
		return element;
	},
	setClassName: function(element, name, bool) {
		return (bool) ? element.addClassName(name) : element.removeClassName(name);
	},
	getLeft: function(inElement, inOptParent) {
		var parent = inOptParent?$(inOptParent):null;
		var currentNode = $(inElement);
		var currentLeft = 0;
		while (currentNode) {
			currentLeft += currentNode.offsetLeft;
			currentNode = currentNode.offsetParent;
			if (parent && currentNode == parent) {
				currentNode = null;
			}
			if (currentNode && !browser().isIE() && currentNode.nodeName.toLowerCase() == 'body') {
				currentNode = null;
			}
		}
		return currentLeft;
	},
	getTop: function(inElement, inOptParent) {
		var parent = inOptParent?$(inOptParent):null;
		var currentNode = $(inElement);
		var currentTop = 0;
		while (currentNode) {
			currentTop += currentNode.offsetTop;
			currentNode = currentNode.offsetParent;
			if (parent && currentNode == parent) {
				currentNode = null;
			}
			if (currentNode && !browser().isIE() && currentNode.nodeName.toLowerCase() == 'body') {
				currentNode = null;
			}
		}
		return currentTop;
	},
	setOffsetHeight: function(element, height) {
		element = $(element);
		if (height) {
			element.style.height = height+'px';
		}
		else {
			height = parseInt(element.style.height);
		}
		var actual = Element.getHeight(element);
		element.style.height = (height-(actual-height))+'px';
	},
	setOffsetWidth: function(element, width) {
		element = $(element);
		if (width) {
			element.style.width = width+'px';
		}
		else {
			width = parseInt(element.style.width);
		}
		var actual = element.offsetWidth;
		element.style.width = (width-(actual-width))+'px';
	},
	getInvisibleSize: function(inElement) {
		var elm = $(inElement);
		if (Element.visible(inElement)) return [Element.getWidth(inElement), Element.getHeight(inElement)];
		elm.style.visibility = 'hidden';
		Element.show(elm);
		var width = elm.offsetWidth;
		var height = Element.getHeight(elm);
		Element.hide(elm);
		elm.style.visibility = '';
		return [width, height];
	},
	getInvisibleHeight: function(inElement) { // ##5389514
		return Element.getInvisibleSize(inElement)[1];
	},
	isChild: function(inChildElement, inParentElement) { // ##5389516
		return Element.descendantOf(inChildElement, inParentElement);
	},
	/* The unwrap() function removes a child element from a parent matching a given selector. */
	/* inSelector is a CSS selector for a parent tag, and tagBuilderCallback is a function to return a new enclosing tag. */
	/* Don't use inOptParentTag; it's used internally when recursing through the DOM. */
	unwrap: function(inChildElm, inSelector, inTagBuilderCallback, inOptParentElm) {
		inChildElm = $(inChildElm);
		// find the parent element
		var parentElm = inOptParentElm || inChildElm.up(inSelector);
		if (parentElm) {
			// find the child which is an ancestor of the child element
			var ancestor = $A(parentElm.childNodes).detect(function(elm) {
				return (elm == inChildElm || inChildElm.descendantOf(elm));
			});
			// wrap the previous siblings
			if (ancestor && ancestor.previousSibling) {
				var subelm = inTagBuilderCallback();
				while (ancestor.previousSibling) {
					var sibling = ancestor.previousSibling;
					Element.remove(sibling);
					insertAtBeginning(sibling, subelm);
				}
				insertAtBeginning(subelm, parentElm);
			}
			// wrap the next siblings
			if (ancestor && ancestor.nextSibling) {
				var subelm = inTagBuilderCallback();
				while (ancestor.nextSibling) {
					var sibling = ancestor.nextSibling;
					Element.remove(sibling);
					subelm.appendChild(sibling);
				}
				parentElm.appendChild(subelm);
			}
			// if we're not a direct parent, recursively wrap the ancestor
			if (ancestor != inChildElm) {
				Element.unwrap(inChildElm, inSelector, inTagBuilderCallback, ancestor);
			}
			// if we're not being called recursively, remove the parent and child elements (but not their children)
			if (!inOptParentElm) {
				promoteElementChildren(parentElm);
				promoteElementChildren(inChildElm);
			}
		}
	},
	reload: function(inElement, inCallback, optUrl) {
		var elm = $(inElement);
		var inCallback = inCallback || Prototype.emptyFunction;
		if (!elm || !elm.id) { // bail if the element has no ID
			inCallback(false);
			return false;
		}
		// caller can pass in a custom URL... default just reloads the current location.
		var url = optUrl || (window.location.pathname + window.location.search);
		// load this document in an invisible iframe
		var reloadFrame = Builder.node('iframe', {
			name: 'element_reload_'+server().getNextUploadID(),
			style: 'position:absolute;top:0;left:0;width:1px;height:1px;visibility:hidden',
			// IE test
			// use this to debug
			//style: 'visibility:visible;width:200px;height:200px;position:absolute;top:0;left:0;z-index:5000',
			src: 'about:blank'
		});
		d.body.appendChild(reloadFrame);
		var frameWindow = reloadFrame.contentWindow;
		// maybeLoadedCallback -- outermost check, looks for a document and body for the newly added iframe
		// this is a workaround because onload doesn't work in this context
		var maybeLoadedCallback = function() {
			if (frameWindow.document && frameWindow.document.body) {
				// once we have a document and body, do a GET request for the page
				var req = new Ajax.Request(url, {method:'get', onSuccess:function(inTransport) {
					// grab the contents of the BODY tag
					var bodyTextMatch = inTransport.responseText.replace(/[\r\n]/gm, '').match(/<body[^>]*>(.+)<\/body>/);
					if (bodyTextMatch) {
						// populate the body of the iframe with the body tag contents
						frameWindow.document.body.innerHTML = bodyTextMatch[1];
						// now look for the element on this page
						var replacementElement = frameWindow.document.getElementById(elm.id);
						if (replacementElement) {
							elm.update(replacementElement.innerHTML);
							inCallback(true);
						}
						else {
							inCallback(false);
						}
					}
					else { // no body tag -- FAIL
						inCallback(false);
					}
					Element.remove(reloadFrame);
				}});
			}
			else {
				setTimeout(maybeLoadedCallback, 250);
			}
		}
		setTimeout(maybeLoadedCallback, 750);
	},
	enableLinkIfAvailable: function(inElement, inOptCallback) {
		// get the element and its href
		var elm = $(inElement);
		if (!elm) return;
		
		var availability_url = elm.getAttribute('name') || elm.getAttribute('href');
		if (availability_url)
		{
			var href = elm.getAttribute('href');
			// disable
			elm.addClassName('disabled');
			elm.setAttribute('href', '#');
			// now try to re-enable if it's reachable
			new Ajax.Request(availability_url, {
				method: (browser().isWebKit() ? 'get' : 'post'),
				onComplete: function(transport)
				{
					if (transport.status >= 200 && transport.status < 300)
					{
						elm.removeClassName('disabled');
						elm.setAttribute('href', href);
					}
					if (Object.isFunction(inOptCallback)) inOptCallback(elm);
				}
			});
		}
	},
	forceReflow: function(inElement) {
		var elm = $(inElement);
		if (elm && elm.style) {
			Element.hide(elm);
			setTimeout(function() {Element.show(elm)}, 1);
		}
	},
	formatElementDateContents: function(inElement, inOptIsGMT) {
		var elm = $(inElement);
		var d = createDateObjFromISO8601(Element.firstNodeValue(elm), inOptIsGMT);
		if (d) replaceElementContents(elm, Loc.getLongDateString(d));
	},
	// Returns the innerText/textContent of this element.
	textValue: function(inElement, inOptParent) {
		if (!inElement) return "";
		if (inElement.nodeType == 3) return inElement.nodeValue;
		return (inElement.textContent || inElement.innerText || "");
	},
	// Returns the outerHTML equivilant of this element.
	outerHtmlValue: function(inElement) {
		if (!inElement) return undefined;
		if (!('outerHTML' in document.documentElement)) {
			return $(inElement).outerHTML;
		} else {
			var temporaryParent = document.createElement('div');
			temporaryParent.appendChild(inElement.cloneNode(true));
			var _innerHTML = temporaryParent.innerHTML;
			temporaryParent = null;
			return _innerHTML;
		}
	}
});

function changeNodeName(inElement, inNodeName) {
	var elm = $(inElement);
	var node = elm.ownerDocument.createElement(inNodeName);
	$A(elm.childNodes).each(function(child) {
		elm.removeChild(child);
		node.appendChild(child);
	});
	elm.parentNode.insertBefore(node, elm);
	Element.remove(elm);
	return node;
};
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.

// Zero-pads a given number up to a supplied length (defaults to 3) and
// returns the result as a string, e.g. pad(13, 3) = "013". Handy for
// building random guids in fixture data.

var pad = function(x, length) {
	var val = "" + x;
	while (val.length < (length || 3)) {
		val = "0" + val;
	}
	return val;
}

// Builds a 36-character alphanumeric guid.

CC.GuidBuilder = Class.create({
	initialize: function() {
		var olderDate = new Date(1582, 10, 15, 0, 0, 0, 0);
		var now = new Date();
		var msec = now.valueOf() - olderDate.valueOf();
		var nic = pad(hex_hmac_md5(this.getShiftedBits(this.getRandomNumberInRange(0, 4095), 0, 16), location.href), 12).substring(0, 12);
		var uidArray = [
			this.getShiftedBits(msec, 0, 8),
			this.getShiftedBits(msec, 8, 12),
			this.getShiftedBits(msec, 12, 16),
			this.getShiftedBits(this.getRandomNumberInRange(0, 4095), 0, 2) + this.getShiftedBits(this.getRandomNumberInRange(0, 4095), 0, 2),
			nic
		];
		this.mStringValue = uidArray.join('-');
	},
	getRandomNumberInRange: function(inMin, inMax) {
		return Math.min(Math.max(Math.round((Math.random() * (inMin + inMax)) - inMin), inMin), inMax);
	},
	getShiftedBits: function(inValue, inStart, inEnd) {
		var base16str = pad(inValue.toString(16), inEnd);
		return base16str.substring(inStart, inEnd);
	},
	toString: function() {
		return this.mStringValue;
	}
});
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.

// Returns the current set of URL parameters in an Object keyed by parameter name.

CC.params = function(inOptHref) {
	var href = (inOptHref || window.location.href);
	var properties = href.slice(href.indexOf('?') + 1);
	return properties.toQueryParams();
};

// Caches so we don't recalculate URLs over and over.

var __urlTypeFragmentMap = {};
var __entityURLMap = {};
var __entityURLMapMinusTitles = {};

// Maps an entity type (e.g. com.apple.entity.Page) to a lowercase URL component (e.g. pages).

var urlTypeFragmentForEntityType = function(inEntityType) {
	var type = __urlTypeFragmentMap[inEntityType]
	if (!type) {
		var split = (inEntityType || "entities").split('.');
		var lastComponent = split[split.length - 1];
		type = lastComponent = lastComponent.toLowerCase();
		if (type != "entities") {
			var entityType = CC.meta('x-apple-entity-type');
			var isBlogPost = CC.meta('x-apple-entity-isBlogpost') == "true";
			var containerType = CC.meta('x-apple-container-type');
						
			// Pluralize and downcase the last component.
			type += "s";
			if (type == "users") {
				type = "people";
			}
			else if (type == 'wikis') {
				type = 'projects';
			}
			else if (type == 'blogs' && ((entityType == 'com.apple.entity.Page') || (entityType == 'com.apple.entity.File')) && isBlogPost) {
				type = urlTypeFragmentForEntityType(containerType);
			}
		}
		__urlTypeFragmentMap[inEntityType] = type;
	}
	return type;
};

CC.entityURL = function(inEntity, inOptShouldIncludeTitle) {
	var type = inEntity.type;
	var tinyID = inEntity.tinyID;
	var guid = inEntity.guid;
	var login = inEntity.shortName || inEntity.tinyID;
	if (!type || !(tinyID || guid || login)) return undefined;
	var id = (tinyID || guid);
	var subpath = "/wiki";
	type = urlTypeFragmentForEntityType(type);
	if (type == "people") {
		id = login;
	}
	var url = (inOptShouldIncludeTitle ? __entityURLMap[id] : __entityURLMapMinusTitles[id]);
	if (!url) {
		if (inOptShouldIncludeTitle) {
			var title = (inEntity.longName || inEntity.shortName || "Untitled");
			title = title.gsub(/[\s]+/, '_').gsub(/[^\w]+/, '')
			url = __entityURLMap[id] = "%@/%@/%@/%@.html".fmt(subpath, type, id, title);
		} else {
			url = __entityURLMapMinusTitles[id] = "%@/%@/%@".fmt(subpath, type, id);
		}
	}
	return url.escapeHTML();
};

CC.entityURLForTypeAndTinyID = function(inType, inTinyID, inOptTitle) {
	return CC.entityURL({
		'type': inType,
		'tinyID': inTinyID,
		'longName': inOptTitle
	}, (inOptTitle != undefined));
};

CC.entityURLForTypeAndGUID = function(inType, inGUID, inOptTitle) {
	return CC.entityURL({
		'type': inType,
		'guid': inGUID,
		'longName': inOptTitle
	}, (inOptTitle != undefined));
};

// Sniffs a route from the URL hash, expects http://...#route=/wiki/foo/bar.

CC.getRouteFromURLHash = function() {
	var hash = window.location.hash;
	if (hash) {
		var matches = hash.match(/route=(.*)$/);
		if (matches && matches.length && matches[1].startsWith("/")) {
			return matches[1];
		}
	}
};

// Sniffs a route from the URL itself, expects http://.../wiki/foo/bar.

CC.getRouteFromURL= function() {
	var search = window.location.search;
	var href = window.location.pathname + (search != "?" ? search : "");
	return href;
};
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.

CC.metaCache = {};
CC.Meta = {};
CC.Meta.NOTIFICATION_DID_REFRESH_META_TAGS = 'NOTIFICATION_DID_REFRESH_META_TAGS';

CC.meta = function(name, inOptForceRecalculate) {
	var cachedValue = CC.metaCache[name];
	if (cachedValue && !inOptForceRecalculate) return cachedValue;
	var node = $$('meta[name='+ name +']').first();
	var val = (node ? node.readAttribute('content') : '');
	CC.metaCache[name] = val;
	return val;
};

CC.metaAsArray = function(name, inOptForceRecalculate) {
	var meta = CC.meta(name, inOptForceRecalculate);
	var result = (meta || "").split(',');
	if (result && result.length == 1 && result[0] == "") return [];
	return result;
};

CC.setMeta = function(name, val) {
	CC.metaCache[name] = val;
	var node = $$('meta[name='+ name +']').first();
	if (node)
		node.writeAttribute('content', val);
	else
	{
		node = document.createElement('meta');
		node.writeAttribute('name', name);
		node.writeAttribute('content', val);
		document.head.appendChild(node);
	}
};

// Theme tag meta helpers.

CC.themeTupleFromMetaTag = function(inOptEntityOwnerOrContainerString) {
	var target = (inOptEntityOwnerOrContainerString || "container");
	var themeParts = new Array(3);
	var containerThemeInfo = (CC.meta("x-apple-%@-themeInfo".fmt(target)) || "");
	var splitContainerThemeInfo = containerThemeInfo.split(',');
	for (var sdx = 0; sdx < splitContainerThemeInfo.length; sdx++) {
		var t = splitContainerThemeInfo[sdx];
		if (t != undefined) {
			themeParts[sdx] = t.strip();
		}
	}
	return themeParts;
};

// Calendar meta helpers.

CC.calendarMetaTagsEnabledForContainer = function() {
	return (CC.meta("x-apple-container-isCalendarEnabled") == "true");
};

// Blog meta helpers.

CC.blogMetaTagsEnabledForContainer = function() {
	var isBlogEnabled = false;
	if (CC.meta('x-apple-owner-type') == 'com.apple.entity.User') {
		isBlogEnabled = (CC.meta("x-apple-owner-isBlogEnabled") == "true");
	}
	else {
		isBlogEnabled = (CC.meta("x-apple-container-isBlogEnabled") == "true");
	}
	return isBlogEnabled;
};
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.



CC.HiDPI = Class.createWithSharedInstance('hidpi', true);
CC.HiDPI.prototype = {
	initialize: function() {
		this.setDPIClassName();
	},
	isHiDPI: function() {
		if (!('devicePixelRatio' in window)) return false;
		if (('devicePixelRatio' in window) && window['devicePixelRatio'] == undefined) return false;
		return (window.devicePixelRatio >= 2);
	},
	setDPIClassName: function() {
		if (this.isHiDPI()) {
			document.body.addClassName('hidpi');
		} else {
			document.body.removeClassName('hidpi');
		}
	}
};
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.



CC.Browser = Class.createWithSharedInstance('browser');
CC.Browser.prototype = {
	initialize: function() {
		this.addBrowserVersionToBodyTag();
	},
	addBrowserVersionToBodyTag: function(name) {
		var matches;
		if (this.isiOS5Plus()) {
			this.addClassName('ios5plus');
		}
		if (this.isiOS6Plus()) {
			this.addClassName('ios6plus');
		}
		if (this.isiPhone()) {
			this.addClassName('iphone');
			return true;
		} else if (this.isiPod()) {
			this.addClassName('ipod');
			return true;
		} else if (this.isiPad()) {
			this.addClassName('ipad');
			return true;
		} else if (this.isSafari5Plus()) {
			this.addClassName('safari5plus');
			return true;
		} else if (matches = navigator.userAgent.match(/(Chrome|Firefox)\/([\d]+)/)) {
			if (matches && matches[1] != null && matches[2] != null) {
				var application = matches[1];
				var version = parseFloat(matches[2]);
				if (application == "Chrome" && version >= 11) {
					this.addClassName('chrome11plus');
					return true;
				} else if (application == "Firefox" && version >= 4) {
					this.addClassName('firefox4plus');
					return true;
				}
			}
		} else if (matches = navigator.userAgent.match(/MSIE ([\d]+)/)) {
			if (matches && matches[1] != null) {
				if (parseFloat(matches[1]) >= 9) {
					this.addClassName('ie9plus');
					return true;
				} else if (tridentMatches = navigator.userAgent.match(/Trident\/([\d]+)/)) {
					if (tridentMatches && tridentMatches[1] != null) {
						if (parseFloat(tridentMatches[1]) >= 5) {
							this.addClassName('ie9plus');
							return true;
						}
					}
				}
			}
		} else if (matches = navigator.userAgent.match(/Mozilla\/5.0 \(Windows NT/)) {
			if (matches && matches[0] != null) {
				this.addClassName('ie9plus');
				return true;
			}
		}
		this.addClassName('unsupported_browser');
		alert("_UnsupportedBrowser.Warning".loc());
		return false;
	},
	locale: function() {
		return (navigator.language ? navigator.language : navigator.browserLanguage || 'en').split('-')[0];
	},
	isIE: function() {
		return document.all && /MSIE/.test(navigator.userAgent);
	},
	isIE6: function() {
		return document.all && /MSIE 6/.test(navigator.userAgent);
	},
	isIE7: function() {
		return document.all && /MSIE 7/.test(navigator.userAgent);
	},
	isIE8: function() {
		return document.all && /MSIE 8/.test(navigator.userAgent);
	},
	isIE9: function() {
		return document.all && /MSIE 9/.test(navigator.userAgent);
	},
	isWebKit: function() {
		return /WebKit/.test(navigator.userAgent);
	},
	isSafari: function() {
		return /AppleWebKit\/.+Version/.test(navigator.userAgent);
	},
	isSafari4: function() {
		return /AppleWebKit\/.+Version\/4/.test(navigator.userAgent);
	},
	isSafari5: function() {
		return /AppleWebKit\/.+Version\/5/.test(navigator.userAgent);
	},
	isSafari6: function() {
		return /AppleWebKit\/.+Version\/6/.test(navigator.userAgent);
	},
	isSafari5Plus: function() {
		var matches = navigator.userAgent.match(/AppleWebKit\/.+Version\/([\d]+)/);
		if (matches && matches[1] != null) {
			if (parseFloat(matches[1]) >= 5) {
				return true
			}
		}
		return false;
	},
	isMobile: function() {
		return /Mobile/.test(navigator.userAgent);
	},
	isMobileSafari: function() {
		return / AppleWebKit\/.+Mobile\//.test(navigator.userAgent);
	},
	isiPad: function() {
		return this.isMobileSafari() && /iPad/.test(navigator.userAgent);
	},
	isiPhone: function() {
		return this.isMobileSafari() && /iPhone/.test(navigator.userAgent);
	},
	isiPod: function() {
		return this.isMobileSafari() && /iPod/.test(navigator.userAgent);
	},
	isiOS4Plus: function() {
		var matches = navigator.userAgent.match(/(iPhone|iPod|iPad|iPod touch); (U; )?(CPU|CPU [\w]*)? OS (\d)/);
		if (matches && matches.length > 0) {
			var version = parseFloat(matches[4]);
			if (version >= 4) {
				return true;
			}
		}
		return false;
	},
	isiOS5Plus: function() {
		var matches = navigator.userAgent.match(/(iPhone|iPod|iPad|iPod touch); (U; )?(CPU|CPU [\w]*)? OS (\d)/);
		if (matches && matches.length > 0) {
			var version = parseFloat(matches[4]);
			if (version >= 5) {
				return true;
			}
		}
		return false;
	},
	isiOS6Plus: function() {
		var matches = navigator.userAgent.match(/(iPhone|iPod|iPad|iPod touch); (U; )?(CPU|CPU [\w]*)? OS (\d)/);
		if (matches && matches.length > 0) {
			var version = parseFloat(matches[4]);
			if (version >= 6) {
				return true;
			}
		}
		return false;
	},
	isChrome: function() {
		return /Chrome/.test(navigator.userAgent);
	},
	isGecko: function() {
		return /Gecko\/\d*/.test(navigator.userAgent);
	},
	isFirefox: function() {
		return this.isGecko();
	},
	isCamino: function() {
		return /Gecko\/\d*.+Camino\/\d*/.test(navigator.userAgent);
	},
	isOpera: function() {
		return /Opera/.test(navigator.userAgent);
	},
	isMacintosh: function() {
		return /Macintosh/.test(navigator.userAgent);
	},
	isWindows: function() {
		return /Windows/.test(navigator.userAgent);
	},
	isLinux: function() {
		return /X11/.test(navigator.userAgent);
	},
	addClassName: function(inClassName) {
		if (browserSupportsModifyBodyClassName()) {
			document.body.addClassName(inClassName);
		}
	}
};

browser();
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.



// Prompt if cookies are disabled.

if (!navigator.cookieEnabled) {
	alert("_Cookies.NoCookiesUnsupported".loc());
}

// Global cookie accessor shared instance.

CC.CookieManager = Class.createWithSharedInstance('globalCookieManager', false);
CC.CookieManager.prototype = {
	initialize: function() {},
	// Writes a new key/value pair to the browser cookie. Accepts a cookie
	// name, value, and optional path, expiry and secure preferences.
	setCookie: function(inCookieKey, inCookieValue, inOptCookiePath, inOptCookieExpiry, inOptIsSecure) {
		if (!inCookieKey) return false;
		this.destroyCookie(inCookieKey, inOptCookiePath);
		var expire = inOptCookieExpiry;
		if (!expire) {
			var today = new Date();
			expire = new Date();
			expire.setTime(today.getTime() + 1000 * 60 * 60);
		}
		var cookieValue = (inCookieValue == undefined ? '' : inCookieValue);
		var cookie = inCookieKey + '=' + cookieValue + '; path=' + (inOptCookiePath || '/') + '; expires=' + expire.toGMTString() + ';' + (inOptIsSecure ? ' secure;' : '');
		document.cookie = cookie;
		return true;
	},
	// Returns the value of a supplied cookie key.
	getCookie: function(inCookieKey) {
		if (!inCookieKey) return undefined;
		var pattern = new RegExp(inCookieKey + '=([^;]+)');
		var value = document.cookie.match(pattern);
		if (value && value.length > 1) {
			return value[1];
		}
		return undefined;
	},
	// Destoys a cookie entry for a given key and optional path.
	destroyCookie: function(inCookieKey, inOptPath) {
		if (!inCookieKey) return;
		document.cookie = inCookieKey + '=; path=' + (inOptPath || '/') + '; expires=Thu, 01-Jan-1970 00:00:01 GMT;';
	}
};
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.



CC.Logger = CC.Logger || new Object();

CC.Logger.LOG_LEVEL_DEBUG = 'debug';
CC.Logger.LOG_LEVEL_INFO = 'info';
CC.Logger.LOG_LEVEL_WARN = 'warn';
CC.Logger.LOG_LEVEL_ERROR = 'error';
CC.Logger.LOG_LEVEL_NONE = 'none';
CC.Logger.LOG_ORDERING = [CC.Logger.LOG_LEVEL_NONE, CC.Logger.LOG_LEVEL_ERROR, CC.Logger.LOG_LEVEL_WARN, CC.Logger.LOG_LEVEL_INFO, CC.Logger.LOG_LEVEL_DEBUG];

CC.Logger.GlobalLoggerSharedInstance = Class.createWithSharedInstance('logger');
CC.Logger.GlobalLoggerSharedInstance.prototype = {
	mLogLevel: CC.Logger.LOG_LEVEL_INFO,
	initialize: function(/* [options] */) {
		if (arguments.length && arguments[0]) Object.extend(this, arguments[0]);
		// Use some bind magic for IE since console properties aren't true functions.
		if (document.all && /MSIE/.test(navigator.userAgent)) {
			if (!window.console) this.mLogLevel = CC.Logger.LOG_LEVEL_NONE;
			if (this.mLogLevel != CC.Logger.LOG_LEVEL_NONE && Function.prototype.bind && console && typeof console.log == "object") {
				$A(['log', 'info', 'warn', 'error']).each(function (method) {
					console[method] = this.bind(console[method], console);
			    }, Function.prototype.call);
			}
		}
		this.setLogLevel(this.mLogLevel);
	},
	setLogLevel: function(inLogLevel) {
		if (!inLogLevel) return false;
		if (!this._ensureLogging()) return;
		this.mLogLevel = CC.Logger.LOG_LEVEL_INFO;
		this.info("Logger initialized (log level: %o)", inLogLevel);
		this.mLogLevel = inLogLevel;
	},
	debug: function(inLogMessage /*, [args] */) {
		if (!this._ensureLogging()) return;
		if (!this._ensureLogLevel(CC.Logger.LOG_LEVEL_DEBUG)) return;
		console.log.apply(console, arguments);
	},
	info: function(inLogMessage /*, [args] */) {
		if (!this._ensureLogging()) return;
		if (!this._ensureLogLevel(CC.Logger.LOG_LEVEL_INFO)) return;
		console.info.apply(console, arguments);
	},
	warn: function(inLogMessage /*, [args] */) {
		if (!this._ensureLogging()) return;
		if (!this._ensureLogLevel(CC.Logger.LOG_LEVEL_WARN)) return;
		console.warn.apply(console, arguments);
	},
	error: function(inLogMessage /*, [args] */) {
		if (!this._ensureLogging()) return;
		if (!this._ensureLogLevel(CC.Logger.LOG_LEVEL_ERROR)) return;
		console.error.apply(console, arguments);
	},
	_ensureLogging: function() {
		return (this.mLogLevel != CC.Logger.LOG_LEVEL_NONE && console && console.log && console.info && console.warn && console.error);
	},
	_ensureLogLevel: function(inLogLevel) {
		var index = CC.Logger.LOG_ORDERING.indexOf(inLogLevel)
		if (index == -1) return false;
		return (index <= CC.Logger.LOG_ORDERING.indexOf(this.mLogLevel))
	}
};
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.

// Add inline notification support to functions as properties on an object.
// Signals this function as a responder to notifications with a given signature.
// By default, notifications are restricted to a CC.Object instance only. Passing
// inOptAnyInstance as true will register this observer for all notification
// broadcasts for a given signature, regardless of scope.

Function.prototype.observes = function(inNotificationSignature, inOptAnyInstance) {
	if (!inNotificationSignature || !globalNotificationCenter()) return this;
	if (!this._observers) this._observers = [];
	this._observers.push([inNotificationSignature, inOptAnyInstance]);
	return this;
};

// Base object class. Identical to the Prototype implementation of a class
// hierarchy, adding support for object/class type introspection (isClass and
// isObject). Also adds support for inline notification registration to any
// CC.Object property that is a function.

CC.Object = Class.create({
	isObject: true,
	initialize: function(/* [inOptAttributes] */) {
		if (arguments.length > 0 && arguments[0]) Object.extend(this, arguments[0]);
		// Initialize any notification observers for this class.
		for (key in this) {
			var value = this[key];
			if (value && (CC.typeOf(value) == CC.T_FUNCTION)) {
				if (value._observers) {
					var observers = value._observers, observerIdx, observer;
					for (observerIdx = 0; observerIdx < observers.length; observerIdx++) {
						observer = observers[observerIdx];
						globalNotificationCenter().subscribe(observer[0], value.bind(this), (observer[1] == true ? undefined : this));
					}
				}
			}
		}
	},
	kindOf: function(klass) {
		return this.constructor.kindOf(klass);
	}
});

var ClassProtocol = {
	isClass: true,
	kindOf: function(klass) {
		if (this == klass || this.constructor == klass || klass.subclasses.include(this)) return true;
		if (klass.subclasses.length == 0) return false;
		return klass.subclasses.any(function(k) {
			return this.kindOf(k);
		}, this);
	}
};

Object.extend(CC.Object, ClassProtocol);

// Wraps the prototype-default Class.create to support our ClassProtocol
// on the class instance it returns.

CC.Object._create = Class.create;
Class.create = function() {
	var klass = CC.Object._create.apply(this, arguments);
	Object.extend(klass, ClassProtocol);
	return klass;
};

// Global type constants.

Object.extend(CC, {
	T_ERROR: 'error', T_OBJECT: 'object', T_NULL: 'null', T_CLASS: 'class', T_HASH: 'hash', T_FUNCTION: 'function',
	T_UNDEFINED: 'undefined', T_NUMBER: 'number', T_BOOL: 'boolean', T_ARRAY: 'array', T_STRING: 'string',
	T_DATE: 'date', T_REGEXP: 'regexp'
});

// Returns the type of a supplied item as a type constant. Returns undefined
// where the supplied item is also undefined. Supports both CC.Object instances
// and prototype-style Class instances.

CC.typeOf = function(item) {
	if (item === undefined) return CC.T_UNDEFINED;
	if (item === null) return CC.T_NULL;
	var ret = typeof(item);
	if (ret == 'object') {
		if (item instanceof Array) {
			ret = CC.T_ARRAY;
		} else if (item instanceof Function) {
			ret = (item.isClass || item.addMethods) ? CC.T_CLASS : CC.T_FUNCTION;
		} else if (item instanceof Date) {
			ret = (item.isClass || item.addMethods) ? CC.T_CLASS : CC.T_DATE;
		} else if (item instanceof RegExp) {
			ret = (item.isClass || item.addMethods) ? CC.T_CLASS : CC.T_REGEXP;
		} else if (item.isObject || item.addMethods === undefined) {
			return CC.T_OBJECT;
		} else ret = CC.T_HASH;
	} else if (ret === CC.T_FUNCTION) {
		ret = (item.isClass || item.addMethods) ? CC.T_CLASS : CC.T_FUNCTION;
	}
	return ret;
};

// Utility method which returns true if an object is an instance of a supplied class
// or one of its subclasses, and false otherwise.

CC.kindOf = function(object, klass) {
	if (object && !object.isClass) object = object.constructor;
	return !!(object && object.kindOf && object.kindOf(klass));
};

// Traverses a property path returning an object instance where it exists.

CC.objectForPropertyPath = function(path, root, stopAt) {
	var loc, nextDotAt, key, max;
	if (!root) root = window;
	if (CC.typeOf(path) === CC.T_STRING) {
		if (stopAt === undefined) stopAt = path.length;
		loc = 0;
		while((root) && (loc < stopAt)) {
			nextDotAt = path.indexOf('.', loc) ;
			if ((nextDotAt < 0) || (nextDotAt > stopAt)) nextDotAt = stopAt;
			key = path.slice(loc, nextDotAt);
			root = root[key];
			loc = nextDotAt + 1;
		}
		if (loc < stopAt) root = undefined;
	}
	return root;
};

// Given a property path, returns a materialized object where the object at that
// path is a constructor, otherwise returns the object itself.

CC.objectInstanceForPropertyPath = function(path) {
	var obj = ((CC.typeOf(path) == CC.T_STRING) ? CC.objectForPropertyPath(path) : path);
	if (obj == undefined) return obj;
	return (CC.typeOf(obj) == CC.T_OBJECT) ? obj : new obj();
};

// Deep clones an object.

CC.deepClone = function(inObject) {
	if (CC.typeOf(inObject) != CC.T_OBJECT) return inObject;
	if (inObject == null) return inObject;
	var newObject = new Object();
	for (var key in inObject) newObject[key] = CC.deepClone(inObject[key]);
	return newObject;
};
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.





CC.Routes = CC.Routes || new Object();

// Built-in regexp patterns for default application routes.

CC.Routes.TrailingSlashOptionalQueryParam = "/?(\\\?[^\/]+)?";
CC.Routes.SLASH_ROUTE = "/" + CC.Routes.TrailingSlashOptionalQueryParam;
CC.Routes.WIKI_HOMEPAGE_ROUTE = "/wiki" + CC.Routes.TrailingSlashOptionalQueryParam;
CC.Routes.WIKI_ACTIVITY_ROUTE = "/wiki/activity" + CC.Routes.TrailingSlashOptionalQueryParam;
CC.Routes.WIKI_PROJECTS_ROUTE = "/wiki/projects" + CC.Routes.TrailingSlashOptionalQueryParam;
CC.Routes.WIKI_PEOPLE_ROUTE = "/wiki/people" + CC.Routes.TrailingSlashOptionalQueryParam;
CC.Routes.WIKI_TAGS_ROUTE = "/wiki/tags" + CC.Routes.TrailingSlashOptionalQueryParam;
CC.Routes.WIKI_MYPAGE_ROUTE = "/wiki/mypage" + CC.Routes.TrailingSlashOptionalQueryParam;
CC.Routes.WIKI_MYPAGE_ACTIVITY_ROUTE = "/wiki/mypage/activity" + CC.Routes.TrailingSlashOptionalQueryParam;
CC.Routes.WIKI_MYPAGE_DOCUMENTS_ROUTE = "/wiki/mypage/documents" + CC.Routes.TrailingSlashOptionalQueryParam;
CC.Routes.WIKI_MYPAGE_FAVORITES_ROUTE = "/wiki/mypage/favorites" + CC.Routes.TrailingSlashOptionalQueryParam;
CC.Routes.WIKI_PAGES_TINYID_ROUTE = "/wiki/pages/:tinyID" + CC.Routes.TrailingSlashOptionalQueryParam;
CC.Routes.WIKI_PAGES_TINYID_TITLE_ROUTE = "/wiki/pages/:tinyID/:title";
CC.Routes.WIKI_PAGES_TINYID_ROUTE = "/wiki/pages/:tinyID" + CC.Routes.TrailingSlashOptionalQueryParam;
CC.Routes.WIKI_PAGES_TINYID_TITLE_ROUTE = "/wiki/pages/:tinyID/:title";
CC.Routes.WIKI_FILES_TINYID_ROUTE = "/wiki/files/:tinyID" + CC.Routes.TrailingSlashOptionalQueryParam;
CC.Routes.WIKI_FILES_TINYID_TITLE_ROUTE = "/wiki/files/:tinyID/:title";
CC.Routes.WIKI_SEARCH_ROUTE = "/wiki/(search|find)/?:query";
CC.Routes.WIKI_CONTAINER_TINYID_ACTIVITY_ROUTE = "/wiki/:containerName/:tinyID/activity" + CC.Routes.TrailingSlashOptionalQueryParam;
CC.Routes.WIKI_CONTAINER_TINYID_DOCUMENTS_ROUTE = "/wiki/:containerName/:tinyID/documents" + CC.Routes.TrailingSlashOptionalQueryParam;
CC.Routes.WIKI_CONTAINER_TINYID_FAVORITES_ROUTE = "/wiki/:containerName/:tinyID/favorites" + CC.Routes.TrailingSlashOptionalQueryParam;
CC.Routes.WIKI_CONTAINER_TINYID_TAGS_ROUTE = "/wiki/:containerName/:tinyID/tags" + CC.Routes.TrailingSlashOptionalQueryParam;
CC.Routes.WIKI_CONTAINER_TINYID_BLOG_ROUTE = "/wiki/:containerName/:tinyID/blog" + CC.Routes.TrailingSlashOptionalQueryParam;
CC.Routes.WIKI_CONTAINER_TINYID_CALENDAR_ROUTE = "/wiki/:containerName/:tinyID/calendar" + CC.Routes.TrailingSlashOptionalQueryParam;
CC.Routes.WIKI_CONTAINER_TINYID_SETTINGS_ROUTE = "/wiki/:containerName/:tinyID/settings" + CC.Routes.TrailingSlashOptionalQueryParam;
CC.Routes.WIKI_CONTAINER_TINYID_ROUTE = "/wiki/:containerName/:tinyID" + CC.Routes.TrailingSlashOptionalQueryParam;
CC.Routes.WIKI_CONTAINER_TINYID_TITLE_ROUTE = "/wiki/:containerName/:tinyID/:title";

// Route notifications.

CC.Routes.NOTIFICATION_ROUTES_SHOULD_UPDATE = 'ROUTES_SHOULD_UPDATE';
CC.Routes.NOTIFICATION_ROUTE_DID_DISPATCH = 'ROUTE_DID_DISPATCH';
CC.Routes.NOTIFICATION_ROUTE_DID_COMPLETE = 'ROUTE_DID_COMPLETE';
CC.Routes.NOTIFICATION_ROUTE_DID_FAIL = 'ROUTE_DID_FAIL';

// Route constants.

CC.Routes.ROUTE_FAILED = 0;
CC.Routes.ROUTE_FIRED = 1;
CC.Routes.ROUTE_QUEUED = 2;
CC.Routes.ROUTE_IGNORED = 3;

// Base route class. A route is a combination of a route regex pattern and a callback function
// that fires when that route is matched.

CC.Routes.Route = Class.create(CC.Object, {
	mRegexPatternString: null,
	mCallback: null,
	initialize: function(/* [options] */) {
		if (arguments && arguments.length > 0) Object.extend(this, arguments[0]);
	},
	// Callback function that will fire when this route is activated. You will be passed a
	// CC.Routes.RouteInvocation instance.
	mCallback: function(inRouteInvocation) {
		window.location.url = inURL;
	}
});

// Route invocation class. Your route callback will be passed a route invocation when it fires.
// The global routes system only fires one route at a time. When your route fires, you can do
// whatever work you need to in your route callback function, but it is your responsibility to
// call routeDidComplete or routeDidFail to dequeue this route invocation from the global queue.

CC.Routes.RouteInvocation = Class.create(CC.Object, {
	// The URL that activated this route.
	url: null,
	// A hash of named regular expression matches (e.g. {tinyID: 'abc123', title: 'Title.html'}).
	namedMatches: null,
	// An array of all matches. 
	matches: null,
	// Callback function for this route.
	callback: null,
	// Should this route alter the URL hash?
	setURLHash: false,
	// Should we push a URL state for this route?
	pushURLState: false,
	// Window title for this route.
	windowTitle: "",
	// State.
	_completed: false,
	_failed: false,
	routeDidComplete: function() {
		this._completed = true;
		globalNotificationCenter().publish(CC.Routes.NOTIFICATION_ROUTE_DID_COMPLETE, this);
	},
	routeDidFail: function() {
		this._failed = true;
		globalNotificationCenter().publish(CC.Routes.NOTIFICATION_ROUTE_DID_FAIL, this);
	}
});

// A wrapper around an array that behaves as a stack.

CC.Routes.RouteHistoryStack = Class.create({
	initialize: function() {
		this.flush();
	},
	stack: function() {
		return this._stack;
	},
	// Pushes a new route on to the stack returning true where the route was added successfully.
	pushRoute: function(inRoute) {
		if (inRoute) {
			this._stack.push(inRoute);
			return true;
		}
		return false;
	},
	// Pops the least recent route from the stack and returns it.
	popLeastRecentRoute: function() {
		return this._stack.shift();
	},
	// Pops the most recent route from the stack and returns it.
	popMostRecentRoute: function() {
		return this._stack.pop();
	},
	flush: function() {
		this._stack = new Array();
	},
	isFirstLoad: function(){
		var stack = this.stack();
		if (stack.length > 1) {
			return true;
		}
		else {
			return false;
		}
	}
});

// Route handling.

CC.Routes.GlobalRouteHandler = Class.createWithSharedInstance('globalRouteHandler');
CC.Routes.GlobalRouteHandler.prototype = {
	// An array of (compiledRegex, groupingNames, callback) tuples for each registered route.
	mRegisteredRoutes: new Array(),
	// Global route queue.  Routes are dispatched from this queue in order, one at a time.
	mGlobalRouteQueue: new Array(),
	// The currently active route.
	mCurrentRoute: null,
	// Route history stack.  When a route is fired, the invocation is automatically pushed onto the route history stack.
	mRouteStack: new CC.Routes.RouteHistoryStack(),
	// The current prefire callback function.
	mRoutePrefireCallback: null,
	// Does firing a route trigger a page redirect to the route url?
	mRoutesTriggerReload: false,
	// Should we set the URL hash by default?
	mDefaultRoutesSetURLHash: false,
	// Should we push URL state by default?
	mDefaultRoutesPushURLState: false,
	// Should we route ALL links (regardless of their cc-routable status)?
	mRouteAllLinks: false,
	// The CSS selector that determines which elements should be routeable.
	mRouteSelectorPattern: '*.cc-routable:not(.cc-route-enabled)',
	initialize: function() {
		globalNotificationCenter().subscribe(CC.Routes.NOTIFICATION_ROUTES_SHOULD_UPDATE, this.handleRoutesShouldUpdateNotification.bind(this));
		globalNotificationCenter().subscribe(CC.Routes.NOTIFICATION_ROUTE_DID_COMPLETE, this.handleRouteStatusNotification.bind(this));
		globalNotificationCenter().subscribe(CC.Routes.NOTIFICATION_ROUTE_DID_FAIL, this.handleRouteStatusNotification.bind(this));
		window.onpopstate = this.handlePopStateEvent.bind(this);
	},
	// Registers an arbitrary pattern string and callback function.
	register: function(inRegexPatternString, inCallback) {
		var route = new CC.Routes.Route({
			'mRegexPatternString': inRegexPatternString,
			'mCallback': inCallback
		});
		this.registerRoute(route);
	},
	// Registers a new CC.Routes.Route handler.
	registerRoute: function(inRoute) {
		if (!CC.kindOf(inRoute, CC.Routes.Route)) logger().error("Tried to register something other than a CC.Routes.Route as a route handler");
		var patternString = inRoute.mRegexPatternString, callback = inRoute.mCallback;
		// Compile the regex for this route, and keep track of the named groupings.
		var namedParamMatchesRegex = /(:[A-Za-z0-9-_]+)/g;
		var namedParamMatches = patternString.match(namedParamMatchesRegex);
		var replacedPatternString = patternString.replace(namedParamMatchesRegex, "([^\/]+)");
		replacedPatternString = "^" + replacedPatternString.replace(/\//g, "\\/") + "$";
		// Drop the ":" off the front of each grouping name.
		var groupingNames = [];
		if (namedParamMatches) {
			for (var idx = 0; idx < namedParamMatches.length; idx++) {
				var param = namedParamMatches[idx];
				groupingNames.push(param.substring(1, param.length));
			}
		}
		// Push this registered route in reverse-registered order so routes registered later have the opportunity
		// to override default routes.
		this.mRegisteredRoutes.unshift([replacedPatternString, groupingNames, inRoute.mCallback, patternString]);
		logger().debug("Registered new route (%@, %@, %@)", replacedPatternString, groupingNames, inRoute.mCallback);
	},
	// Evaluates a URL against all registered route handlers (in the order in which they were registered). Instantiates
	// a route invocation for the first matching route, and pushes it on to the global route dispatch queue.
	__evaluateURL: function(inURLString) {
		if (!inURLString) return false;
		var routes = this.mRegisteredRoutes, route, regexp, namedGroupings, namedGrouping, callback, originalRoutePattern, matches, namedMatches;
		for (var rdx = 0; rdx < routes.length; rdx++) {
			route = routes[rdx];
			regexp = route[0], namedGroupings = route[1], callback = route[2], originalRoutePattern = route[3], matches, namedMatches = {};
			// Evaluate the URL against the compiled regular expression for this route.
			matches = inURLString.match(regexp);
			if (matches && matches.length) {
				// We got a match, do we have any named groupings?
				if (namedGroupings && namedGroupings.length) {
					for (gdx = 0; gdx < namedGroupings.length; gdx++) {
						namedGrouping = namedGroupings[gdx];
						if (namedGrouping) namedMatches[namedGrouping] = matches[gdx + 1].escapeHTML();
					}
				}
				
				if (namedMatches['containerName'] && namedMatches['containerName'] != 'projects' && namedMatches['containerName'] != 'people' && namedMatches['containerName'] != 'mypage') {
					logger().warn("Failed to find matching route for URL (%@) with container name (%@)".fmt(inURLString, namedMatches['containerName']));
					return false;
				}
				
				// Return a tuple of callback, url, hash of named matches and array of original matches for the regex.
				logger().debug("Found matching route for URL (%@, %@, %@, %@)".fmt(inURLString, namedMatches, matches, callback));
				return [callback, inURLString, namedMatches, matches, originalRoutePattern];
			} else {
				continue;
			}
		}
		logger().warn("Failed to find matching route for URL (%@)".fmt(inURLString));
		return false;
	},
	// Internal method that dispatches the next route in the global route queue. You should not call manually.
	__dispatchRoute: function(inRouteInvocation) {
		if (!inRouteInvocation || !inRouteInvocation.url) return CC.Routes.ROUTE_FAILED;
		var url = inRouteInvocation.url;
		// Do we have a queued identical route? Routes are deemed to be identical if their URLs are identical.
		var queue = this.mGlobalRouteQueue, queueItem;
		if (queue.length) {
			for (var idx = (queue.length - 1); idx >= 0; idx--) {
				queueItem = queue[idx];
				if (queueItem && queueItem.url == url) {
					logger().info("Ignoring route because an identical route is already queued (%@)".fmt(url));
					return CC.Routes.ROUTE_IGNORED;
				}
			}
		}
		// Do we have a route in progress that is identical?
		if (this.mCurrentRoute && (this.mCurrentRoute.url == url)) {
			logger().info("Ignoring route because it has a url that is identical to the last route (%@)".fmt(url));
			return CC.Routes.ROUTE_IGNORED;
		}
		// Push this route invocation onto the queue.
		this.mGlobalRouteQueue.push(inRouteInvocation);
		// Immediately dispatch if we don't have an active route already.
		if (!this.mCurrentRoute) this.__dispatchNextRoute();
	},
	__dispatchNextRoute: function() {
		delete this.mCurrentRoute;
		if (this.mGlobalRouteQueue.length > 0) {
			var queued = false;
			if (this.mGlobalRouteQueue.length != 1) queued = true;
			// Grab the next route invocation in the dispatch queue.
			var nextRoute = this.mGlobalRouteQueue.shift();
			if (nextRoute && nextRoute.callback) {
				this.mCurrentRoute = nextRoute;
				var cb = nextRoute.callback;
				cb(nextRoute);
				globalNotificationCenter().publish(CC.Routes.NOTIFICATION_ROUTE_DID_DISPATCH, nextRoute);
				// Push the route we just fired onto the route stack.
				this.mRouteStack.pushRoute(nextRoute);
				return (queued ? CC.Routes.ROUTE_QUEUED : CC.Routes.ROUTE_FIRED);
			} else {
				this.__dispatchNextRoute();
			}
		}
	},
	// Enables a route for every link tag or element with a cc-routable class name element on the page.
	handleRoutesShouldUpdateNotification: function(inMessage, inObject, inOptExtras) {
		var bound = this.routeEvent.bindAsEventListener(this);
		var routables = [], routable;
		var selector = (this.mRouteAllLinks ? 'a, ' + this.mRouteSelectorPattern : this.mRouteSelectorPattern);
		// Did we get passed an explicit root element?
		if (inOptExtras && inOptExtras.rootElement) {
			routables = $(inOptExtras.rootElement).select(selector);
		} else {
			routables = $$(selector);
		}
		for (var idx = 0; idx < routables.length; idx++) {
			routable = routables[idx];
			Event.observe(routable, 'click', bound, false);
			Element.addClassName(routable, 'cc-route-enabled');
		}
	},
	// Route status changed notification handler.
	handleRouteStatusNotification: function(inMessage, inObject, inOptExtras) {
		var didComplete = (inMessage == CC.Routes.NOTIFICATION_ROUTE_DID_COMPLETE);
		didComplete ? logger().debug("Route completed:", inObject) : logger().error("Route failed:", inObject);
		if (inObject == this.mCurrentRoute) {
			// Set the URL hash if we need to.
			var setHash = (inObject.setURLHash || this.mDefaultRoutesSetURLHash);
			if (didComplete && setHash) window.location.hash = "route=%@".fmt(inObject.url);
			// Push the URL state if we need to.
			var shouldPushURLState = (inObject.pushURLState || this.mDefaultRoutesPushURLState);
			if (didComplete && shouldPushURLState) {
				if (history.pushState) {
					history.pushState({}, (inObject.windowTitle || ""), inObject.url);
				}
				else {
					window.location = inObject.url;
				}
			}
			this.__dispatchNextRoute();
		} else {
			logger().debug("Got a route notification for a route other than the active route, ignoring");
		}
	},
	handlePopStateEvent: function(inEvent) {
		if (this.mRouteStack.isFirstLoad()) {
			this.routeURL(window.location.pathname, undefined, true, false, false, document.title);
		}
	},
	// Default callback for all routed elements which evaluates a URL to a routing tuple and fires a registered
	// callback where it exists. Otherwise the event proceeds as normal.
	routeEvent: function(inEvent) {
		var elem = Event.findElement(inEvent, '.cc-route-enabled');
		if (elem) {
			// Grab the URL by looking at a data-route-href attribute first, and an href second.
			var href = elem.getAttribute('data-route-href') || elem.getAttribute('href');
			if (href) {
				return this.routeURL(href, inEvent);
			}
		}
		return false;
	},
	routeURL: function(inURL, inOptSourceEvent, inOptRedirectOverrideFlag, inOptSetURLHash, inOptPushURLState, inOptWindowTitle) {
		// Do we have a prefire callback?  If we do, check if we should even process this route.
		if (this.mRoutePrefireCallback) {
			var _callback = this.mRoutePrefireCallback;
			var shouldProceed = _callback();
			if (!shouldProceed) return true;
		}
		var routeTuple = this.__evaluateURL(inURL);
		var routeInvocation;
		if (routeTuple && routeTuple.length) {
			// Do routes trigger a page reload?  Only redirect if the override flag has not been passed.
			if (this.mRoutesTriggerReload && !inOptRedirectOverrideFlag) {
				window.location.href = inURL;
				return true;
			}
			// Stop the event since we're about to handle it.
			if (inOptSourceEvent) Event.stop(inOptSourceEvent);
			var callback = routeTuple[0], url = routeTuple[1], namedMatches = routeTuple[2], matches = routeTuple[3], originalRoutePattern = routeTuple[4];
			// Initialize a route invocation.
			var invocationHash = {
				'callback': (callback || Prototype.emptyFunction),
				'url': (url || ""),
				'namedMatches': (namedMatches || {}),
				'matches': (matches || []),
				'originalRoutePattern': originalRoutePattern
			};
			if (inOptSetURLHash !== undefined) invocationHash['setURLHash'] = (inOptSetURLHash == true);
			if (inOptPushURLState !== undefined) invocationHash['pushURLState'] = (inOptPushURLState == true);
			if (inOptWindowTitle) invocationHash['windowTitle'] = inOptWindowTitle;
			routeInvocation = new CC.Routes.RouteInvocation(invocationHash);
			// Dispatch it.
			this.__dispatchRoute(routeInvocation);
			return true;
		}
		logger().debug("Got an empty route tuple after evaluating URL (%@)", inURL);
		return false;
	},
	// Registers a callback function that fires before any route is fired similar to the window onunload event
	// that fires when the user tries to click away from the active window.  Useful for mimicing the same
	// behavior where routes are in use but the window is not reloading.  If you return true the route will fire,
	// otherwise the route will be cancelled.
	setRoutePrefireCallback: function(inCallback) {
		if (!inCallback) {
			logger().warn("Called setRoutePrefireCallback without passing a valid callback (%@) ... current callback will be cleared", inCallback);
			this.mRoutePrefireCallback = null;
		} else {
			logger().debug("Set a new prefire callback (%@) in globalRouteHandler", inCallback);
			this.mRoutePrefireCallback = inCallback;
		}
	}
};
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.




CC.Mvc = CC.Mvc || new Object();
CC.Mvc.Mixins = CC.Mvc.Mixins || new Object();
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.




// Base model class.

CC.Mvc.Model = Class.create(CC.Object, {
	// Walk like a model.
	isModel: true,
	// The type of this model.
	type: 'com.apple.Model',
	// A unique identifer for this model.
	guid: null,
	// Serializes this model to a JSON hash.
	serialize: function() {
		return {'type': this.type, 'guid': this.guid};
	}
});

// Mixin for a change-aware model; one that we can build changesets for.

CC.Mvc.Mixins.ChangeAware = {
	// Walk like a channge-aware duck.
	isChangeAware: true,
	// An array of attributes of this model to be considered when
	// building a changeset.
	mChangesetAttributes: [],
	// Private function returning a list of changeset attributes.
	// Do not override.
	_changesetAttributes: 'guid type'.w(),
	_cachedChangesetAttributes: null,
	changesetAttributes: function(inOptForceRecalculate) {
		if (!this._cachedChangesetAttributes || inOptForceRecalculate) {
			this._cachedChangesetAttributes = this.mChangesetAttributes ? this._changesetAttributes.concat(this.mChangesetAttributes) : this._changesetAttributes;
		}
		return this._cachedChangesetAttributes;
	},
	// Override serialize to return a simple object representation of this model
	// including changeset-aware attributes.
	serialize: function($super) {
		var serialized = new Object(), attrs = this.changesetAttributes(), attr;
		for (var attrIdx = 0; attrIdx < attrs.length; attrIdx++) {
			attr = attrs[attrIdx];
			serialized[attr] = this[attr];
		}
		serialized['type'] = this.type;
		serialized['guid'] = this.guid;
		return serialized;
	}
};
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.


CC.EntityMixins = CC.EntityMixins || new Object();

// Container with comments mixin, e.g. a project or a blog.

CC.EntityMixins.COMMENT_ACCESS_DISABLED = 'disabled';
CC.EntityMixins.COMMENT_ACCESS_ALL = 'all';
CC.EntityMixins.COMMENT_ACCESS_AUTHENTICATED = 'authenticated';
CC.EntityMixins.COMMENT_ACCESS_DEFAULT = CC.EntityMixins.COMMENT_ACCESS_AUTHENTICATED;
CC.EntityMixins.COMMENT_ACCESS_ALLOWED_VALUES = [
	CC.EntityMixins.COMMENT_ACCESS_DISABLED,
	CC.EntityMixins.COMMENT_ACCESS_ALL,
	CC.EntityMixins.COMMENT_ACCESS_AUTHENTICATED
];

CC.EntityMixins.COMMENT_MODERATION_DISABLED = 'disabled';
CC.EntityMixins.COMMENT_MODERATION_ALL = 'all';
CC.EntityMixins.COMMENT_MODERATION_ANONYMOUS = 'anonymous';
CC.EntityMixins.COMMENT_MODERATION_DEFAULT = CC.EntityMixins.COMMENT_MODERATION_DISABLED;
CC.EntityMixins.COMMENT_MODERATION_ALLOWED_VALUES = [
	CC.EntityMixins.COMMENT_MODERATION_DISABLED,
	CC.EntityMixins.COMMENT_MODERATION_ALL,
	CC.EntityMixins.COMMENT_MODERATION_ANONYMOUS
];

CC.EntityMixins.ContainerWithComments = {
	getCommentAccessLevel: function() {
		var xattrs = (this.extendedAttributes || {});
		var settings = (xattrs['settings'] || {});
		return settings['comments'];
	},
	setCommentAccessLevel: function(inLevel) {
		if (CC.EntityMixins.COMMENT_ACCESS_ALLOWED_VALUES.include(inLevel)) {
			if (!this.extendedAttributes) this.extendedAttributes = {};
			if (!this.extendedAttributes.settings) this.extendedAttributes.settings = {};
			this.extendedAttributes.settings.comments = inLevel;
		}
		return false;
	},
	getCommentModerationLevel: function() {
		var xattrs = (this.extendedAttributes || {});
		var settings = (xattrs['settings'] || {});
		return settings['commentModeration'];
	},
	setCommentModerationLevel: function(inLevel) {
		if (CC.EntityMixins.COMMENT_MODERATION_ALLOWED_VALUES.include(inLevel)) {
			if (!this.extendedAttributes) this.extendedAttributes = {};
			if (!this.extendedAttributes.settings) this.extendedAttributes.settings = {};
			this.extendedAttributes.settings.commentModeration = inLevel;
		}
		return false;
	}
};
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
//
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.





CC.EntityTypes = CC.EntityTypes || new Object();

// Sessions (read-only).

CC.EntityTypes.Session = Class.create(CC.Mvc.Model, {
	type: 'com.apple.Session',
	user: null,
	authToken: null,
	createTime: null,
	updateTime: null,
	data: null
});

CC.EntityTypes.DateTime = Class.create(CC.Mvc.Model, {
	type: 'com.apple.DateTime',
	epochValue: 0,
	isoValue:"",
	initialize: function(inDate) {
		// given the string, get epoch
		this.isoValue = inDate.toISOString();
		this.epochValue = inDate.getTime() / 1000;
	}
});

// Entity (changeset-aware).

CC.EntityTypes.BaseEntity = Class.create(CC.Mvc.Model, CC.Mvc.Mixins.ChangeAware, {
	_type: 'com.apple.Entity',
	mChangesetAttributes: [],
	initialize: function($super) {
		$super.apply(null, Array.prototype.slice.call(arguments, 1));
		this.type = this._type;
		if (!this.guid) {
			var generator = new CC.GuidBuilder();
			this.guid = generator.toString();
		}
	}
});

CC.EntityTypes.WikiEntity = Class.create(CC.EntityTypes.BaseEntity, CC.EntityMixins.ContainerWithComments, {
	_type: 'com.apple.entity.Wiki',
	mChangesetAttributes: 'description extendedAttributes longName themeInfo detailPageGUID blogGUID'.w()
});

CC.EntityTypes.UserEntity = Class.create(CC.EntityTypes.BaseEntity, {
	_type: 'com.apple.entity.User',
	mChangesetAttributes: 'privateAttributes extendedAttributes longName themeInfo detailPageGUID blogGUID preferredEmailHash'.w()
});

CC.EntityTypes.BlogEntity = Class.create(CC.EntityTypes.BaseEntity, CC.EntityMixins.ContainerWithComments, {
	_type: 'com.apple.entity.Blog',
	mChangesetAttributes: 'extendedAttributes longName'.w()
});

CC.EntityTypes.PageEntity = Class.create(CC.EntityTypes.BaseEntity, {
	_type: 'com.apple.entity.Page',
	mChangesetAttributes: 'extendedAttributes longName'.w()
});

CC.EntityTypes.FileEntity = Class.create(CC.EntityTypes.BaseEntity, {
	_type: 'com.apple.entity.File',
	mChangesetAttributes: 'extendedAttributes longName'.w()
});

CC.EntityTypes.FileDataEntity = Class.create(CC.EntityTypes.BaseEntity, {
	_type: 'com.apple.entity.FileData'
});

CC.EntityTypes.EntityACL = Class.create(CC.Mvc.Model, {
	_type: 'com.apple.EntityACL',
	allow: true,
	action: 'none',
	userExternalID: null,
	userLogin: null,
	userLongName: null,
	initialize: function($super) {
		$super.apply(null, Array.prototype.slice.call(arguments, 1));
		this.type = this._type;
	}
});

// Activity (read-only).

CC.EntityTypes.UserActivity = Class.create(CC.Mvc.Model, {
	type: 'com.apple.UserActivity',
	// Synthesize a guid property so we can stash activity objects in the store.
	guid: null,
	// Model attributes.
	userGUID: null,
	action: null,
	entityGUID: null,
	entityRevision: null,
	data: null,
	actionTime: null,
	containerGUID: null,
	ownerGUID: null,
	subFields: null,
	isUnread: null,
	isFavorite: null,
	initialize: function($super) {
		$super.apply(null, Array.prototype.slice.call(arguments, 1));
		// Synthesize a guid for this model by hashing the userGUID, entityGUID, action and actionTime together.
		this.guid = "%@-%@-%@-%@".fmt(this.userGUID, this.entityGUID, this.action, (this.actionTime.getTime() / 1000));
	}
});

// Search.

CC.EntityTypes.SearchResult = Class.create(CC.Mvc.Model, {
	type: 'com.apple.SearchResult',
	guid: null,
	results: []
});

CC.EntityTypes.SavedQuery = Class.create(CC.Mvc.Model, {
	_type: 'com.apple.entity.SavedQuery',
	guid: null,
	longName: "Untitled Search",
	query: {},
	initialize: function($super) {
		this.type = 'com.apple.entity.SavedQuery',
		$super.apply(null, Array.prototype.slice.call(arguments, 1));
	}
});

// Related entity.

CC.EntityTypes.RelatedRelationship = Class.create(CC.Mvc.Model, {
	type: 'com.apple.relationship.Related',
	guid: null,
	targetEntityGUID: null,
	sourceEntityGUID: null
});

// Entity changeset.

CC.EntityTypes.EntityChangeSet = Class.create(CC.Object, {
	changeGUID: null,
	changeAction: null,
	changeType: null,
	entityGUID: null,
	entityRevision: null,
	entityType: null,
	changeComment: null,
	changeUserGUID: null,
	changeUserLogin: null,
	force: false,
	changes: null,
	initialize: function($super) {
		this.type = "com.apple.EntityChangeSet";
		this.changes = [];
		$super.apply(null, Array.prototype.slice.call(arguments, 1));
	}
});

// Service request/response classes.

CC.EntityTypes.ServiceRequest = Class.create(CC.Object, {
	adminAuthorizationRef: null,
	sessionGUID: null,
	serviceName: null,
	methodName: null,
	arguments: null,
	expandReferencedObjects: null,
	subpropertyPaths: null,
	referencedPathsToFollow: null,
	clientURL: undefined,
	hints: null,
	initialize: function($super) {
		this.type = "com.apple.ServiceRequest";
		this.arguments = [];
		$super.apply(null, Array.prototype.slice.call(arguments, 1));
	}
});

CC.EntityTypes.ServiceResponse = Class.create(CC.Object, {
	succeeded: false,
	response: null,
	responseStatus: null,
	referencedObjects: null
});

CC.EntityTypes.BatchServiceRequest = Class.create(CC.Object, {
	requests: null,
	initialize: function($super) {
		this.type = "com.apple.BatchServiceRequest";
		this.requests = [];
		$super.apply(null, Array.prototype.slice.call(arguments, 1));
	}
});

CC.EntityTypes.BatchServiceResponse = Class.create(CC.Object, {
	responses: null
});

CC.EntityTypes.PaginationRequest = Class.create(CC.Object, {
	serviceRequest: null,
	guid: null,
	startIndex: null,
	resultsLimit: null,
	initialize: function($super) {
		this.type = "com.apple.PaginationRequest"
		$super.apply(null, Array.prototype.slice.call(arguments, 1));
	}
});

CC.EntityTypes.PaginatedResult = Class.create(CC.Object, {
	guid: null,
	startIndex: null,
	results: null,
	total: null,
	initialize: function($super) {
		this.type = "com.apple.PaginatedResult",
		this.results = [];
		$super.apply(null, Array.prototype.slice.call(arguments, 1));
	}
});

// Entity types global.

CC.EntityTypes.SharedInstance = Class.createWithSharedInstance('entity_types');
CC.EntityTypes.SharedInstance.prototype = {
	initialize: function() {},
	typeMap: {
		'com.apple.entity.Wiki': CC.EntityTypes.WikiEntity,
		'com.apple.entity.Page': CC.EntityTypes.PageEntity,
		'com.apple.entity.User': CC.EntityTypes.UserEntity,
		'com.apple.entity.Blog': CC.EntityTypes.BlogEntity,
		'com.apple.entity.File': CC.EntityTypes.FileEntity,
		'com.apple.entity.FileData': CC.EntityTypes.FileDataEntity,
		'com.apple.entity.EntityACL': CC.EntityTypes.EntityACL,
		'com.apple.UserActivity': CC.EntityTypes.UserActivity,
		'com.apple.SearchResult': CC.EntityTypes.SearchResult,
		'com.apple.entity.SavedQuery': CC.EntityTypes.SavedQuery,
		'com.apple.RelatedRelationship': CC.EntityTypes.RelatedRelationship,
		'com.apple.entity.Bot': CC.EntityTypes.BotEntity,
		'com.apple.entity.BotRun': CC.EntityTypes.BotRunEntity,
		'com.apple.entity.SCMCommit': CC.EntityTypes.SCMCommitEntity,
		'com.apple.XCWorkSchedule': CC.EntityTypes.XCWorkSchedule,
		'com.apple.XCWorkScheduleRecurrence': CC.EntityTypes.XCWorkScheduleRecurrence
	},
	prototypeForTypeName: function(inName) {
	    var val = this.typeMap[inName];
	    if (!val) val = CC.EntityTypes.BaseEntity;
		return val;
	},
	entityForHash: function(inHash) {
		var proto = this.prototypeForTypeName(inHash['type']);
		return new proto(inHash);
	}
};

// Returns a localized container string.  E.g. in Andrew's Documents, in Example Wiki.

var localizedContainerString = function(inContainerName, inContainerType) {
	var localized = "";
	if (!inContainerName || !inContainerType) return localized;
	if (inContainerType == "com.apple.entity.User") {
		localized = "_General.Container.Subtitle.User".loc(inContainerName);
	} else if (inContainerType == "com.apple.entity.Blog") {
		localized = "_General.Container.Subtitle.Blog".loc(inContainerName);
	} else if (inContainerType == "com.apple.entity.Wiki") {
		localized = "_General.Container.Subtitle.Wiki".loc(inContainerName);
	}
	return localized;
};

// Returns an avatar icon for a given entity.  Accepts an optional inOptIgnoreAvatarsAndPreviews argument
// which when passed as true, always returns a generic CoreClientBase icon.  Accepts optional width and
// height parameters, and a HIDPI flag.

var iconURIForEntity = function(inEntity, inOptReturnGenericIconsOnly, inOptTargetWidth, inOptTargetHeight, inOptHIDPI) {
	var sizeString = "32x32";
	var hidpi = (inOptHIDPI != undefined ? inOptHIDPI : (window.devicePixelRatio >= 2));
	if (inOptTargetWidth || inOptTargetHeight) {
		sizeString = "%@x%@".fmt(inOptTargetWidth, inOptTargetHeight);
	}
	// Build the iconURI first using the size.
	var iconURI = "/__collabd/coreclientbase/stylesheets/cc/img/document_%@".fmt(sizeString);
	if (inEntity.type == "com.apple.entity.Wiki" || inEntity.type == "com.apple.entity.User") {
		// Do we have a direct avatar? Otherwise fall back on a default.
		if (inEntity.avatarGUID && !inOptReturnGenericIconsOnly) {
			return "%@/files/download/%@".fmt(env().root_path, inEntity.avatarGUID);
		} else {
			if (inEntity.type == "com.apple.entity.Wiki") {
				iconURI = "/__collabd/coreclientbase/stylesheets/cc/img/wiki_%@".fmt(sizeString);
			} else if (inEntity.type == "com.apple.entity.User") {
				iconURI = "/__collabd/coreclientbase/stylesheets/cc/img/user_%@".fmt(sizeString);
			}
		}
	}
	if (inEntity.type == "com.apple.entity.Page" || inEntity.type == "com.apple.entity.File") {
		var guid = (inEntity.avatarGUID || inEntity.iconGUID);
		if (!inOptReturnGenericIconsOnly && guid) {
			return '%@/files/download/%@'.fmt(env().root_path, guid);
		} else {
			if (inEntity.type == "com.apple.entity.Page") {
				iconURI = "/__collabd/coreclientbase/stylesheets/cc/img/page_%@".fmt(sizeString);
			} else if (inEntity.type == "com.apple.entity.File") {
				iconURI = "/__collabd/coreclientbase/stylesheets/cc/img/file_%@".fmt(sizeString);
			}
		}
	}
	if (inEntity.type == "com.apple.entity.Bot") {
		iconURI = "/__collabd/coreclientbase/stylesheets/cc/img/bot_%@".fmt(sizeString);
	}
	if (hidpi) iconURI += "@2x";
	iconURI += ".png";
	return iconURI;
};

var iconURIForEntityType = function(inEntityType, inOptTargetWidth, inOptTargetHeight, inOptHIDPI) {
	var fakeEntity = {type: (inEntityType || 'com.apple.Entity')};
	return iconURIForEntity(fakeEntity, true, inOptTargetWidth, inOptTargetHeight, inOptHIDPI);
};

var getOwnerGuidFromEntityParentGuids = function(inEntity, inLevel) {
	if ( inLevel && inLevel > 0) {
		return ((inEntity.parentGUIDs.length-(inLevel+1) > 0) ? inEntity.parentGUIDs[inEntity.parentGUIDs.length -(inLevel+1)] : '');
	}
	else {
		return inEntity.ownerGUID;
	}
}
;
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.





CC.ServiceClient = CC.ServiceClient || new Object();

// Simple JSON encoder/decoder classes.

CC.ServiceClient.JSONEncoder = Class.create({
	encode_object: function(obj) {
		return JSON.stringify(obj, function(key, val) {
			if (val instanceof Date) {
				return csDateTimeFromDate(val);
			}
			return val;
		}.bind(this))
	}
});

CC.ServiceClient.JSONDecoder = Class.create({
	decode_object: function(data) {
		return JSON.parse(data, function(key, val) {
			if (val && val.type && val.type == 'com.apple.DateTime') {
				return dateFromCSDateTime(val);
			}
			return val;
		});
	}
});

// Service client instance.

CC.ServiceClient.ServiceClientSharedInstance = Class.createWithSharedInstance('service_client');
CC.ServiceClient.ServiceClientSharedInstance.prototype = {
	basePath: "/collabdproxy",
	encoder: null,
	decoder: null,
	session_guid: null,
	referencedObjects: null,
	// Automatic request batching support.
	autobatchRequests: true,
	autobatchWindow: 100, // 100ms
	autobatchQueue: [],
	initialize: function() {
		this.encoder = new CC.ServiceClient.JSONEncoder();
		this.decoder = new CC.ServiceClient.JSONDecoder();
	},
	__httpPUT: function(inRequestData, inCallback, inErrback) {
		logger().info(inRequestData);
		return new Ajax.Request(this.basePath, {
			method: 'put',
			contentType: 'application/json',
			postBody: inRequestData,
			onSuccess: function(response) {
				var unpacked = this.unpackResponse(response);
				return inCallback(unpacked);
			}.bind(this),
			onFailure: inErrback
		});
	},
	__sendRequestAsynchronously: function(inRequest, inOptions, inCallback, inErrback) {
		if (inOptions != undefined) {
			// If this is a batch request, auto-forward request options to individual requests in the batch.
			// Otherwise set request options on the request itself.
			if (inRequest.type == "com.apple.BatchServiceRequest") {
				var requests = inRequest.requests;
				for (var requestIdx = 0; requestIdx < requests.length; requestIdx++) {
					var request = this.setRequestOptionsForRequest(requests[requestIdx], inOptions);
					requests[requestIdx] = request;
				}
			} else {
				inRequest = this.setRequestOptionsForRequest(inRequest, inOptions);
			}
		}
		// Encode the request.
		var requestData = this.encoder.encode_object(inRequest);
		// Make the request.
		return this.__httpPUT(requestData, function(response) {
			// Catch CSSessionRequiredError exception and force-rebuild the session.
			if (response && response.response && response.response.exceptionName) {
			 	if (response.response.exceptionName == 'CSSessionRequiredError') {
					sessions().currentOrNewSessionAsynchronously(true, function(session) {
						return this.__sendRequestAsynchronously(inRequest, inOptions, inCallback, inErrback);
					}.bind(this), Prototype.emptyFunction)
					return;
				}
				logger().error("Exception: " + response.response.exceptionName + " " + response.response.exceptionString);
				if (inErrback) inErrback(response);
				return;
			}
			if (inCallback) inCallback(response);
			return;
		}.bind(this), inErrback);
	},
	// Immediately flushes the autobatched service request queue.
	flushQueuedServiceRequests: function() {
		setTimeout(this.__flushAutobatchQueue.bind(this), 10);
	},
	// Flushes the current set of queued requests by packaging them up in a single batch request.
	__flushAutobatchQueue: function() {
		var queue = this.autobatchQueue;
		this.autobatchQueue = [];
		logger().info("Flushing service client autobatched request queue (%@ items)".fmt(queue.length));
		// Do we have anything in the queue to flush?
		if (!queue || queue.length == 0) return;
		// Build a new batch request by iterating the autobatch queue.
		var batchedRequest = new CC.EntityTypes.BatchServiceRequest();
		var requests = [], orderedCallbackTuples = [];
		for (var idx = 0; idx < queue.length; idx++) {
			var item = queue[idx];
			var request = item[0], options = item[1], callback = item[2], errback = item[3];
			// If the queued request is already a batch request, something is badly wrong.
			if (request.type == "com.apple.BatchServiceRequest") {
				logger().error("Found a com.apple.BatchServiceRequest request in the service client autobatch queue (%@)... skipping", request);
				continue;
			} else {
				if (options) request = this.setRequestOptionsForRequest(request, options);
				requests.push(request);
				logger().info("    Included request: %@ %@".fmt(request.serviceName, request.methodName));
				orderedCallbackTuples.push([callback, errback]);
			}
		}
		// Actually make the service request.
		batchedRequest.requests = requests;
		(function(callbackTuples) {
			this.__sendRequestAsynchronously(batchedRequest, undefined, function(response) {
				// Intercept the response so we can call any callbacks/errbacks in order.
				var _responses = $A(response.responses);
				for (var rdx = 0; rdx < _responses.length; rdx++) {
					var _response = _responses[rdx];
					var callbacks = callbackTuples[rdx];
					if (_response && _response.succeeded) {
						logger().debug("Got batched response %@, dispatching result to callback function", _response);
						(callbacks[0] || Prototype.emptyFunction)(_response);
					} else {
						logger().debug("Got batched response %@, dispatching result to errback function", _response);
						(callbacks[1] || Prototype.emptyFunction)(_response);
					}
				}
			}, function() {
				logger().error("Failed to flush autobatch queue because an error occurred");
			});
		}.bind(this))(orderedCallbackTuples);
	},
	queueRequest: function(inRequest, inOptions, inCallback, inErrback) {
		// Enqueue the request in the autobatch queue. If autobatching is enabled and we don't have an active
		// timer, create a new queue flushing timer which flushes the autobatch queue. If autobatching is disabled
		// flush the autobatch queue right away without using a timer.
		this.autobatchQueue.push([inRequest, inOptions, inCallback, inErrback]);
		// Do we need to flush the autobatch queue?
		if (this.autobatchRequests) {
			if (!this.autobatchQueueTimer) {
				this.autobatchQueueTimer = setTimeout(function() {
					delete this.autobatchQueueTimer;
					this.__flushAutobatchQueue();
				}.bind(this), this.autobatchWindow);
			}
		} else {
			this.__flushAutobatchQueue();
		}
	},
	executeAsynchronously: function(inService, inMethod, inParams, inOptions, inCallback, inErrback) {
		var request = new CC.EntityTypes.ServiceRequest();
		var sessionGUID = sessions().currentSessionCookie();
		request.sessionGUID = sessionGUID;
		request.serviceName = inService;
		request.methodName = inMethod;
		if (inParams) request.arguments = Object.isArray(inParams) ? inParams : [inParams];
		this.queueRequest(request, inOptions, inCallback, inErrback);
	},
	batchExecuteAsynchronously: function(inBatched, inOptions, inCallback, inErrback) {
		var request;
		var sessionGUID = sessions().currentSessionCookie();
		var batchedRequest = new CC.EntityTypes.BatchServiceRequest();
		batchedRequest.requests = $A(inBatched).map(function(arg) {
			request = new CC.EntityTypes.ServiceRequest();
			request.sessionGUID = sessionGUID;
			request.serviceName = arg[0];
			request.methodName = arg[1];
			if (arg.length > 2 && arg[2]) {
				request.arguments = (Object.isArray(arg[2]) ? arg[2] : [arg[2]]);
			}
			if (arg.length > 3 && arg[3]) {
				request = this.setRequestOptionsForRequest(request, arg[3]);
			}
			return request;
		}.bind(this));
		this.__sendRequestAsynchronously(batchedRequest, inOptions, inCallback, inErrback);
	},
	paginateAsynchronously: function(inService, inMethod, inParams, inOptions, inPaginationGUID, inPaginationStartIndex, inPaginationHowMany, inCallback, inErrback) {
		// Create the inner service request we will paginate.
		var request = new CC.EntityTypes.ServiceRequest();
		var sessionGUID = sessions().currentSessionCookie();
		request.sessionGUID = sessionGUID;
		request.serviceName = inService;
		request.methodName = inMethod;
		request.expandReferencedObjects = false;
		if (inParams) request.arguments = Object.isArray(inParams) ? inParams : [inParams];
		// Create the pagination request.
		var pagination = new CC.EntityTypes.PaginationRequest();
		pagination.serviceRequest = request;
		pagination.guid = inPaginationGUID;
		pagination.startIndex = inPaginationStartIndex;
		pagination.resultsLimit = inPaginationHowMany;
		// Create a wrapping service request.
		var service = new CC.EntityTypes.ServiceRequest();
		service.sessionGUID = sessionGUID;
		service.serviceName = 'ContentService';
		service.methodName = 'paginateRequest:'
		service.arguments = [pagination];
		this.__sendRequestAsynchronously(service, inOptions, inCallback, inErrback);
	},
	// Returns a tuple of response (either an response or an ordered array of responses) and an optional
	// array of referenced objects for a service request.
	unpackResponse: function(inResponse) {
		if (!inResponse) return undefined;
		var responseText = inResponse.responseText;
		var decodedResponse = this.decoder.decode_object(responseText);
		if (decodedResponse.type == "com.apple.ServiceResponse") {
			return new CC.EntityTypes.ServiceResponse(decodedResponse);
		} else if (decodedResponse.type == "com.apple.BatchServiceResponse") {
			return new CC.EntityTypes.BatchServiceResponse({'responses': decodedResponse.responses});
		} else if (decodedResponse.type == "com.apple.PaginatedResponse") {
			return new CC.EntityTypes.PaginatedResponse(decodedResponse.response);
		}
		return inResponse;
	},
	// Internal method that maps an options hash to properties on an individual request. Doesn't replace existing request properties.
	// You shouldn't normally call this method yourself.
	setRequestOptionsForRequest: function(inRequest, inOptions) {
		if (inRequest && inOptions) {
			if (inOptions.adminAuthorizationRef != undefined && inRequest.adminAuthorizationRef == undefined) inRequest.adminAuthorizationRef = inOptions.adminAuthorizationRef;
			inRequest.expandReferencedObjects = (inOptions.expandReferencedObjects == undefined ? false : (inOptions.expandReferencedObjects == true ? true : false));
			if (inOptions.referencedPathsToFollow != undefined && inRequest.referencedPathsToFollow == undefined) inRequest.referencedPathsToFollow = inOptions.referencedPathsToFollow;
			if (inOptions.subpropertyPaths != undefined && inRequest.subpropertyPaths == undefined) inRequest.subpropertyPaths = inOptions.subpropertyPaths;
			if (inOptions.clientURL != undefined && inRequest.clientURL == undefined) inRequest.clientURL = inOptions.clientURL;
			if (inOptions.hints != undefined && inRequest.hints == undefined) inRequest.hints = inOptions.hints;
		}
		return inRequest;
	}
};
/**
 * Copyright (c) 2010-2014, Apple Inc. All rights reserved. 
 * 
 * IMPORTANT NOTE: This file is licensed only for use on Apple-branded
 * computers and is subject to the terms and conditions of the Apple Software
 * License Agreement accompanying the package this file is a part of.
 * You may not port this file to another platform without Apple's written consent.
 * 
 * IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
 * of the Apple Software and is subject to the terms and conditions of the Apple
 * Software License Agreement accompanying the package this file is part of.
 **/


function _ucs4Ordinal(ch) {
	var ucs4Ordinal = "";
	ucs4Ordinal += String.fromCharCode(240 | (ch >> 18));
	ucs4Ordinal += String.fromCharCode(127 | ((ch >> 12) & 63));
	ucs4Ordinal += String.fromCharCode(127 | ((ch >> 6) & 63));
	ucs4Ordinal += String.fromCharCode(127 | (ch & 63));
	return ucs4Ordinal;
}

/*
 * Based on PyUnicode_EncodeUTF8
 */

function utf8Encode (string) {
	var utf8Text = "";

	for (var i = 0; i < string.length; i++) {
		var ch = string.charCodeAt(i);

		if (ch < 128) {
			// Characters less than 128 are ASCII
			utf8Text += String.fromCharCode(ch);
		}
		else if((ch > 127) && (ch < 2048)) {
			// Characters between 127 and 2048 are Latin-1
			utf8Text += String.fromCharCode(192 | (ch >> 6));
			utf8Text += String.fromCharCode(128 | (ch & 63));
		}
		else {
			// All other characters are UCS2 or UCS4 unicode ordinals
			if (ch < 65536) {
				// Special case check for high surrogates
				if ((55296 <= ch) && (ch <= 57343) && i != string.length) {
					var ch2 = string.charCodeAt(i + 1);
					// Check for low surrogate and combine for a UCS4 value
					if ((56320 <= ch2) && (ch2 < 57343)) {
						ch = ((ch - 55296) << 10 | (ch2 - 56320)) + 65536;
						i++;
						utf8Text += _ucs4Ordinal(ch);
					}
					// Fall through and handle isolated high surrogates
				}
				utf8Text += String.fromCharCode(224 | (ch >> 12));
				utf8Text += String.fromCharCode(128 | ((ch >> 6) & 63));
				utf8Text += String.fromCharCode(128 | (ch & 63));
				continue;
			}
			utf8Text += _ucs4Ordinal(ch);
		}

	}

	return utf8Text;
}

/*
 * Convert an array of little-endian words to a hex string.
 */
function binl2binstr(binarray)
{
  var str = "";
  for (var i = 0; i < binarray.length; i++)
  {
	for (var j = 0; j < 4; j++)
	{
		str += String.fromCharCode(((binarray[i] >> (j*8)) & 0xFF));
	}
  }
  return str;
}

/*
 * Convert a string to an array of little-endian words
 * If chrsz is ASCII, characters >255 have their hi-byte silently ignored.
 */
function str2binl2(str)
{
  var bin = Array();
  var mask = (1 << chrsz) - 1;
  for(var i = 0; i < str.length * chrsz; i += chrsz)
    bin[i>>5] |= (str.charCodeAt(i / chrsz) & mask) << (i%32);
  return bin;
}

function digestResponse(username, password, challengeString) {
	var challenge = challengeToObject(challengeString);
	// for now lets just handle the realm and nonce
	var nonce = challenge['Digest nonce'];
	if (!nonce) {
	    nonce = challenge.nonce;
	}
	var realm = challenge.realm;
	//var method = challenge['method'];
	//if (!method) {
	//	method = 'GET';
	//}
	var method = 'AUTHENTICATE';
	var path = challenge.path;
	if (!path || path == undefined) {
		path = '/';
	}
	
	// handle qop
	var qop = challenge.qop;
	var doQOPAuth = false;
	var extras = "" // for any of the extra fields we need
	if (qop) {
		var opaque = challenge.opaque;
		var qops = qop.split(",");
		qops.each(function(aQop) {
			if (aQop.indexOf("auth") != -1) {
				doQOPAuth = true;
			}
		});
	}
	
	if (doQOPAuth) {
		// generate a 2617 response
		var cnonce = randomString(36);
	}
	
	var HA1 = new Array(username, realm, password)
	HA1 = utf8Encode(HA1.join(':'));
	
	if (doQOPAuth) {
		HA1 = core_md5(str2binl2(HA1), HA1.length * chrsz);
		HA1 = binl2binstr(HA1) + ":" + nonce + ":" + cnonce;
	}

	HA1 = hex_md5(HA1, HA1.length + chrsz);

	var HA2 = new Array(method, path);
	HA2 = utf8Encode(HA2.join(':'));
	HA2 = hex_md5(HA2, HA2.length + chrsz);
	
	// first, generate a legacy response which will be used in most cases
	var response = new Array(HA1, nonce, HA2);
	
	// now deal with more sophisticated challenges
	if (doQOPAuth) {
		response = new Array(HA1, nonce, "00000001", cnonce, "auth", HA2);
		extras = "qop=\"auth\",nc=\"00000001\",cnonce=\""+cnonce+"\",algorithm=md5-sess,";
	}
	
	response = utf8Encode(response.join(':'));
	response = hex_md5(response, response.length + chrsz);
	var digest = "Digest username=\""+username+"\",realm=\""+realm+"\",nonce=\""+nonce+"\",uri=\""+path+"\","+extras+"response=\""+response +"\"";
	if (opaque != undefined) {
		digest += ",opaque=\""+opaque+"\""
	}
	return digest;
}

function challengeToObject(challengeString) {
	var anObj = {};
	var pairs = challengeString.split(",");
	pairs.each(function(aPair) {
		var kv = aPair.split("=");
		var key = kv[0];
		var value = stripIt(kv.slice(1).join("="));
		anObj[key] = value;
	});
	return anObj;
}

function stripIt(x){
	x = x.replace(/['"]/g,'');
	return x;
}

function randomString(strLength, charSet) {
	if (charSet == undefined) {
		// not great, but good enough to plow the field
		charSet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz";
	}
	var randomString = "";
	for (var i = 0; i < strLength; i++) {
		var whichChar = Math.floor(Math.random()*charSet.length);
		randomString += charSet[whichChar];
	}
	return randomString;
}

;
/*
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

/*
 * Configurable variables. You may need to tweak these to be compatible with
 * the server-side, but the defaults work in most cases.
 */

var hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */
var b64pad  = ""; /* base-64 pad character. "=" for strict RFC compliance   */
var chrsz   = 8;  /* bits per input character. 8 - ASCII; 16 - Unicode      */

/*
 * These are the functions you'll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */
function hex_md5(s){ return binl2hex(core_md5(str2binl(s), s.length * chrsz));}
function b64_md5(s){ return binl2b64(core_md5(str2binl(s), s.length * chrsz));}
function str_md5(s){ return binl2str(core_md5(str2binl(s), s.length * chrsz));}
function hex_hmac_md5(key, data) { return binl2hex(core_hmac_md5(key, data)); }
function b64_hmac_md5(key, data) { return binl2b64(core_hmac_md5(key, data)); }
function str_hmac_md5(key, data) { return binl2str(core_hmac_md5(key, data)); }

/*
 * Perform a simple self-test to see if the VM is working
 */
function md5_vm_test()
{
  return hex_md5("abc") == "900150983cd24fb0d6963f7d28e17f72";
}

/*
 * Calculate the MD5 of an array of little-endian words, and a bit length
 */
function core_md5(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << ((len) % 32);
  x[(((len + 64) >>> 9) << 4) + 14] = len;

  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;

    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);

    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);

    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);

    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
  }
  return Array(a, b, c, d);

}

/*
 * These functions implement the four basic operations the algorithm uses.
 */
function md5_cmn(q, a, b, x, s, t)
{
  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);
}
function md5_ff(a, b, c, d, x, s, t)
{
  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
}
function md5_gg(a, b, c, d, x, s, t)
{
  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
}
function md5_hh(a, b, c, d, x, s, t)
{
  return md5_cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5_ii(a, b, c, d, x, s, t)
{
  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
}

/*
 * Calculate the HMAC-MD5, of a key and some data
 */
function core_hmac_md5(key, data)
{
  var bkey = str2binl(key);
  if(bkey.length > 16) bkey = core_md5(bkey, key.length * chrsz);

  var ipad = Array(16), opad = Array(16);
  for(var i = 0; i < 16; i++)
  {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5C5C5C5C;
  }

  var hash = core_md5(ipad.concat(str2binl(data)), 512 + data.length * chrsz);
  return core_md5(opad.concat(hash), 512 + 128);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function bit_rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}

/*
 * Convert a string to an array of little-endian words
 * If chrsz is ASCII, characters >255 have their hi-byte silently ignored.
 */
function str2binl(str)
{
  var bin = Array();
  var mask = (1 << chrsz) - 1;
  for(var i = 0; i < str.length * chrsz; i += chrsz)
    bin[i>>5] |= (str.charCodeAt(i / chrsz) & mask) << (i%32);
  return bin;
}

/*
 * Convert an array of little-endian words to a string
 */
function binl2str(bin)
{
  var str = "";
  var mask = (1 << chrsz) - 1;
  for(var i = 0; i < bin.length * 32; i += chrsz)
    str += String.fromCharCode((bin[i>>5] >>> (i % 32)) & mask);
  return str;
}

/*
 * Convert an array of little-endian words to a hex string.
 */
function binl2hex(binarray)
{
  var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
  var str = "";
  for(var i = 0; i < binarray.length * 4; i++)
  {
    str += hex_tab.charAt((binarray[i>>2] >> ((i%4)*8+4)) & 0xF) +
           hex_tab.charAt((binarray[i>>2] >> ((i%4)*8  )) & 0xF);
  }
  return str;
}

/*
 * Convert an array of little-endian words to a base-64 string
 */
function binl2b64(binarray)
{
  var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var str = "";
  for(var i = 0; i < binarray.length * 4; i += 3)
  {
    var triplet = (((binarray[i   >> 2] >> 8 * ( i   %4)) & 0xFF) << 16)
                | (((binarray[i+1 >> 2] >> 8 * ((i+1)%4)) & 0xFF) << 8 )
                |  ((binarray[i+2 >> 2] >> 8 * ((i+2)%4)) & 0xFF);
    for(var j = 0; j < 4; j++)
    {
      if(i * 8 + j * 6 > binarray.length * 32) str += b64pad;
      else str += tab.charAt((triplet >> 6*(3-j)) & 0x3F);
    }
  }
  return str;
}

if (window.loaded) loaded('md5.js');
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.





// Authenticator class for plain/digest authentication.
CC.Auth = {};
CC.Auth.LOGIN_STATUS_CHANGED_NOTIFICATION = 'LOGIN_STATUS_CHANGED';

var Authenticator = Class.createWithSharedInstance('authenticator');
Authenticator.prototype = {
	basePath: "/auth",
	csrf_token: null,
	loginFrame: null,
	currentErrorMessage: null,
	initialize: function() {
		this.rememberMe = false;
	},
	displayWindowedLoginPrompt: function(inOptCallback, inOptCancelback, inOptErrMessage) {
		var width = window.innerWidth;
		var height = window.innerHeight;
		var x = Math.floor((width - 340) / 2) + (window.screenX || window.screenLeft);
		var y = Math.floor((height - 300) / 2) + (window.screenY || window.screenTop);
		var w = window.open("/auth?sendToken=no&windowed=yes", "authWindow", "width=340,height=300,left=" + x + ",top=" + y + ",resizable=no,scrollbars=no,dialog=yes,centerscreen=yes");
		if (w == null)
			return false;
		if (inOptCallback)
			w.completionCallback = inOptCallback;
		if (inOptCancelback)
			w.cancelCallback = inOptCancelback;
		if (inOptErrMessage)
			this.currentErrorMessage = inOptErrMessage;
		return true;
	},
	displayFramedLoginPrompt: function(inOptCallback, inOptCancelback, inOptErrMessage) {
		if (this.loginFrame)
			return false;
		
		this.loginFrame = document.createElement('iframe');
		this.loginFrame.className = 'authenticationFrame';
		this.loginFrame.src = "/auth?sendToken=no&framed=yes";
		
		if (inOptCallback)
			this.loginFrame.completionCallback = inOptCallback;
		if (inOptCancelback)
			this.loginFrame.cancelCallback = inOptCancelback;
		if (inOptErrMessage)
			this.currentErrorMessage = inOptErrMessage;
			
		this.loginFrame.addEventListener('load', function(inEvent){
			dialogManager().hide();
			inEvent.target.addClassName('ready');
		}, false);
		
		document.body.appendChild(this.loginFrame);
		
		dialogManager().showProgressMessage("_General.Loading".loc());
		
		return true;
	},
	getCurrentErrorMessage: function() {
		var msg = this.currentErrorMessage;
		this.currentErrorMessage = null;
		return msg;
	},
	completeWindowedLogin: function(inLoginWindow) {
		this.repopulateUserMetadata(function(){
			if (inLoginWindow)
				inLoginWindow.close();
			
			globalNotificationCenter().publish(CC.Auth.LOGIN_STATUS_CHANGED_NOTIFICATION, this);
		
			if (inLoginWindow && inLoginWindow.completionCallback)
				inLoginWindow.completionCallback.call(this);
			if (this.loginFrame && this.loginFrame.completionCallback)
				this.loginFrame.completionCallback.call(this);
			
			if (this.loginFrame)
			{
				this.loginFrame.parentNode.removeChild(this.loginFrame);
				this.loginFrame = null;
			}
		}.bind(this), function(){
			inLoginWindow.close();
			window.location.reload();
		});
	},
	cancelWindowedLogin: function(inLoginWindow) {
		if (inLoginWindow)
			inLoginWindow.close();
		
		if (inLoginWindow && inLoginWindow.cancelCallback)
			inLoginWindow.cancelCallback.call(this);
		if (this.loginFrame && this.loginFrame.cancelCallback)
			this.loginFrame.cancelCallback.call(this);
		
		if (this.loginFrame)
		{
			this.loginFrame.parentNode.removeChild(this.loginFrame);
			this.loginFrame = null;
		}
	},
	repopulateUserMetadata: function(inOptCallback, inOptErrback) {
		server_proxy().refreshMetaTags(inOptCallback, inOptErrback);
	},
	// Plain login.
	login_plain: function(inUsername, inPassword, inCallback, inErrback) {
		var callback = function(inWorked) {
			if (!inWorked) {
				inErrback(inWorked);
			} else {
				inCallback(inWorked);
			}
		}
		server_proxy().validateUsernameAndPassword(inUsername, inPassword, this.rememberMe, callback, inErrback);
	},
	// Digest login.
	login_digest: function(inUsername, inPassword, inCallback, inErrback) {
		var validateCallback = function(success) {
			if (success) {
				inCallback(success);
			} else {
				inErrback(success);
			}
		}
		var challengeCallback = function(challenge) {
			var digested = digestResponse(inUsername, inPassword, challenge);
			server_proxy().validateUsernameAndPasswordDigest(digested, this.rememberMe, validateCallback, inErrback);
		}
		server_proxy().getChallenge(inUsername, true, challengeCallback.bind(this), inErrback);
	},
	// Logout.
	logout: function() {
		var currentURL = window.location;
		window.location.href = "/auth/logout?redirect=" + currentURL;
	},
	setRememberMe: function(inRemember) {
		this.rememberMe = inRemember;
	}
};
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.

// Global event instance. Supports registration for events using a delegate model where an event
// registration is a tuple of DOM responder identifer (e.g. div#abc123) and callback function. A
// single event handler is registered on the window object and as events fire, they are handed off
// to any receivers that have made themselves known. Allows us to register less handlers for
// performance, but more importantly supports event registration on elements inside a contentEditable
// container which survive undo/redo events.

var GlobalEventDelegate = Class.createWithSharedInstance('globalEventDelegate');
GlobalEventDelegate.prototype = {
	mEventResponderRegistry: null,
	mRegisteredHandlersCache: null,
	initialize: function() {
		bindEventListeners(this, ['handleEventFired']);
		this.mEventResponderRegistry = new Hash();
		this.mRegisteredHandlersCache = {};
	},
	// Registers a DOM-responder for a given event by identifer. When an event fires that is
	// recieved by the global event delegate, we determine the closest element to the
	// event source matching an event responder, and delegate to that responder.
	registerDomResponderForEventByIdentifer: function(inEventName, inIdentifer, inCallback) {
		if (!inEventName) return false;
		if (inEventName == "click" && browser().isMobile()) {
			inEventName = "touchstart";
		}
		
		logger().debug("registerDomResponderForEventByIdentifer: %o %o", inEventName, inIdentifer);
		var responders = this.mEventResponderRegistry.get(inEventName);
		if (!responders) responders = this.mEventResponderRegistry.set(inEventName, new Hash());
		responders.set(inIdentifer, inCallback);
		this._registerEventHandlerForResponder(inEventName);
		return true;
	},
	bulkRegisterDomResponderForEventByIdentifer: function(inBatch) {
		if (!inBatch) return false;
		var batchItem;
		for (var batchIdx = 0; batchIdx < inBatch.length; batchIdx++) {
			batchItem = inBatch[batchIdx];
			this.registerDomResponderForEventByIdentifer(batchItem[0], batchItem[1], batchItem[2]);
		}
	},
	_registerEventHandlerForResponder: function(inEventName) {
		// Strictly one event handler per customer for performance.
		if (!this.mRegisteredHandlersCache[inEventName]) {
			Event.observe(window, inEventName, this.handleEventFired);
		}
	},
	// Unregisters a previously registered responder for an event name by identifer.
	unregisterDomResponderForEventByIdentifer: function(inEventName, inIdentifer) {
		if (!inEventName || !inIdentifer) return false;
		var eventResponders = this.mEventResponderRegistry.get(inEventName);
		if (!eventResponders || !eventResponders.get(inIdentifer)) return false;
		delete eventResponders[inIdentifer];
		this.mEventResponderRegistry.set(inEventName, eventResponders);
		return true;
	},
	// Unregisters all responders for a given event name.
	unregisterDomRespondersForEvent: function(inEventName) {
		if (!inEventName) return false;
		this.mEventResponderRegistry.unset(inEventName);
		return true;
	},
	// Handles an event, delegating to a registered DOM responder where possible. 
	handleEventFired: function(inEvent) {
		var type, responders, eventElement, nearesetResponder, nearestResponderId, nearestResponderCallback;
		// Do we have any responders for this event type?
		type = inEvent.type;
		responders = this.mEventResponderRegistry.get(type);
		if (responders) {
			eventElement = Event.element(inEvent);
			// Find the nearest responder in the document. For performance, check if the direct event
			// source element is a responder for this event. Otherwise walk up the direct ancestors tree.
			var workingNode = eventElement, workingNodeId;
			while (workingNode) {
				workingNodeId = (workingNode.id || (workingNode.readAttribute && workingNode.readAttribute('data-responder-id')));
				if (workingNodeId && responders.get(workingNodeId)) {
					nearestResponder = workingNode;
					nearestResponderId = workingNodeId;
					break;
				}
				workingNode = workingNode.parentNode;
			}
			if (nearestResponderId) {
				responderCallback = responders.get(nearestResponderId);
				// Trigger the callback for the nearest responder.
				if (responderCallback) {
					logger().debug("Delegating event %o to nearest responder %o %o", type, nearestResponderId, nearestResponder);
					return responderCallback(inEvent);
				}
			}
		}
		return false;
	},
	// Debug only. Simulates an event.
	simulateEvent: function(inEventName, inIdentifer) {
		if (!inEventName || !inIdentifer) return false;
		logger().debug("simulateEvent: %o, %o", inEventName, inIdentifer);
		Event.fire($(inIdentifer), inEventName);
	}
};
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.



CC.Keyboard = CC.Keyboard || new Object();
CC.Keyboard.Mixins = CC.Keyboard.Mixins || new Object();

// A keyboard shortcut delegate.

CC.Keyboard.NOTIFICATION_DID_KEYBOARD_RETURN = 'DID_KEYBOARD_RETURN';
CC.Keyboard.NOTIFICATION_DID_KEYBOARD_TAB = 'DID_KEYBOARD_TAB';
CC.Keyboard.NOTIFICATION_DID_KEYBOARD_SHIFT_TAB = 'DID_KEYBOARD_SHIFT_TAB';
CC.Keyboard.NOTIFICATION_DID_KEYBOARD_ESC = 'DID_KEYBOARD_ESC';
CC.Keyboard.NOTIFICATION_DID_KEYBOARD_SHIFT_ESC = 'DID_KEYBOARD_SHIFT_ESC'
CC.Keyboard.NOTIFICATION_DID_KEYBOARD_SPACE = 'DID_KEYBOARD_SPACE';
CC.Keyboard.NOTIFICATION_DID_KEYBOARD_BACKSPACE = 'DID_KEYBOARD_BACKSPACE';
CC.Keyboard.NOTIFICATION_DID_KEYBOARD_DELETE = 'DID_KEYBOARD_DELETE';
CC.Keyboard.NOTIFICATION_DID_KEYBOARD_FORWARD_DELETE = 'DID_KEYBOARD_FORWARD_DELETE';
CC.Keyboard.NOTIFICATION_DID_KEYBOARD_LEFT = 'DID_KEYBOARD_LEFT';
CC.Keyboard.NOTIFICATION_DID_KEYBOARD_RIGHT = 'DID_KEYBOARD_RIGHT';
CC.Keyboard.NOTIFICATION_DID_KEYBOARD_UP = 'DID_KEYBOARD_UP';
CC.Keyboard.NOTIFICATION_DID_KEYBOARD_DOWN = 'DID_KEYBOARD_DOWN';
CC.Keyboard.NOTIFICATION_DID_KEYBOARD_PAGEUP = 'DID_KEYBOARD_PAGEUP';
CC.Keyboard.NOTIFICATION_DID_KEYBOARD_PAGEDOWN = 'DID_KEYBOARD_PAGEDOWN';
CC.Keyboard.NOTIFICATION_DID_KEYBOARD_SELECT_ALL = 'DID_KEYBOARD_SELECT_ALL';
CC.Keyboard.NOTIFICATION_DID_KEYBOARD_CLOSE = 'DID_KEYBOARD_CLOSE';
CC.Keyboard.NOTIFICATION_DID_KEYBOARD_SAVE = 'DID_KEYBOARD_SAVE';
CC.Keyboard.NOTIFICATION_DID_KEYBOARD_CUT = 'DID_KEYBOARD_CUT';
CC.Keyboard.NOTIFICATION_DID_KEYBOARD_COPY = 'DID_KEYBOARD_COPY';
CC.Keyboard.NOTIFICATION_DID_KEYBOARD_PASTE = 'DID_KEYBOARD_PASTE';
CC.Keyboard.NOTIFICATION_DID_KEYBOARD_INDENT = 'DID_KEYBOARD_INDENT';
CC.Keyboard.NOTIFICATION_DID_KEYBOARD_OUTDENT = 'DID_KEYBOARD_OUTDENT';
CC.Keyboard.NOTIFICATION_DID_KEYBOARD_BOLD = 'DID_KEYBOARD_BOLD';
CC.Keyboard.NOTIFICATION_DID_KEYBOARD_ITALIC = 'DID_KEYBOARD_ITALIC';
CC.Keyboard.NOTIFICATION_DID_KEYBOARD_UNDERLINE = 'DID_KEYBOARD_UNDERLINE';
CC.Keyboard.NOTIFICATION_DID_KEYBOARD_MODIFIER = 'DID_KEYBOARD_MODIFIER';
CC.Keyboard.NOTIFICATION_DID_KEYBOARD_MODIFIER_UP = 'DID_KEYBOARD_MODIFIER_UP';
CC.Keyboard.NOTIFICATION_DID_KEYBOARD_GENERIC = 'DID_KEYBOARD_GENERIC';

Object.extend(Event, {
	CHARACTER_A: 65,
	CHARACTER_B: 66,
	CHARACTER_C: 67,
	CHARACTER_I: 73,
	CHARACTER_S: 83,
	CHARACTER_U: 85,
	CHARACTER_V: 86,
	CHARACTER_W: 87,
	CHARACTER_X: 88,
	CHARACTER_LEFT_SQUARE_BRACKET: 219,
	CHARACTER_RIGHT_SQUARE_BRACKET: 221,
	KEY_DELETE: 46,
	KEY_TAB: 9,
	KEY_SHIFT: 16,
	KEY_CONTROL: 17,
	KEY_OPTION: 18,
	KEY_COMMAND: 91,
	KEY_SPACE: 32,
	KEY_COMMA: 188,
	KEY_FORWARD_DELETE: 127
});

// Keyboard responder mixin.

CC.Keyboard.Mixins.Responder = {
	mIsKeyboardResponder: true,
	// Handles a keyboard notification returning true if the notification was
	// handled successfully and false otherwise. Returning true will prevent
	// the notification from firing elsewhere.
	handleKeyboardNotification: function(inMessage, inObject, inOptExtras) { /* Interface */ },
	willBecomeFirstResponder: function() { /* Interface */ },
	willLoseFirstResponder: function() { /* Interface */ },
	// Make this keyboard responder first responder. If another responder later
	// steals first responder status, your responder will regain first responder
	// once once the new responder loses first responder status.
	becomeFirstResponder: function() {
		this.willBecomeFirstResponder();
		globalKeyboardDelegate().mResponderChain = globalKeyboardDelegate().mResponderChain.without(this);
		globalKeyboardDelegate().pushFirstResponder(this);
	},
	// Give up first responder status.
	loseFirstResponder: function() {
		this.willLoseFirstResponder();
		globalKeyboardDelegate().mResponderChain = globalKeyboardDelegate().mResponderChain.without(this);
	}
};

// Global keyboard shortcut delegate.

CC.Keyboard.GlobalKeyboardShortcutDelegate = Class.createWithSharedInstance('globalKeyboardDelegate', true);
CC.Keyboard.GlobalKeyboardShortcutDelegate.prototype = {
	mResponderChain: null,
	initialize: function() {
		Event.observe(window, 'keydown', this.handleKeyboardEvent.bind(this));
		Event.observe(window, 'keyup', this.handleKeyboardUpEvent.bind(this));
		this.mResponderChain = new Array();
	},
	// Returns the first available responder in the responder chain.
	firstResponder: function() {
		if (this.mResponderChain.length > 0) return this.mResponderChain[0];
	},
	// Returns the next available responder after the current first responder.
	nextResponder: function() {
		if (this.mResponderChain.length > 1) return this.mResponderChain[1];
	},
	// Pushes a new first responder at the top of the responder chain.
	pushFirstResponder: function(inResponder) {
		if (!inResponder || (inResponder && !inResponder.mIsKeyboardResponder)) return;
		if (this.firstResponder() == inResponder) return;
		this.mResponderChain = this.mResponderChain.without(inResponder);
		this.mResponderChain.unshift(inResponder);
	},
	// Removes and returns the current first responder from the responder chain.
	popFirstResponder: function() {
		return this.mResponderChain.shift();
	},
	// Returns true if the user is holding the default modifier combination
	// for their platform (ctrl on Windows/Linux, cmd on Mac).
	isHoldingDefaultModifier: function(inEvent) {
		if ((browser().isWindows() || browser().isLinux()) && inEvent.ctrlKey) return false;
		else return (browser().isMacintosh() && inEvent.metaKey);
	},
	// Returns true if the user is holding the shift key.
	isHoldingShiftKey: function(inEvent) {
		return (inEvent && inEvent.shiftKey);
	},
	// Handles a keyboard event by traversing the responder chain looking for a responder that
	// successfully handles the event. Otherwise, publishes a generic keyboard notification.
	handleKeyboardEvent: function(inEvent) {
		var keyCode = inEvent.keyCode;
		if (!keyCode) return;
		// Initialize some constants.
		var notification = CC.Keyboard.NOTIFICATION_DID_KEYBOARD_GENERIC;
		var optExtras = {'event': inEvent};
		// Determine the notification we will publish.
		switch (keyCode) {
			case Event.KEY_RETURN:
				notification = CC.Keyboard.NOTIFICATION_DID_KEYBOARD_RETURN;
				break;
			case Event.KEY_TAB:
				notification = (this.isHoldingShiftKey(inEvent) ? CC.Keyboard.NOTIFICATION_DID_KEYBOARD_SHIFT_TAB : CC.Keyboard.NOTIFICATION_DID_KEYBOARD_TAB);
				break;
			case Event.KEY_SPACE:
				notification = CC.Keyboard.NOTIFICATION_DID_KEYBOARD_SPACE;
				break;
			case Event.KEY_BACKSPACE:
				notification = CC.Keyboard.NOTIFICATION_DID_KEYBOARD_BACKSPACE;
				break;
			case Event.KEY_DELETE:
				notification = CC.Keyboard.NOTIFICATION_DID_KEYBOARD_DELETE;
				break;
			case Event.KEY_FORWARD_DELETE:
				notification = CC.Keyboard.NOTIFICATION_DID_KEYBOARD_FORWARD_DELETE;
				break;
			case Event.KEY_LEFT:
				notification = CC.Keyboard.NOTIFICATION_DID_KEYBOARD_LEFT;
				break;
			case Event.KEY_RIGHT:
				notification = CC.Keyboard.NOTIFICATION_DID_KEYBOARD_RIGHT;
				break;
			case Event.KEY_UP:
				notification = CC.Keyboard.NOTIFICATION_DID_KEYBOARD_UP;
				break;
			case Event.KEY_DOWN:
				notification = CC.Keyboard.NOTIFICATION_DID_KEYBOARD_DOWN;
				break;
			case Event.KEY_PAGEUP:
				notification = CC.Keyboard.NOTIFICATION_DID_KEYBOARD_PAGEUP;
				break;
			case Event.KEY_PAGEDOWN:
				notification = CC.Keyboard.NOTIFICATION_DID_KEYBOARD_PAGEDOWN;
				break;
			case Event.KEY_ESC:
				notification = (this.isHoldingShiftKey(inEvent) ? CC.Keyboard.NOTIFICATION_DID_KEYBOARD_SHIFT_ESC : CC.Keyboard.NOTIFICATION_DID_KEYBOARD_ESC);
				break;
			// Select all.
			case Event.CHARACTER_A:
				if (!this.isHoldingDefaultModifier(inEvent)) break;
				notification = CC.Keyboard.NOTIFICATION_DID_KEYBOARD_SELECT_ALL;
				break;
			// Close.
			case Event.CHARACTER_W:
				if (!this.isHoldingDefaultModifier(inEvent)) break;
				notification = CC.Keyboard.NOTIFICATION_DID_KEYBOARD_CLOSE;
				break;
			// Save.
			case Event.CHARACTER_S:
				if (!this.isHoldingDefaultModifier(inEvent)) break;
				notification = CC.Keyboard.NOTIFICATION_DID_KEYBOARD_SAVE;
				break;
			// Cut.
			case Event.CHARACTER_X:
				if (!this.isHoldingDefaultModifier(inEvent)) break;
				notification = CC.Keyboard.NOTIFICATION_DID_KEYBOARD_CUT;
				break;
			// Copy.
			case Event.CHARACTER_C:
				if (!this.isHoldingDefaultModifier(inEvent)) break;
				notification = CC.Keyboard.NOTIFICATION_DID_KEYBOARD_COPY;
				break;
			// Paste.
			case Event.CHARACTER_V:
				if (!this.isHoldingDefaultModifier(inEvent)) break;
				notification = CC.Keyboard.NOTIFICATION_DID_KEYBOARD_PASTE;
				break;
			// Indent.
			case Event.CHARACTER_RIGHT_SQUARE_BRACKET:
				if (!this.isHoldingDefaultModifier(inEvent)) break;
				notification = CC.Keyboard.NOTIFICATION_DID_KEYBOARD_INDENT;
				break;
			// Outdent.
			case Event.CHARACTER_LEFT_SQUARE_BRACKET:
				if (!this.isHoldingDefaultModifier(inEvent)) break;
				notification = CC.Keyboard.NOTIFICATION_DID_KEYBOARD_OUTDENT;
				break;
			// Bold.
			case Event.CHARACTER_B:
				if (!this.isHoldingDefaultModifier(inEvent)) break;
				notification = CC.Keyboard.NOTIFICATION_DID_KEYBOARD_BOLD;
				break;
			// Italic.
			case Event.CHARACTER_I:
				if (!this.isHoldingDefaultModifier(inEvent)) break;
				notification = CC.Keyboard.NOTIFICATION_DID_KEYBOARD_ITALIC;
				break;
			// Underline.
			case Event.CHARACTER_U:
				if (!this.isHoldingDefaultModifier(inEvent)) break;
				notification = CC.Keyboard.NOTIFICATION_DID_KEYBOARD_UNDERLINE;
				break;
			// Modifier.
			case Event.KEY_SHIFT:
			case Event.KEY_CONTROL:
			case Event.KEY_OPTION:
			case Event.KEY_COMMAND:
				notification = CC.Keyboard.NOTIFICATION_DID_KEYBOARD_MODIFIER;
				break;
		}
		// Is there a responder in the chain that wants to handle the notification?
		var responderIdx, responder, processed;
		for (var responderIdx = 0; responderIdx < this.mResponderChain.length; responderIdx++) {
			responder = this.mResponderChain[responderIdx];
			if (responder && (responder.handleKeyboardNotification(notification, undefined, optExtras) == true)) {
				processed = true;
				break;
			}
		}
		// Otherwise, publish a notification.
		if (!processed) {
			logger().debug("dispatchKeyboardNotification: %o %o", notification, optExtras);
			globalNotificationCenter().publish(notification, undefined, optExtras);
			return false;
		}
		return true;
	},
	// Handles a keyboard event by traversing the responder chain looking for a responder that
	// successfully handles the event. Otherwise, publishes a generic keyboard notification.
	// Up events are only processed for modifier keys.
	handleKeyboardUpEvent: function(inEvent) {
		var keyCode = inEvent.keyCode;
		if (!keyCode) return;
		// Initialize some constants.
		var notification = CC.Keyboard.NOTIFICATION_DID_KEYBOARD_GENERIC;
		var optExtras = {'event': inEvent};
		// Determine the notification we will publish.
		switch (keyCode) {
			// Modifier.
			case Event.KEY_SHIFT:
			case Event.KEY_CONTROL:
			case Event.KEY_OPTION:
			case Event.KEY_COMMAND:
				notification = CC.Keyboard.NOTIFICATION_DID_KEYBOARD_MODIFIER_UP;
				break;
		}
		if (notification != CC.Keyboard.NOTIFICATION_DID_KEYBOARD_MODIFIER_UP) return;
		// Go straight to publishing a notification.
		logger().debug("dispatchKeyboardNotification: %o %o", notification, optExtras);
		globalNotificationCenter().publish(notification, undefined, optExtras);
		return false;
	}
};
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.




CC.Store = CC.Store || new Object();
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.




// Store tracking objects returned from the server, local modifications to those objects,
// and responsible for building changesets for objects that can be pushed back to the server.

CC.Store.BackingStore = Class.create(CC.Object, {
	// Hash tracking objects as returned by the server. Cannonical unaltered copies.
	_store: null,
	// A set of working copies for each object in the store.
	_workingCopies: null,
	// A set of working changes for objects in the working copy store.
	_changes: null,
	// A set of deferred changes for objects in the working copy store.
	_deferredChanges: null,
	_deferredChangesOrderStack: null,
	// Initialize the store.
	initialize: function() { this.purgeStore(); },
	// Push a new model into the store. We only support instances of our
	// CC.Mvc.Model base class. Returns a working copy if the object was
	// successfully added to the store, and undefined otherwise.
	pushObject: function(inObject) {
		if (!inObject || !inObject.isModel || !inObject.guid) return undefined;
		var guid = inObject.guid;
		// Add the object to the store.
		this._store.set(guid, inObject);
		// Clone and return a working copy.
		var workingCopy = CC.deepClone(inObject);
		this._workingCopies.set(guid, workingCopy);
		// Keep the store consistent by nuking any changes for this guid.
		this._changes.unset(guid);
		logger().debug("pushObject: %o", inObject);
		return workingCopy;
	},
	// Pushes an individual change for an object into the store. Returns
	// true if the change was successfully added and false otherwise.
	pushChangeForObject: function(inObject, inPropertyPath, inChange) {
		if (!inObject || !inObject.isModel || !inPropertyPath) return false;
		// Fetch the changelist for the object.
		var guid = inObject.guid;
		if (!guid || !this._store.get(guid)) return false;
		var changelist = this._changes.get(guid);
		if (!changelist) changelist = this._changes.set(guid, {});
		// Update the changelist.
		changelist[inPropertyPath] = inChange;
		// Update the working copy.
		var workingCopy = this._workingCopies.get(guid);
		if (!workingCopy) return false;
		if (inPropertyPath.indexOf('.') == -1) {
			workingCopy[inPropertyPath] = inChange;
		}
		else {
			// We have a property path, so get a reference to the property we're
			// trying to update.
			var matches = inPropertyPath.match(/(.*)\.(\w+)$/);
			if (!matches.length || matches.length < 3) return false;
			var path = matches[1], attribute = matches[2];
			var property = CC.objectForPropertyPath(path, workingCopy);
			if (!property) {
				var property = {};
				var subproperty = property;
				for (var idx = 0; idx < matches.length; idx++) {
					subproperty = subproperty[matches[idx]] = {};
				}
			}
			property[attribute] = inChange;
		}
		logger().debug("pushChangeForObject: %o %o %o", inObject, inPropertyPath, inChange);
		return true;
	},
	// Pushes a bulk change for an object into the store.
	pushBulkChangeForObject: function(inObject, inBulkChanges) {
		if (!inObject || !inObject.isModel || !inBulkChanges) return false;
		for (var key in inBulkChanges) {
			if (inBulkChanges.hasOwnProperty(key)) {
				this.pushBulkChangeForObject(inObject, key, inBulkChanges[key]);
			}
		}
		logger().debug("pushBulkChangeForObject: %o %o", inObject, inBulkChanges);
		return true;
	},
	// Pushes a deferred individual change for an object into the store. A deferred
	// change is determined by the object being updated, the property being changed
	// and a callback function calculating the new value. Deferred values will be
	// calculated once calculateDeferredChanges() is called on the parent store.
	// Deferred store changes are calculated in the order in which they were pushed.
	// Returns true if the change was successfully queued, and false otherwise.
	pushChangeForObjectUsingDeferred: function(inObject, inPropertyPath, inCallback) {
		if (!inObject || !inObject.isModel || !inPropertyPath) return false;
		// Fetch the list of deferred changes for the object.
		var guid = inObject.guid;
		if (!guid || !this._store.get(guid)) return false
		var deferred = this._deferredChanges.get(guid);
		if (!deferred) deferred = this._deferredChanges.set(guid, []);
		// Each deferred change is stored as a property and callback tuple.
		var change = [inPropertyPath, inCallback];
		deferred.push(change);
		this._deferredChanges.set(guid, deferred);
		if (!this._deferredChangesReverseMap.get(guid)) {
			this._deferredChangesStack.push(guid);
			this._deferredChangesReverseMap.set(guid, true);
		}
		logger().debug("pushDeferredChangeForObject: %o %o %o", inObject, inPropertyPath, inCallback);
		return true;
	},
	// Returns the working copy for an object with a given GUID.
	workingCopyForGUID: function(inGUID) {
		return (inGUID && this._workingCopies && this._workingCopies.get(inGUID));
	},
	// Removes an object with a given identifer from the store if it exists.
	// Returns the object where it was successfully removed, and undefined
	// otherwise.
	popObject: function(inGUID) {
		if (!inGUID || !this._store.get(inGUID)) return undefined;
		this._changes.unset(inGUID);
		return this._store.unset(inGUID);
	},
	// Deletes everything from the store.
	purgeStore: function() {
		this._store = new Hash();
		this._workingCopies = new Hash();
		this.purgeChangesFromStore();
	},
	purgeChangesFromStore: function() {
		this._changes = new Hash();
		this._deferredChanges = new Hash();
		this._deferredChangesStack = new Array();
		this._deferredChangesReverseMap = new Hash();
	},
	// Deletes any trace of a given GUID from the store.
	purgeGUID: function(inGUID) {
		if (!inGUID || !this._store.get(inGUID)) return false;
		this._store.unset(inGUID);
		this._changes.unset(inGUID);
		this._workingCopies.unset(inGUID);
		this._deferredChanges.unset(inGUID);
		return true;
	},
	// Calculates any deferred record changes, pushing the results back into the store.
	// If inOptCalculateOnly is specified, changes are calculated and returned without
	// being pushed into the store.
	calculateDeferredChanges: function(inOptCalculateOnly) {
		var deferredChanges = this._deferredChanges;
		var deferredGUIDs = this._deferredChangesStack;
		if (!deferredGUIDs || deferredGUIDs.length == 0) return [];
		var result = {}, deferredChangeIdx, deferredGUID;
		for (deferredGUIDIdx = 0; deferredGUIDIdx < deferredGUIDs.length; deferredGUIDIdx++) {
			deferredGUID = deferredGUIDs[deferredGUIDIdx];
			result[deferredGUID] = this.calculateDeferredChangesForGUID(deferredGUID, inOptCalculateOnly);
		}
		logger().debug("calculateDeferredChanges: %o %o", inOptCalculateOnly, result);
		return result;
	},
	// Calculates any deferred record changes for a given block guid, pushing the results back
	// into the store. If inOptCalculateOnly is specified, changes are calculated and returned
	// without being pushed into the store.
	calculateDeferredChangesForGUID: function(inGUID, inOptCalculateOnly) {
		if (!inGUID) return undefined;
		var deferredChanges = this._deferredChanges.get(inGUID);
		if (!deferredChanges || deferredChanges.length == 0) return [];
		var deferredChangeIdx, deferredChange, deferredChangePropertyPath, deferredChangeCallback, value, result = [];
		for (deferredChangeIdx = 0; deferredChangeIdx < deferredChanges.length; deferredChangeIdx++) {
			deferredChange = deferredChanges[deferredChangeIdx];
			deferredChangePropertyPath = deferredChange[0];
			deferredChangeCallback = deferredChange[1];
			// Evaluate the deferred property.
			value = (deferredChangeCallback ? deferredChangeCallback() : undefined);
			// Push the evaluated property onto the changeset for this GUID.
			result.push([deferredChangePropertyPath, value, null]);
			// Bail early if we're calculating deferred changes only.
			if (inOptCalculateOnly) continue;
			// Otherwise push the change into the store.
			this.pushChangeForObject(this._workingCopies.get(inGUID), deferredChangePropertyPath, value);
		}
		logger().debug("calculateDeferredChangesForGUID: %o %o %o", inGUID, (inOptCalculateOnly == true), result);
		return result;
	},
	// Builds a changeset for a model with a given guid. Returns a changeset, which
	// is a dictionary of revision (an integer) and changes (a tuple of key, new value
	// pairs and timestamp).
	buildChangesetForObjectWithGUID: function(inGUID) {
		if (!inGUID) return undefined;
		var changeset = [], changelist = this._changes.get(inGUID);
		if (!changelist) return undefined;
		// Get the working copy so we can calculate which attributes to include
		// in the changeset.
		var workingCopy = this._workingCopies.get(inGUID);
		if (!workingCopy || !workingCopy.isChangeAware) return undefined;
		var attributes = workingCopy.changesetAttributes();
		// Track any keys we've already added to the changeset.
		var changeKeysSoFar = $A([]);
		// Build the changeset.
		var propertyPath, value, type;
		for (var key in changelist) {
			propertyPath = key;
			// Only consider the root of a property path.
			if (propertyPath.match(/\./)) propertyPath = propertyPath.split('.')[0];
			// Bail if the property is not flagged for inclusion in a changeset.
			if (attributes.indexOf(propertyPath) == -1) continue;
			value = workingCopy[propertyPath];
			// Map any fancy attributes to vanilla objects.
			if ((type = CC.typeOf(value)) && (type == CC.T_OBJECT || type == CC.T_HASH) && value.toObject) value = value.toObject();
			if (changeKeysSoFar.include(propertyPath)) continue;
			changeset.push([propertyPath, value, null]);
			changeKeysSoFar.push(propertyPath);
		}
		return changeset
	},
	// Bulk builds a set of changesets for an array of models. Returns
	// a dictionary of changesets keyed by model guid.
	buildChangesetForObjectsWithGUIDs: function(inGUIDs) {
		var changesets = {}, guidIdx, guid;
		if (!inGUIDs) return changesets;
		if (CC.typeOf(inGUIDs) != 'array') inGUIDs = [inGUIDs];
		for (guidIdx = 0; guidIdx < inGUIDs.length; guidIdx++) {
			guid = inGUIDs[guidIdx];
			changesets[guid] = this.buildChangesetForObjectWithGUID(guid);
		}
		logger().debug("buildChangesetForObjectWithGUIDs: %o %o", inGUIDs, changesets);
		return changesets;
	},
	// Returns a hash of changesets for all modified objects in the store.
	allChanges: function() {
		return this.buildChangesetForObjectsWithGUIDs(this._changes.keys());
	},
	// Returns a double-array of object guids and changests for all modified objects with a matching type in the store.
	allChangesForModelType: function(inType) {
		if (!inType) return [];
		var guids = [];
		var workingCopyValues = this._workingCopies.values(), workingCopyValueIdx, workingCopyValue;
		for (workingCopyValueIdx = 0; workingCopyValueIdx < workingCopyValues.length; workingCopyValueIdx++) {
			workingCopyValue = workingCopyValues[workingCopyValueIdx];
			if (workingCopyValue.isModel && workingCopyValue.type == inType) guids.push(workingCopyValue.guid);
		}
		return this.buildChangesetForObjectsWithGUIDs(guids);
	},
	// Returns true if the store has unsaved changes.
	hasUnsavedChanges: function() {
		return (this._changes.size() > 0 || this._deferredChanges.size() > 0);
	}
});
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.




// Sessions global responsible for tracking all things session related, including session cookies
// and session instances returned from the server. Important note: the session is not magically loaded
// when the page is loaded to avoid blocking the UI and to avoid race conditions where the session
// is loaded after dependent code is called. Any code that is expecting a populated session/user should
// be making calls to currentUserAsynchronously and currentOrNewSessionAsynchronously before drawing
// any dependent UI.

CC.now = function() {
	return Math.round(new Date().getTime() / 1000);
};

CC.Sessions = Class.createWithSharedInstance('sessions');
CC.Sessions.prototype = {
	mCurrentSession: null,
	mTimestamp: null,
	mRefreshInterval: 8 * 60 * 60,
	initialize: function() {},
	// Fetches a full session instance given the current session cookie, accepting an optional force
	// reset flag which nukes the local cookie and obtains a new session.
	currentOrNewSessionAsynchronously: function(inShouldReset, inCallback, inErrback) {
		var sessionGUID;
		if (!inShouldReset) {
			var currentSession = this.__getCurrentSession();
			if (currentSession) {
				logger().debug("currentOrNewSessionAsynchronously: %@", currentSession);
				var timestamp = CC.now();
				if ((timestamp - this.mTimestamp) < this.mRefreshInterval) {
					inCallback(currentSession);
					return;
				}
			}
			// Do we have a session cookie we can use?
			sessionGUID = this.currentSessionCookie();
		} else {
			// Nuke the current session (including the cookie) to force the server to grant us a new one.
			this.__resetCurrentSession();
		}
		// Fetch a session.
		service_client().executeAsynchronously('AuthService', 'currentOrNewSession', [], {}, function(service_response) {
			var session = (service_response && service_response.response);
			if (session) {
				logger().debug("session: " + JSON.stringify(session));
				this.__setCurrentSession(session);
				if (inCallback) inCallback(session);
				return;
			}
		}.bind(this), inErrback);
	},
	currentUserAsynchronously: function(inCallback, inErrback) {
		this.currentOrNewSessionAsynchronously(false, function(session) {
			return inCallback(session.user);
		}, function() {
			logger().error("Could not fetch current user");
			return inErrback();
		});
	},
	// Returns the current session cookie if it exists.
	currentSessionCookie: function() {
		return globalCookieManager().getCookie('cc.collabd_session_guid');
	},
	// Returns the current session.  You should not normally call this manually, use currentOrNewSessionAsynchronously.
	__getCurrentSession: function() {
		logger().debug("currentSession: %@", this.mCurrentSession);
		return this.mCurrentSession;
	},
	// Sets the current session. You should not normally call this manually.
	__setCurrentSession: function(inSession) {
		this.mTimestamp = CC.now();
		var sessionModel = new CC.EntityTypes.Session(inSession);
		logger().debug("__setCurrentSession: %@", sessionModel);
		globalCookieManager().setCookie('cc.collabd_session_guid', sessionModel.guid);
		return (this.mCurrentSession = sessionModel);
	},
	// Resets the current session (logging the current user out if they're authenticated). You should not normally
	// call this method manually.
	__resetCurrentSession: function(inOptCallback, inOptErrback) {
		logger().debug("__resetCurrentSession: %@");
		this.mCurrentSession = null;
		this.mTimestamp = null;
		globalCookieManager().destroyCookie('cc.collabd_session_guid');
	}
};
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.






CC.ServerProxy = CC.ServerProxy || new Object();

// A server proxy shared instance.

CC.ServerProxy.SharedInstance = Class.createWithSharedInstance('server_proxy');
CC.ServerProxy.SharedInstance.prototype = {
	mDefaultSubpropertyPaths: {
		'containerGUID.longName': 'container.longName',
		'containerGUID.shortName': 'container.shortName',
		'containerGUID.type': 'container.type',
		'containerGUID.avatarGUID': 'container.avatarGUID',
		'containerGUID.tinyID': 'container.tinyID',
		'containerGUID.isHidden': 'container.isHidden',
		'updatedByUserGUID.longName': 'updatedByUser.longName',
		'updatedByUserGUID.shortName': 'updatedByUser.shortName',
		'updatedByUserGUID.type': 'updatedByUser.type',
		'updatedByUserGUID.avatarGUID': 'updatedByUser.avatarGUID',
		'updatedByUserGUID.tinyID': 'updatedByUser.tinyID',
		'createdByUserGUID.longName': 'createdByUser.longName',
		'createdByUserGUID.shortName': 'createdByUser.shortName',
		'createdByUserGUID.type': 'createdByUser.type',
		'createdByUserGUID.avatarGUID': 'createdByUser.avatarGUID',
		'createdByUserGUID.tinyID': 'createdByUser.tinyID'
	},
	mDefaultSearchHowMany: 10,
	mDefaultSearchFields: ['tinyID', 'longName', 'themeInfo', 'shortName', 'type', 'createTime', 'updateTime', 'isFavorite', 'isDeleted', 'tags', 'avatarGUID', 'previewGUIDs', 'thumbnailGUIDs', 'iconGUID', 'description'],
	mDefaultSearchSortFields: ['+longName'],
	mDefaultActivityTotalResultLimit: 500,
	mDefaultActivitySubFields: {
		'entityGUID.longName': 'entityLongName',
		'entityGUID.shortName': 'entityShortName',
		'entityGUID.tinyID': 'entityTinyID',
		'entityGUID.type': 'entityType',
		'containerGUID.longName': 'ownerLongName',
		'containerGUID.shortName': 'ownerShortName',
		'containerGUID.tinyID': 'ownerTinyID',
		'containerGUID.type': 'ownerType',
		'containerGUID.avatarGUID': 'ownerAvatarGUID',
		'userGUID.longName': 'userLongName',
		'userGUID.shortName': 'userShortName',
		'userGUID.tinyID': 'userTinyID',
		'userGUID.type': 'userType',
		'userGUID.avatarGUID': 'userAvatarGUID'
	},
	mDefaultRecentDocumentsLimit: 5,
	mStore: new CC.Store.BackingStore(),
	initialize: function() {},
	// Store convenience function.
	objectFromStoreWithGUID: function(inGUID) {
		return this.mStore.workingCopyForGUID(inGUID);
	},
	// Default entities callback. Returns an array of store-added model objects.
	_defaultEntitiesCallback: function(inResponse, inCallback, inErrback) {
		if (inResponse && inResponse.response) {
			var response = $A(inResponse.response);
			var entities = this._parseAndStoreEntities(response);
			return inCallback(entities);
		}
		if (inErrback) return inErrback(inResponse);
	},
	// Default paginated entities callback. Takes a paginated response, and maps the result to models in the
	// local backing store. Returns a tuple of (results, startIndex, total, paginationGUID) which is enough to
	// request future windows in this paginated set. You shouldn't really call this manually.
	_defaultPaginatedEntitiesCallback: function(inResponse, inCallback, inErrback) {
		if (inResponse && inResponse.response) {
			var paginated = new CC.EntityTypes.PaginatedResult(inResponse.response);
			var models = this._parseAndStoreEntities(paginated.results);
			return inCallback(models, paginated.startIndex, paginated.total, paginated.guid);
		}
		return inErrback(inResponse);
	},
	// Default search callback. Returns an  array of search result objects (note that they
	// are not automatically added to the store).
	_defaultSearchResultsCallback: function(inResponse, inCallback, inErrback) {
		if (inResponse && inResponse.response) {
			var results = (inResponse.response.results || []);
			return inCallback(results);
		}
		if (inErrback) return inErrback(inResponse);
	},
	// Generic pagination method for paginating a service method, and pushing the results into the local backing
	// store. Note that the results must be valid entity_types models to be pushed into the store correctly. You
	// shouldn't really call this manually.
	_paginateAndStoreEntities: function(inServiceName, inMethodName, inArguments, inOptPaginationGUID, inOptPaginationStartIndex, inOptPaginationHowMany, inCallback, inErrback) {
		var _callback = function(response) {
			return this._defaultPaginatedEntitiesCallback(response, inCallback, inErrback);
		}.bind(this);
		service_client().paginateAsynchronously(inServiceName, inMethodName, inArguments, {}, inOptPaginationGUID, inOptPaginationStartIndex, inOptPaginationHowMany, _callback.bind(this), inErrback);
	},
	// Maps an array of JSON structures to model objects, and pushes them into the store.
	// Returns an array of store-based models. This should only be called for models you
	// want to retain in the server_proxy backing store.
	_parseAndStoreEntities: function(models) {
		var stored = [];
		if (models && models.length) {
			var model, storedModel;
			for (var modelIdx = 0; modelIdx < models.length; modelIdx++) {
				model = models[modelIdx];
				storedModel = this._parseAndStoreEntity(model);
				if (storedModel) stored.push(storedModel);
			}
		}
		return stored;
	},
	_parseSearchResultsAndStoreEntities: function(searchResults) {
		var stored = searchResults.collect(function(result) {
			var entity = this._parseAndStoreEntity(result.entity);
			entity.snippets = result.snippets;
			return entity;
		}, this);
		return stored;
	},
	_parseAndStoreEntity: function(model) {
		if (!model || !model.type || model.type == "com.apple.EntityPlaceholder") return;
		var entity = entity_types().entityForHash(model);
		var pushed = this.mStore.pushObject(entity);
		return pushed;
	},
	// Returns all entities for a given type.
	entitiesForType: function(inType, inCallback, inErrback) {
		var _callback = function(response) {
			return this._defaultEntitiesCallback(response, inCallback, inErrback);
		}.bind(this);
		return service_client().executeAsynchronously('ContentService', 'entitiesForType:', inType, {}, _callback, inErrback);
	},
	// Paginated version of entities for a given type.
	paginatedEntitiesForType: function(inType, inOptPaginationGUID, inOptPaginationStartIndex, inOptPaginationHowMany, inCallback, inErrback) {
		var _callback = function(response) {
			return this._defaultPaginatedEntitiesCallback(response, inCallback, inErrback);
		}.bind(this);
		service_client().paginateAsynchronously('ContentService', 'entitiesForType:', inType, {}, inOptPaginationGUID, inOptPaginationStartIndex, inOptPaginationHowMany, _callback, inErrback);
	},
	// Returns all document entities under a given container GUID.
	documentsForContainer: function(inGUID, inCallback, inErrback) {
		var _callback = function(response) {
			return this._defaultEntitiesCallback(response, inCallback, inErrback);
		}.bind(this);
		return service_client().executeAsynchronously('ContentService', 'entitiesForType:inContainerGUID:', ['com.apple.entity.Document', inGUID], {}, _callback, inErrback);
	},
	// Returns an entity by GUID.
	entityForGUID: function(inGUID, inCallback, inErrback) {
		return this.entityForGUIDWithOptions(inGUID, {}, inCallback, inErrback);
	},
	// Returns an entity by GUID with options.
	entityForGUIDWithOptions: function(inGUID, inOptions, inCallback, inErrback) {
		var _callback = function(service_response) {
			var response = service_response.response;
			var entity = this._parseAndStoreEntity(response);
			if (!entity) return inErrback(response);
			if (inCallback) inCallback(entity);
		}.bind(this);
		return service_client().executeAsynchronously('ContentService', 'entityForGUID:', inGUID, inOptions || {}, _callback, inErrback);
	},
	// Returns an array of entities by GUID.
	entitiesForGUIDs: function(inGUIDs, inCallback, inErrback) {
		return this.entitiesForGUIDsWithOptions(inGUIDs, {}, inCallback, inErrback);
	},
	// Returns an array of entities by GUID with options.
	entitiesForGUIDsWithOptions: function(inGUIDs, inOptions, inCallback, inErrback) {
		var _callback = function(response) {
			return this._defaultEntitiesCallback(response, inCallback, inErrback);
		}.bind(this);
		return service_client().executeAsynchronously('ContentService', 'entitiesForGUIDs:', [inGUIDs], inOptions || {}, _callback, inErrback);
	},
	entitiesForGUIDsWithInternalTags: function(inGUIDs, inCallback, inErrback) {
		return this.entitiesForGUIDsWithInternalTagsWithOptions(inGUIDs, {}, inCallback, inErrback);
	},
	entitiesForGUIDsWithInternalTagsWithOptions: function(inGUIDs, inOptions, inCallback, inErrback) {
		var _callback = function(response) {
			return this._defaultEntitiesCallback(response, inCallback, inErrback);
		}.bind(this);
		return service_client().executeAsynchronously('ContentService', 'entitiesForGUIDs:withInternalTags:', [inGUIDs, true], inOptions || {}, _callback, inErrback);
	},
	// Returns an entity by tinyID.
	entityForTinyID: function(inTinyID, inCallback, inErrback) {
		return this.entityForTinyIDWithOptions(inTinyID, {}, inCallback, inErrback);
	},
	// Returns an entity by tinyID with options.
	entityForTinyIDWithOptions: function(inTinyID, inOptions, inCallback, inErrback) {
		var _callback = function(service_response) {
			var response = service_response.response;
			var entity = this._parseAndStoreEntity(response);
			if (!entity) return inErrback(response);
			if (inCallback) inCallback(entity);
		}.bind(this);
		return service_client().executeAsynchronously('ContentService', 'entityForTinyID:', inTinyID, inOptions || {}, _callback, inErrback);
	},
	entityForLogin: function(inLogin, inCallback, inErrback) {
		return this.entityForLoginWithOptions(inLogin, {}, inCallback, inErrback)
	},
	entityForLoginWithOptions: function(inLogin, inOptions, inCallback, inErrback) {
		var _callback = function(service_response) {
			var response = service_response.response;
			var entity = this._parseAndStoreEntity(response);
			if (!entity) return inErrback(response);
			if (inCallback) inCallback(entity);
		}.bind(this);
		return service_client().executeAsynchronously('ContentService', 'bestGuessForUserEntityForLogin:', inLogin, inOptions || {}, _callback, inErrback);
	},
	entityForID: function(inID, inCallback, inErrback) {
		return this.entityForIDWithOptions(inID, {}, inCallback, inErrback);
	},
	entityForIDWithOptions: function(inID, inOptions, inCallback, inErrback) {
		// if it is a GUID, use that otherwise try login and tinyID
		if (looksLikeGUID(inID)) {
			return server_proxy().entityForGUIDWithOptions(inID, inOptions, inCallback, inErrback);
		}
		var _errback = function(result) {
			// assume error means we need to look it up differently
			return server_proxy().entityForLoginWithOptions(inID, inOptions, inCallback, inErrback);
		}
		return server_proxy().entityForTinyIDWithOptions(inID, inOptions, inCallback, _errback);
	},
	// repopulates the values of the meta tags for the current page
	refreshMetaTags: function(inCallback, inErrback) {
		var _callback = function(service_response) {
			for (var key in service_response.response)
			{
				if (service_response.response.hasOwnProperty(key))
					CC.setMeta(key, service_response.response[key]);
			}
			
			if (inCallback)
				inCallback();
			
			globalNotificationCenter().publish(CC.Meta.NOTIFICATION_DID_REFRESH_META_TAGS, server_proxy());
		};
		var entityID = (CC.meta('x-apple-entity-guid') == '') ? null : CC.meta('x-apple-entity-guid');
		var route = CC.meta('x-apple-route');
		return service_client().executeAsynchronously('AppContextService', 'metaTagsForEntityID:withRoute:', [entityID, route], {}, _callback, inErrback);
	},
	deleteEntityWithGUID: function(inGUID, permanently, inCallback, inErrback) {
		var methodName = permanently ? 'permanentlyDeleteEntityWithGUID:' : 'deleteEntityWithGUID:';
		return service_client().executeAsynchronously('ContentService', methodName, inGUID, {}, inCallback, inErrback);
	},
	undeleteEntityWithGUID: function(inGUID, inCallback, inErrback) {
		return service_client().executeAsynchronously('ContentService', 'undeleteEntityWithGUID:', inGUID, {}, inCallback, inErrback);
	},
	hideUserWithGUID: function(inGUID, inCallback, inErrback) {
		return service_client().executeAsynchronously('ContentService', 'hideUserWithGUID:', inGUID, {}, inCallback, inErrback);
	},
	unhideUserWithGUID: function(inGUID, inCallback, inErrback) {
		return service_client().executeAsynchronously('ContentService', 'unhideUserWithGUID:', inGUID, {}, inCallback, inErrback);
	},
	// move to a new owner
	moveEntityToOwner: function(inEntityGUID, inOwnerGUID, inCallback, inErrback) {
		var _updateCallback = function(inResult) {
			return service_client().executeAsynchronously('ContentService', 'removeACLsForEntityGUID:', inEntityGUID, {}, inCallback, inErrback);
		}
		var _getEntityCallback = function(inEntity) {
			var cs = new CC.EntityTypes.EntityChangeSet({
				'changeAction': "UPDATE",
				'entityGUID': inEntityGUID,
				'entityRevision': inEntity.revision,
				'entityType': inEntity.type,
				'changes': [["ownerGUID", inOwnerGUID]],
				'force': false
			});
			return server_proxy().updateEntityAndACLs(cs, null, _updateCallback, inErrback);
		}
		return server_proxy().entityForGUID(inEntityGUID, _getEntityCallback, inErrback);
	},
	// Returns the current revision for an entity with a given GUID as an Integer.
	revisionForEntityGUID: function(inGUID, inCallback, inErrback) {
		var _callback = function(service_response) {
			var response = service_response.response;
			var revision = (response) ? parseInt(response, 10) : null;
			if (inCallback) inCallback(revision);
		}.bind(this);
		return service_client().executeAsynchronously('ContentService', 'revisionForEntityGUID:', inGUID, {}, _callback, inErrback);
	},
	commentsForCommentGUIDs: function(inGUIDs, inCallback, inErrback) {
		var _callback = function(service_response) {
			var response = service_response.response;
			if (inCallback) inCallback(response);
		}.bind(this);
		return service_client().executeAsynchronously('ContentService', 'commentsForGUIDs:', [inGUIDs], {}, _callback, inErrback);
	},
	commentsAndCanICommentForGUID: function(inGUID, inCallback, inErrback) {
		var batch = [
			['ContentService', 'commentsForEntityGUID:', inGUID],
			['ContentService', 'canICommentOnEntityGUID:', inGUID]
		]
		return service_client().batchExecuteAsynchronously(batch, null, function(service_response) {
			if (service_response && service_response.responses) {
				var firstResponse = service_response.responses[0];
				var secondResponse = service_response.responses[1];
				var comments = server_proxy()._parseAndStoreEntities(firstResponse.response);
				var canIcomment = secondResponse.response;
				return inCallback(comments, canIcomment);
			}
			return inErrback(service_response);
		}.bind(this), inErrback);
	},
	addCommentToOwnerGUID: function(inText, inOwnerGUID, inCallback, inErrback) {
		var newComment = {
			type: 'com.apple.EntityComment',
			entityGUID: inOwnerGUID,
			body: inText
		};
		var entity = globalEditorController().mPage.mRecord;
		var href = window.location.protocol + "//" + window.location.host;
		var entityURL = href + CC.entityURLForTypeAndGUID(entity.type, entity.guid);
		var ownerURL = href + CC.entityURLForTypeAndGUID(entity.ownerType, entity.ownerGUID);
		var clientURL = "#entity_url:%@#owner_url:%@".fmt(entityURL, ownerURL);
		
		return service_client().executeAsynchronously('ContentService', 'addComment:', newComment, {'clientURL': clientURL}, inCallback, inErrback);
	},
	deleteCommentWithGUID: function(inCommentGUID, inCallback, inErrback) {
		return service_client().executeAsynchronously('ContentService', 'removeCommentWithGUID:', inCommentGUID, {}, inCallback, inErrback);	
	},
	approveCommentWithGUID: function(inCommentGUID, inCallback, inErrback) {
		return service_client().executeAsynchronously('ContentService', 'approveCommentWithGUID:', inCommentGUID, {}, inCallback, inErrback);	
	},
	approveCommentsWithGUIDs: function(inGUIDs, inCallback, inErrback) {
		if (!inGUIDs) return inErrback();
		var batch = [];
		for (var idx = 0; idx < inGUIDs.length; idx++) {
			batch.push(['ContentService', 'approveCommentWithGUID:', inGUIDs[idx]]);
		}
		return service_client().batchExecuteAsynchronously(batch, null, inCallback, inErrback);
	},
	// Returns an array of relationship objects.
	relationshipsForGUID: function(inGUID, inCallback, inErrback) {
		var _callback = function(response) {
			if (response && response.response) {
				// Iterate over each of the relationship tuples we got ([relationshipGUID, otherEntity]).
				var relationships = $A(response.response);
				var relationshipModels = new Array();
				var relationship, _relationship, relationshipModel;
				for (var rdx = 0; rdx < relationships.length; rdx++) {
					// First create a relationship model for each relationship.
					relationship = relationships[rdx];
					_relationship = {'guid': relationship[0], 'targetEntityGUID': relationship[1].guid, 'sourceEntityGUID': inGUID};
					relationshipModel = new CC.EntityTypes.RelatedRelationship(_relationship);
					relationshipModels.push(this.mStore.pushObject(relationshipModel));
					// Next push the target entity into the store. Note that you'll need to ask for these later if you want them.
					this._parseAndStoreEntity(relationship[1]);
				}
				if (inCallback) inCallback(relationshipModels);
			} else {
				if (inErrback) inErrback(response);
			}
		}.bind(this);
		return service_client().executeAsynchronously('ContentService', 'relatedEntitiesForGUID:withType:', [inGUID, 'com.apple.relationship.Related'], {}, _callback, inErrback);
	},
	relateEntities: function(guid1, guid2, inCallback, inErrback) {
		return service_client().executeAsynchronously('ContentService', 'relateEntityWithGUID:toEntityWithGUID:withType:', [guid1, guid2, 'com.apple.relationship.Related'], {}, inCallback, inErrback);
	},
	relationshipsForGUIDs: function(inGUIDs, inCallback, inErrback) {
 		var _callback = function(service_response) {
			var results = $A(service_response.response || []);
			return inCallback(results);
 		};
		var guids = inGUIDs || [];
		return service_client().executeAsynchronously('ContentService', 'relationshipsForGUIDs:', [guids], {}, _callback, inErrback);
	},
	deleteRelationship: function(relationshipGUID, inCallback, inErrback) {
		return service_client().executeAsynchronously('ContentService', 'deleteRelationshipWithGUID:', relationshipGUID, {}, inCallback, inErrback);
	},
	// Recent documents helper.  Note these methods deliberately don't push results in to the store since the results
	// have no referenced objects or subproperties expanded.  Also note the difference - recentEntitiesForUser returns
	// recent entities for the currently logged in user.  Recent documents uses search to list the last updated entities.
	recentEntitiesForUserWithLimitAndOptions: function(inLimit, inOptions, inCallback, inErrback) {
 		var _callback = function(service_response) {
			var results = $A(service_response.response || []);
			return inCallback(results);
 		};
		return service_client().executeAsynchronously('ContentService', 'recentEntitiesWithLimit:', (inLimit || this.mDefaultRecentDocumentsLimit), (inOptions || {}), _callback, inErrback);
	},
	recentEntitiesForUserForOwnerGUIDWithLimitAndOptions: function(inOwnerGUID, inLimit, inOptions, inCallback, inErrback) {
 		var _callback = function(service_response) {
			var results = $A(service_response.response || []);
			return inCallback(results);
 		};
		return service_client().executeAsynchronously('ContentService', 'recentEntitiesForOwnerGUID:withLimit:', inOwnerGUID, (inLimit || this.mDefaultRecentDocumentsLimit), (inOptions || {}), _callback, inErrback);
	},
	recentDocumentsWithOptions: function(inLimit, inOptions, inCallback, inErrback) {
		return this.recentDocumentsInOptOwnerWithOptions(inLimit, undefined, inOptions, inCallback, inErrback);
	},
	recentDocumentsInOptOwnerWithOptions: function(inLimit, inOptOwnerGUID, inOptions, inCallback, inErrback) {
		var query = this.searchQuery(undefined, ['com.apple.entity.Page', 'com.apple.entity.File'], 0, (inLimit || this.mDefaultRecentDocumentsLimit), undefined);
		this.searchQueryUpdateSort(query, '-lastActivityTime');
		if (inOptOwnerGUID) query = this.searchQueryUpdateOwnerGUID(query, inOptOwnerGUID);
		var _callback = function(service_response) {
			var results = new Array();
			if (service_response.response && service_response.response.results) {
				results = $A(service_response.response.results).collect(function(result) {
					return result.entity;
				});
			}
			return inCallback(results.without(undefined));
		}.bind(this);
		return service_client().executeAsynchronously('SearchService', 'query:', query, (inOptions || {}), _callback, inErrback);
	},
	addTagForOwner: function(inTag, inOwnerGUID, inCallback, inErrback) {
		if (!inTag.match(/\S/)) {
			inErrback({error:"Cannot add an empty tag"});
			return;
		}
		return service_client().executeAsynchronously('ContentService', 'addTag:toEntityWithGUID:', [inTag, inOwnerGUID], {}, inCallback, inErrback);
	},
	deleteTagForOwner: function(inTag, inOwnerGUID, inCallback, inErrback) {
		return service_client().executeAsynchronously('ContentService', 'deleteTag:inOwnerGUID:', [inTag, inOwnerGUID], {}, inCallback, inErrback);
	},
	subscriptionsForEntity: function(inGUID, inCallback, inErrback) {
		return service_client().executeAsynchronously('ContentService', 'subscriptionsForEntity:', inGUID, {}, inCallback, inErrback);
	},
	subscribeToEntityWithType: function(inGUID, inType, inCallback, inErrback) {
		return service_client().executeAsynchronously('ContentService', 'subscribeToEntity:withType:', [inGUID, inType], {}, inCallback, inErrback);
	},
	unsubscribeToEntityWithType: function(inGUID, inType, inCallback, inErrback) {
		return service_client().executeAsynchronously('ContentService', 'unsubscribeFromEntity:withType:', [inGUID, inType], {}, inCallback, inErrback);
	},
	// Creates a new page entity with a given set of page options and ACLs.
	createPageWithOptionsAndOptionalACLs: function(inOptions, inOptAcls, inCallback, inErrback) {
		var gotCurrentUser = function(currentUser) {
			// Figure out a title and whether this page is a blog post.
			var longName = (inOptions.longName || "_Page.Default.Title".loc());
			var isBlogpost = (inOptions.isBlogpost || false);
			// Did we get passed an explicit ownerGUID for the page? Fall back to the current user GUID.
			var currentUserGUID = currentUser.guid;
			var ownerGUID = (inOptions.ownerGUID ? inOptions.ownerGUID : currentUserGUID);
			var _page = {'longName': longName, 'isBlogpost': isBlogpost};
			var page = new CC.EntityTypes.PageEntity(_page);
			var variables = {'ownerGUID': ownerGUID, 'longName': longName};
			var language = globalLocalizationManager().getLprojLocale();
			// Build a batch (including ACLs if the owner is the current user and the current user is authenticated).
			var batched = [];
			if (inOptAcls) {
				batched.push(['ContentService', 'createEntitiesFromTemplate:withData:andVariables:andACL:andLanguage:', ['wiki_page', page, variables, inOptAcls, language], {}]);
			} else if ((currentUser && currentUser.isAuthenticated) && (ownerGUID == currentUserGUID)) {
				var acl = new CC.EntityTypes.EntityACL({
					'userLogin': currentUser.login,
					'userLongName': currentUser.longName,
					'userExternalID': currentUser.externalID,
					'action': 'own',
					'allow': true
				});
				batched.push(['ContentService', 'createEntitiesFromTemplate:withData:andVariables:andACL:andLanguage:', ['wiki_page', page, variables, [acl], language], {}]);
			} else {
				batched.push(['ContentService', 'createEntitiesFromTemplate:withData:andVariables:andACL:andLanguage:', ['wiki_page', page, variables, null, language], {}]);
			}
			// Unhide the creating user if they're hidden.
			if (currentUser && currentUser.isHidden && currentUser.isAuthenticated) {
				batched.push(['ContentService', 'unhideUserWithGUID:', currentUser.guid, {'hints': {'activity.ignore': true}}]);
			}
			// Define a callback.
			var _callback = function(service_response) {
				if (service_response && service_response.responses) {
					var firstResponse = service_response.responses[0];
					var entities = firstResponse.response;
					if (entities && entities[0]) {
						var storedModel = this._parseAndStoreEntity(entities[0]);
						// Immediately kick the preview queue.
						service_client().executeAsynchronously('PagePreviewService', 'kickPreviewQueue', null, Prototype.emptyFunction, Prototype.emptyFunction);
						return inCallback(storedModel);
					}
				}
				return inErrback(service_response);
			};
			// Create the page.
			return service_client().batchExecuteAsynchronously(batched, {}, _callback.bind(this), inErrback);
			
		}.bind(this);
		return sessions().currentUserAsynchronously(gotCurrentUser, inErrback);
	},
	// Creates a new project entity with a given set of project options and ACLs.
	createProjectWithOptionsAndACLs: function(inOptions, inACLs, inCallback, inErrback) {
		// Start by creating three GUIDs we can use in the batch.
		var projectGUID = (new CC.GuidBuilder()).toString();
		var detailPageGUID = (new CC.GuidBuilder()).toString();
		var blogGUID = (new CC.GuidBuilder()).toString();
		// Build up the batch by creating the project, detail page, blog and setting the project ACLs.
		var longName = (inOptions.longName || "_Project.Default.Title".loc());
		var tinyID = longName.strip().gsub(/[^\w]/, "").toLowerCase();
		if (tinyID == "") tinyID = null;
		var description = (inOptions.description || "");
		var extendedAttributes = (inOptions.extendedAttributes || {});
		var _project = {
			'guid': projectGUID,
			'tinyID': tinyID,
			'shortName': tinyID,
			'longName': longName,
			'description': description,
			'extendedAttributes': extendedAttributes,
			'detailPageGUID': detailPageGUID,
			'blogGUID': blogGUID
		}
		if (inOptions.themeInfo) _project['themeInfo'] = inOptions.themeInfo;
		if (inOptions.avatarGUID) _project['avatarGUID'] = inOptions.avatarGUID;
		var project = new CC.EntityTypes.WikiEntity(_project);
		project.setCommentAccessLevel(CC.EntityMixins.COMMENT_ACCESS_DEFAULT);
		project.setCommentModerationLevel(CC.EntityMixins.COMMENT_MODERATION_DEFAULT);
		var blogEntity = new CC.EntityTypes.BlogEntity({
			'guid': blogGUID,
			'longName': "_Blog.Default.Title".loc(),
			'ownerGUID': projectGUID
		});
		var language = globalLocalizationManager().getLprojLocale();
		var batched = [
			['ContentService', 'createEntity:', project],
			['ContentService', 'createEntitiesFromTemplate:withData:andVariables:andACL:andLanguage:', ['wiki_home', {}, {'guid': detailPageGUID, 'ownerGUID': projectGUID, 'longName': longName}, null, language], {'hints': {'activity.ignore': true}}],
			['ContentService', 'createEntity:', blogEntity, {'hints': {'activity.ignore': true}}],
			['ContentService', 'setACLs:forEntityGUID:', [inACLs, projectGUID], {'hints': {'activity.ignore': true}}]
		];
		// Define a callback.
		var _callback = function(service_response) {
			if (service_response && service_response.responses) {
				var firstResponse = service_response.responses[0];
				if (firstResponse) {
					var storedModel = this._parseAndStoreEntity(firstResponse.response);
					service_client().executeAsynchronously('PagePreviewService', 'kickPreviewQueue', null, Prototype.emptyFunction, Prototype.emptyFunction);
					return inCallback(storedModel);
				}
			}
			return inErrback(service_response);
		};
		// Create the project in a batch.
		return service_client().batchExecuteAsynchronously(batched, {'expandReferencedObjects': false}, _callback.bind(this), inErrback);
	},
	createEntity: function(inEntity, inCallback, inErrback) {
		return service_client().executeAsynchronously('ContentService', 'createEntity:', inEntity, {}, inCallback, inErrback);
	},
	updateEntity: function(inChangeset, inCallback, inErrback) {
		return service_client().executeAsynchronously('ContentService', 'updateEntity:', inChangeset, {}, function(service_response) {
			if (service_response && service_response.response) {
				var model = this._parseAndStoreEntity(service_response.response);
				return inCallback(model);
			}
			return inErrback(service_response);
		}.bind(this), inErrback);
	},
	updateEntityAndACLs: function(changeset, acls, inCallback, inErrback) {
		var batch = [
			['ContentService', 'updateEntity:', changeset]
		];
		if (acls) {
			batch.push(['ContentService', 'setACLs:forEntityGUID:', [acls, changeset.entityGUID]]);
		}
		return service_client().batchExecuteAsynchronously(batch, {'expandReferencedObjects': false}, function(service_response){
			if (service_response && service_response.responses) {
				var firstResponse = service_response.responses[0];
				this._parseAndStoreEntity(firstResponse.response);
				return inCallback();
			}
			return inErrback(service_response);
		}.bind(this), inErrback);
	},
	saveQueryAsSavedSearchWithName: function(inQuery, inName, inCallback, inErrback) {
		var savedSearch = new CC.EntityTypes.SavedQuery({
			'longName': (inName || ""),
			'query': inQuery
		});
		return server_proxy().createEntity(savedSearch, inCallback, inErrback);
	},
	savedSearchesForCurrentUser: function(inCallback, inErrback) {
		sessions().currentUserAsynchronously(function(currentUser) {
			if (currentUser && currentUser.isAuthenticated) {
				var query = {
					entityTypes: ['com.apple.entity.SavedQuery'],
					query: {
						match: currentUser.guid,
						field: 'ownerGUID',
						exact: true
					},
					sortFields: ['-updateTime'],
					fields: ['type', 'longName', 'query']
				};
				return this.entitiesForSearchQuery(query, inCallback, inErrback);
			}
			return inCallback([]);
		}.bind(this), inErrback);
	},
	// Quick search keyword/type search.
	entitiesForQuickSearch: function(inKeyword, inTypes, inCallback, inErrback) {
		if (!inTypes) inTypes = ['com.apple.entity.File', 'com.apple.entity.Page'];
		var aQuery = this.searchQuery(inKeyword, inTypes, 0, 5);
		this.searchQueryUpdateSort(aQuery, '-rank');
		this.entitiesForSearchQuery(aQuery, inCallback, inErrback);
	},
	// Returns an array of entities matching a query.
	entitiesForSearchQuery: function(inQuery, inCallback, inErrback) {
		return this.entitiesForSearchQueryWithOptions(inQuery, undefined, inCallback, inErrback);
	},
	entitiesForSearchQueryWithOptions: function(inQuery, inOptions, inCallback, inErrback) {
		var _callback = function(response) {
			return this._defaultSearchResultsCallback(response, inCallback, inErrback);
		}.bind(this);
		return service_client().executeAsynchronously('SearchService', 'query:', inQuery, (inOptions || {}), _callback, inErrback);
	},
	entitiesForSavedSearch: function(inSavedSearchGUID, inCallback, inErrback) {
		var _savedSearchCallback = function(response) {
			this.entitiesForSearchQuery(response.query, inCallback, inErrback);
		}.bind(this);
		return this.entityForGUID(inSavedSearchGUID, _savedSearchCallback, inErrback);
	},
	// Returns a JSON-format search query.
	searchQuery: function(inKeywords, inTypes, inStartIndex, inHowMany, inOptSearchGUID) {
		var queryNode = null;
		var keywords = [];
		if (inKeywords) keywords = Object.isArray(inKeywords) ? inKeywords: [inKeywords];
		if (keywords.length) {
			queryNode = {};
			var andNode = queryNode['and'] = [];
			$A(keywords).each(function(keyword) {
				if (keyword && keyword != "") {
					andNode.push({
						'match': keyword
					});
				}
			});
		}
		var entityTypes = [];
		if (inTypes) entityTypes = Object.isArray(inTypes) ? inTypes: [inTypes];
		return {
			'guid': inOptSearchGUID,
			'query': queryNode,
			'fields': this.mDefaultSearchFields,
			'subFields': this.mDefaultSubpropertyPaths,
			'sortFields': this.mDefaultSearchSortFields,
			'range': [(inStartIndex || 0), (inHowMany || this.mDefaultSearchHowMany)],
			'entityTypes': entityTypes,
			'onlyDeleted': false
		};
	},
	searchQueryForTags: function(inTags, inTypes, inStartIndex, inHowMany, inOptSearchGUID) {
    	var aQuery = this.searchQuery("", inTypes, inStartIndex, inHowMany, inOptSearchGUID);
    	return this.addTagsToQuery(aQuery, inTags);
	},
	addTagsToQuery: function(inTags, inQuery) {
		var tags = (inTags == undefined) ? [] : (Object.isArray(inTags) ? inTags: [inTags]);
		if (tags.length) {
			var andNode = ((inQuery.query ? inQuery.query['and'] : []) || []);
			$A(tags).each(function(tag) {
				if (tag && tag != "") {
					andNode.push({
						match: tag,
						field: 'tags',
						exact: true
					});
				}
			});
			if (!inQuery.query) inQuery.query = {};
			inQuery.query['and'] = andNode;
		}
		return inQuery;
	},
	searchQueryAddToOrNode: function(inQuery, inItem) {
		return this.searchQueryAddToTypedNode('or', inQuery, inItem);
	},
	searchQueryAddToAndNode: function(inQuery, inItem) {
		return this.searchQueryAddToTypedNode('and', inQuery, inItem);
	},
	searchQueryAddToTypedNode: function(inType, inQuery, inItem) {
		var types = ['or', 'and'];
		
		if (types.indexOf(inType) != -1) {
			var typedNode = ((inQuery.query ? inQuery.query[inType] : []) || []);
			var hasNodeAlready = false;
			if (inItem) {
				if (inItem.field) {
					for (var a = 0; a < typedNode.length; a++) {
						var node = typedNode[a];
						if (node.field && node.field == inItem.field && node.match == inItem.match) {
							hasNodeAlready = true;
						}
					}
				}
			
				if(!hasNodeAlready) {
					typedNode.push(inItem);
				}
			}
			
			if (!inQuery.query) inQuery.query = {};
			inQuery.query[inType] = typedNode;
			return inQuery;
		}
		else {
			return null;
		}
		
	},
	searchQueryCreateNode: function(inFieldName, inMatchValue, inExact) {
		var node = {
			match: inMatchValue,
			field: inFieldName,
			exact: (inExact == true)
		}
		return node;
	},
	searchQueryCreateOrArray: function(inArrayOfNodes) {
		var orNode = {
			or: []
		};
		
		if (inArrayOfNodes) {
			for (var i = 0; i < inArrayOfNodes.length; i++) {
				var node = inArrayOfNodes[i];
				orNode.or.push(node);
			}
		}
		return orNode;
	},
	searchQueryCreateAndArray: function(inArrayOfNodes) {
		var andNode = {
			and: []
		};
		
		if (inArrayOfNodes) {
			for (var i = 0; i < inArrayOfNodes.length; i++) {
				var node = inArrayOfNodes[i];
				andNode.and.push(node);
			}
		}
		return andNode;
	},
	searchQueryUpdateSort: function(inQuery, inSortField) {
		inQuery.sortFields = [inSortField];
		return inQuery;
	},
	searchQueryFavoritesOnly: function(inQuery, inFavoritesOnly) {
		var andNode, _andNode;
		var oldAndNode = (inQuery.query ? inQuery.query['and'] || [] : []);
		var markedExistingAndNode = false;
		for (var nodeIdx = 0; nodeIdx < oldAndNode.length; nodeIdx++) {
			if (!andNode) andNode = inQuery.query['and'] = [];
			_andNode = oldAndNode[nodeIdx];
			if (_andNode && _andNode.field == 'isFavorite') {
				andNode[nodeIdx] = {match: (inFavoritesOnly == true), field: 'isFavorite'};
				markedExistingAndNode = true;
			} else {
				andNode[nodeIdx] = _andNode;
			}
		}
		if (!markedExistingAndNode && inFavoritesOnly) {
			if (!andNode) andNode = [];
			andNode.push({match: true, field: 'isFavorite'});
		}
		if (andNode) {
			if (!inQuery.query) inQuery.query = {};
			inQuery.query['and'] = andNode;
		}
		return inQuery;
	},
	searchQueryUpdateContainerGUID: function(inQuery, inContainerGUID) {
		return this.__updateQueryForContainerOrOwnerGUID(inQuery, 'containerGUID', inContainerGUID);
	},
	searchQueryUpdateOwnerGUID: function(inQuery, inOwnerGUID) {
		return this.__updateQueryForContainerOrOwnerGUID(inQuery, 'ownerGUID', inOwnerGUID);
	},
	__updateQueryForContainerOrOwnerGUID: function(inQuery, inContainerOrOwnerKey, inContainerOrOwnerValue) {
		if (inContainerOrOwnerKey && inContainerOrOwnerValue) {
			// Expand out entityTypes to individual nodes in an OR clause.
			if (!inQuery.query) inQuery.query = {};
			if (!inQuery.query['and']) inQuery.query['and'] = [];
			var andNode = inQuery.query['and'];
			var orNode = [];
			var entityTypes = (inQuery.entityTypes || []);
			if (entityTypes.length) {
				for (var tdx = 0; tdx < entityTypes.length; tdx++) {
					orNode.push({match: entityTypes[tdx], field: 'type', exact: true});
				}
				andNode.push({'or': orNode});
			}
			delete inQuery.entityTypes;
			// Push the new container or owner key.
			andNode.push({match: inContainerOrOwnerValue, field: inContainerOrOwnerKey, exact: true});
		}
		return inQuery;	
	},
	// Fetches activity (for an optional user or container GUID) from a given start index.	Accepts an
	// optional inOptPaginationGUID argument that triggers use of a cached pagination result on the server.
	paginatedActivity: function(inOptUserGUID, inOptOwnerGUID, inOptContainerGUID, inOptPaginationGUID, inOptPaginationStartIndex, inOptPaginationHowMany, inOptPaginationOnlyFavorites, inOptPaginationOnlyUnread, inOptPaginationOnlyWatched, inOptPaginationStartTime, inCallback, inErrback) {
		var query = {
			type: 'com.apple.UserActivityQuery',
			userGUID: inOptUserGUID,
			startIndex: 0, // The outer pagination request will take care of moving the pagination window.
			resultsLimit: this.mDefaultActivityTotalResultLimit,
			containerGUID: inOptContainerGUID,
			ownerGUID: inOptOwnerGUID,
			subFields: this.mDefaultActivitySubFields,
			onlyFavorites: (inOptPaginationOnlyFavorites || false),
			onlyUnread: (inOptPaginationOnlyUnread || false),
			onlyWatched: (inOptPaginationOnlyWatched || true),
			startTime: inOptPaginationStartTime
		};
		var _callback = function(response) {
			return this._defaultPaginatedEntitiesCallback(response, inCallback, inErrback);
		}.bind(this);
		service_client().paginateAsynchronously('ContentService', 'userActivity:', query, {}, inOptPaginationGUID, inOptPaginationStartIndex, inOptPaginationHowMany, _callback, inErrback);
	},
	paginatedSearchQuery: function(inQuery, inOptPaginationGUID, inOptPaginationStartIndex, inOptPaginationHowMany, inCallback, inErrback) {
		var _callback = function(service_response) {
			if (service_response && service_response.response) {
				var paginated = new CC.EntityTypes.PaginatedResult(service_response.response);
				var searchResult = new CC.EntityTypes.SearchResult(paginated.results[0]);
				var models = this._parseSearchResultsAndStoreEntities(searchResult.results);
				return inCallback(models, paginated.startIndex, paginated.total, paginated.guid);
			}
			return inErrback(service_response);
		}.bind(this);
		return service_client().entitiesForSearchQuery(inQuery, _callback, inErrback);
	},
	// Favorites/unread support.
	addEntityToFavorites: function(inGUID, inCallback, inErrback) {
		return service_client().executeAsynchronously('ContentService', 'addEntityToFavorites:', inGUID, {}, inCallback, inErrback);
	},
	removeEntityFromFavorites: function(inGUID, inCallback, inErrback) {
		return service_client().executeAsynchronously('ContentService', 'removeEntityFromFavorites:', inGUID, {}, inCallback, inErrback);
	},
	markEntityAsRead: function(inGUID, inCallback, inErrback) {
		return service_client().executeAsynchronously('ContentService', 'markEntityAsRead:', inGUID, {}, inCallback, inErrback);
	},
	markEntityAsUnread: function(inGUID, inCallback, inErrback) {
		return service_client().executeAsynchronously('ContentService', 'markEntityAsUnread:', inGUID, {}, inCallback, inErrback);
	},
	markAllAsRead: function(inCallback, inErrback) {
		return service_client().executeAsynchronously('ContentService', 'markAllEntitiesAsRead', [], {}, inCallback, inErrback);
	},
	// Watched support.
	watchEntity: function(inGUID, inCallback, inErrback) {
		return service_client().executeAsynchronously('ContentService', 'addEntityToWatchlist:', inGUID, {}, inCallback, inErrback);
	},
	unwatchEntity: function(inGUID, inCallback, inErrback) {
		return service_client().executeAsynchronously('ContentService', 'removeEntityFromWatchlist:', inGUID, {}, inCallback, inErrback);
	},
	// acls
	aclsForEntityGUID: function(inGUID, inCallback, inErrback) {
		return service_client().executeAsynchronously('ContentService', 'aclsForEntityGUID:', inGUID, {}, function(service_response) {
			var acls = service_response.response;
			inCallback(acls);
		}.bind(this), inErrback);
	},
	setACLsOnEntity: function(sharedNotificationList, inACLs, inGUID, inCallback, inErrback) {
		
		// Send clientURL info to server for document link information used in notification emails (shared document notification, etc).
		var href = window.location.protocol + "//" + window.location.host;
		var entityURL = href + CC.entityURLForTypeAndGUID(CC.meta('x-apple-entity-type'), CC.meta('x-apple-entity-guid'));
		var ownerURL = href + CC.entityURLForTypeAndGUID(CC.meta('x-apple-owner-type'), CC.meta('x-apple-owner-guid'));
		var clientURL = "#entity_url:%@#owner_url:%@".fmt(entityURL, ownerURL);
				
		if (!inACLs || inACLs.length == 0) return inErrback();
		return service_client().executeAsynchronously('ContentService', 'setACLs:with:forEntityGUID:', [sharedNotificationList, inACLs, inGUID], {'clientURL': clientURL}, inCallback, inErrback);
	},
	accessToEntityWithGUID: function(inGUID, inCallback, inErrback) {
		return service_client().executeAsynchronously('ContentService', 'accessToEntityWithGUID:', inGUID, {}, function(service_response) {
			var access = service_response.response;
			inCallback(access);
		}, inErrback);
	},
	odRecordsMatching: function(inKeyword, inCallback, inErrback) {
		var _callback = function(service_response) {
			var response = service_response.response;
			var rawRecords = (response) ? response : [];
			var records = rawRecords.collect(function(aRawRecord) {
				var aRecord = {
					login: aRawRecord.login,
					externalID: aRawRecord.externalID,
					longName: aRawRecord.longName
				};
				return aRecord;
			});
			if (inCallback) inCallback(records);
		}.bind(this);
		return service_client().executeAsynchronously('ODService', 'odRecordsMatching:', inKeyword, {}, _callback, inErrback);
	},
	detailPageWithContainerAndPermissionForID: function(inID, inCallback, inErrback) {
		// gets a container and its detail page
		var options =  {'expandReferencedObjects': false, 'subpropertyPaths': this.mDefaultSubpropertyPaths};
		var _callback = function(aModel) {
			var anEntity = server_proxy()._parseAndStoreEntity(aModel);
			if (!anEntity) return inErrback({responses:[aModel]});
			// Fetch the detail page for this entity.
			var detailPageGUID = anEntity.detailPageGUID;
			server_proxy().entityForIDWithOptions(detailPageGUID, {}, function(detailPage) {
				// Next grab the permissions.
				server_proxy().accessToEntityWithGUID(anEntity.guid, function (inAccess) {
					inCallback(detailPage, anEntity, server_proxy()._accessForString(inAccess));
				}, inErrback);
			}, inErrback);
		}.bind(this);
		server_proxy().entityForIDWithOptions(inID, options, _callback, inErrback);
	},
	documentWithContainerAndPermissionForID: function(inID, inCallback, inErrback) {
		// gets a document and it's container
		var options =  {'expandReferencedObjects': false, 'subpropertyPaths': this.mDefaultSubpropertyPaths};
		var _callback = function(aModel) {
			var anEntity = server_proxy()._parseAndStoreEntity(aModel);
			if (!anEntity) return inErrback({responses:[aModel]});
			// Fetch the container for this entity.
			var containerGUID = anEntity.containerGUID;
			server_proxy().entityForIDWithOptions(containerGUID, {}, function(container) {
				// Next grab the permissions.
				server_proxy().accessToEntityWithGUID(container.guid, function (inAccess) {
					inCallback(anEntity, container, server_proxy()._accessForString(inAccess));
				}, inErrback);
			}, inErrback);
		}.bind(this);
		// document first
		server_proxy().entityForIDWithOptions(inID, options, _callback, inErrback);
	},
	serverHomepageDocument: function(inCallback, inErrback) {
		// grab the server home page document
		var _callback = function(document, permissions) {
			// get permissions
			var anEntity = server_proxy()._parseAndStoreEntity(document);
			if (!anEntity) return inErrback({responses:[document]});
			server_proxy().accessToEntityWithGUID(anEntity.guid, function (inAccess) {
					inCallback(document, server_proxy()._accessForString(inAccess));
				}, inErrback);
		}.bind(this);
		server_proxy().entityForIDWithOptions('serverhome', {}, _callback, inErrback);
	},
	permissionsForUser: function(inCallback, inErrback) {
		sessions().currentUserAsynchronously(function(currentUser) {
			var batch = [
				['ContentService', 'canICreateProjects'],
				['ContentService', 'amIAnAdmin']
			];
			return service_client().batchExecuteAsynchronously(batch, null, function(service_response) {
				if (service_response && service_response.responses) {
					var firstResponse = service_response.responses[0];
					var secondResponse = service_response.responses[1];
					var userPermissions = {
						isLoggedIn : currentUser.isAuthenticated,
						canCreateWikis : firstResponse.response,
						isAdmin : secondResponse.response
					}
					if (inCallback) return inCallback(userPermissions);
				}
				if (inErrback) return inErrback(service_response);
			}, inErrback);
		}, inErrback);
	},
	_accessForString: function(inString) {
		return {
			canRead : (inString == 'read') || (inString == 'write') || (inString == 'own'),
			canWrite : (inString == 'write') || (inString == 'own'),
			owns : (inString == 'own')
		};
	},
	preferredEmailAddressForUser: function(inCallback, inErrback) {
		sessions().currentUserAsynchronously(function(currentUser) {
			var callback = function(result) {
				var email = "";
				if (result.privateAttributes) {
					email = result.privateAttributes.preferredEmailAddress ? result.privateAttributes.preferredEmailAddress : result.privateAttributes.defaultDirectoryEmailAddress;
				}
				if (email == undefined) {
					email = "";
				}
				return inCallback(email);
			}
			return server_proxy().entityForGUID(currentUser.guid, callback, inErrback);
		}, inErrback);
	},
	tagsForEntityGUID: function(inGUID, inCallback, inErrback) {
		return service_client().executeAsynchronously('ContentService', 'tagsForEntityGUID:', [inGUID], {}, function(service_response){
			if (service_response && service_response.succeeded) {
				return inCallback(service_response.response || []);
			}
			return inErrback(service_response);
		}, inErrback);
	},
	removeTagFromEntityWithGUID: function(inTag, inGUID, inCallback, inErrback) {
		return service_client().executeAsynchronously('ContentService', 'removeTag:fromEntityWithGUID:', [inTag, inGUID], {}, function(service_response){
			if (service_response && service_response.succeeded) {
				return inCallback(service_response);
			}
			return inErrback(service_response);
		}, inErrback);
	},
	allTags: function(inCallback, inErrback) {
		return service_client().executeAsynchronously('ContentService', 'allTags', [], {}, function(service_response){
			if (service_response && service_response.response) {
				return inCallback(service_response.response);
			}
			return inErrback(service_response);
		}, inErrback);
	},
	allTagsOwnedByGUID: function(inGUID, inCallback, inErrback) {
		return service_client().executeAsynchronously('ContentService', 'allTagsOwnedByGUID:', [inGUID], {}, function(service_response){
			if (service_response && service_response.response) {
				return inCallback(service_response.response);
			}
			return inErrback(service_response);
		}, inErrback);
	},
	allTagsStartingWith: function(tagPrefix, inCallback) {
		return service_client().executeAsynchronously('ContentService', 'allTagsStartingWith:', tagPrefix, {}, function(service_response){
			if (service_response && service_response.response) {
				return inCallback(service_response.response);
			}
		}, function(){
			logger.error("Could not fetch all tags starting with " + tagPrefix);
		});
	},
	replaceTagWithTagInOwnerGUID: function(firstTag, secondTag, ownerGUID, inCallback, inErrback) {
		return service_client().executeAsynchronously('ContentService', 'replaceTag:withTag:inOwnerGUID:', [firstTag, secondTag, ownerGUID], {}, function(service_response){
			if (service_response && service_response.succeeded) {
				return inCallback(service_response);
			}
			return inErrback(service_response);
		}, inErrback);
	},
	globallyReplaceTagWithTag: function(oldTag, newTag, inCallback, inErrback) {
		return service_client().executeAsynchronously('ContentService', 'globallyReplaceTag:WithTag:', [oldTag, newTag], {}, function(service_response){
			if (service_response && service_response.succeeded) {
				return inCallback(service_response);
			}
			return inErrback(service_response);
		}, inErrback);
	},
	deleteTagInOwnerGUID: function(inTag, ownerGUID, inCallback, inErrback) {
		return service_client().executeAsynchronously('ContentService', 'deleteTag:inOwnerGUID:', [inTag, ownerGUID], {}, function(service_response){
			if (service_response && service_response.succeeded) {
				return inCallback(service_response);
			}
			return inErrback(service_response);
		}, inErrback);
	},
	globallyDeleteTag: function(inTag, inCallback, inErrback) {
		return service_client().executeAsynchronously('ContentService', 'globallyDeleteTag:', [inTag], {}, function(service_response){
			if (service_response && service_response.succeeded) {
				return inCallback(service_response);
			}
			return inErrback(service_response);
		}, inErrback);
	},
	// Search tracking support. Returns a GUID to record a search by. You should pass an identical
	// query to the one you're using to search by.
	recordQuery: function(inQuery, inCallback, inErrback) {
		return service_client().executeAsynchronously('SearchService', 'recordQuery:', inQuery, {}, function(service_response) {
			if (service_response && service_response.response) {
				if (inCallback) return inCallback(service_response.response);
			}
		}, (inErrback || Prototype.emptyFunction));
	},
	// Records a click on a specific result for a in-progress query.
	recordClickInResultsWithGUID: function(inRecordedQueryGUID, inIndex, inSnippets, inClickedEntityGUID /*, No callbacks */) {
		var args = [inRecordedQueryGUID, (inIndex != undefined ? inIndex : -1), (inSnippets || {}), inClickedEntityGUID]
		return service_client().executeAsynchronously('SearchService', 'recordClickInResultsWithGUID:atIndex:withSnippets:andEntityGUID:', args, {}, Prototype.emptyFunction, Prototype.emptyFunction);
	},
	// Returns an array of revisions for a given entity GUID.
	revisionsForGUID: function(inGUID, inCallback, inErrback) {
		return service_client().executeAsynchronously('ContentService', 'pastEntitiesForGUID:withChangeTypes:onlyFields:', [inGUID, ['create', 'edit', 'delete', 'undelete', 'restore'], []], {}, inCallback, inErrback);
	},
	pastEntityForGUIDAtRevision: function(inGUID, inRevision, inCallback, inErrback) {
		var _callback = function(service_response) {
			var result = service_response.response;
			if (result.dataGUID) {
				// we've got a file revision, fetch the file data of that revision
				var dataCallback = function(dataResponse) {
					result.mediaType = dataResponse.mediaType;
					result.contentType = dataResponse.contentType;
					result.isQuickLookable = dataResponse.isQuickLookable;
					result.iconGUID = dataResponse.iconGUID;
					result.thumbnailGUIDs = dataResponse.thumbnailGUIDs;
					result.previewGUIDs = dataResponse.previewGUIDs;
					
					var revision = entity_types().entityForHash(result);
					inCallback(revision);
				}
				server_proxy().entityForGUID(result.dataGUID, dataCallback, function(response) {logger.error("Error getting entity for revision");});
			} else {
				var revision = entity_types().entityForHash(result);
				inCallback(revision);
			}
		}
		return service_client().executeAsynchronously('ContentService', 'pastEntityForGUID:atRevision:', [inGUID, inRevision], {}, _callback, inErrback);
	},
	pastEntitiesForGUIDAndRevisionsWithChangeTypesOnlyFields: function(inGUID, inRevisions, inChangeTypes, inOnlyFields, inCallback, inErrback) {
		var changeTypes = (inChangeTypes || []);
		var onlyFields = (inOnlyFields || []);
		return service_client().executeAsynchronously('ContentService', 'pastEntitiesForGUID:andRevisions:withChangeTypes:onlyFields:', [inGUID, (inRevisions || []), changeTypes, onlyFields], {}, inCallback, inErrback);
	},
	revisionSummaryForGUID: function(inGUID, inRevision, inCallback, inErrback) {
		return service_client().executeAsynchronously('ContentService', 'pastEntitiesForGUID:andRevisions:withChangeTypes:onlyFields:', [inGUID, [inRevision], ['create', 'edit', 'delete', 'undelete', 'restore'], ['revision', 'updatedByUserLongName', 'updatedByUserShortName', 'updateTime']], {}, inCallback, inErrback);
	},
	restoreRevision: function(inGUID, inRevision, inCallback, inErrback) {
		return service_client().executeAsynchronously('ContentService', 'restoreEntityWithGUID:toRevision:', [inGUID, inRevision], {}, inCallback, inErrback);
	},
	diffForEntityBetweenRevisions: function(inGUID, inFirstRevision, inSecondRevision, inCallback, inErrback) {
		var callback = function(service_response) {
			var result = service_response.response;
			inCallback(result);
		}
		return service_client().executeAsynchronously('ContentService', 'diffPastEntityGUID:compareRevision:againstRevision:usingProperty:', [inGUID, inFirstRevision, inSecondRevision, 'extendedAttributes.renderedPage'], {}, callback, inErrback);
	},
	// authentication 
	validateUsernameAndPassword: function(inUsername, inPassword, inRemember, inCallback, inErrback) {
		var callback = function(inResponse) {
			inCallback(inResponse.response);
		}
		return service_client().executeAsynchronously('AuthService', 'validateUsername:andPassword:remember:', [inUsername, inPassword, inRemember], {}, callback, inErrback);
	},
	getChallenge: function(inUsername, inAdvanced, inCallback, inErrback) {
		var callback = function(inResponse) {
			inCallback(inResponse.response);
		}
		return service_client().executeAsynchronously('AuthService', 'challengeForUsername:advanced:', [inUsername, inAdvanced], {}, callback, inErrback);
	},
	validateUsernameAndPasswordDigest: function(inDigest, inRemember, inCallback, inErrback) {
		var callback = function(inResponse) {
			inCallback(inResponse.response);
		}
		service_client().executeAsynchronously('AuthService', 'validateUsernameAndPasswordDigest:remember:', [inDigest, inRemember], {}, callback, inErrback);
	},
	amILoggedIn: function(inCallback, inErrback) {
		var callback = function(inResponse) {
			inCallback(inResponse.response);
		}
		return service_client().executeAsynchronously('ContentService', 'amILoggedIn', [], {}, callback, inErrback);
	},
	sanitizeRedirect: function(inRedirect, inCallback, inErrback) {
		var callback = function(inResponse) {
			inCallback(inResponse.response);
		}
		return service_client().executeAsynchronously('AuthService', 'sanitizeRedirect:withHost:', [inRedirect, window.location.hostname], {}, callback, inErrback);
	},
	changePassword: function(inOldPassword, inNewPassword, inVerifiedPassword, inCallback, inErrback) {
		var callback = function(inResponse) {
			inCallback(inResponse.response);
		}
		return service_client().executeAsynchronously('AuthService', 'changePasswordFrom:to:verified:', [inOldPassword, inNewPassword, inVerifiedPassword], {}, callback, inErrback);
	},
	currentServerTime: function(inCallback, inErrback) {
		var callback = function(inResponse) {
			inCallback(inResponse.response);
		}
		return service_client().executeAsynchronously('TimeService', 'currentServerTime', [], {}, callback, inErrback);
	}
};
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.



CC.ActivityStream = CC.ActivityStream || new Object();

// Notifications.

CC.ActivityStream.NOTIFICATION_DID_GET_NEW_ACTIVITY_CHUNK = 'DID_GET_NEW_ACTIVITY_CHUNK';
CC.ActivityStream.NOTIFICATION_NO_STREAM_ACTIVITY = 'NO_STREAM_ACTIVITY';
CC.ActivityStream.NOTIFICATION_ACTIVITY_STREAM_SHOULD_RECONNECT = 'ACTIVITY_STREAM_SHOULD_RECONNECT';
CC.ActivityStream.IFRAME_NO_ACTIVITY_INTERVAL = 300000;

// Activity stream shared instance so the chunked response <script> tag has something to call.
// Publishes a notification when any new activity arrives. Private shared instance hard-coded
// on the server to prevent XSS.

var ActivityStreamSharedInstance = Class.createWithSharedInstance('activityStream');
ActivityStreamSharedInstance.prototype = {
	initialize: function() {},
	signalWithJSON: function(inScriptTag, inJSON) {
		globalNotificationCenter().publish(CC.ActivityStream.NOTIFICATION_DID_GET_NEW_ACTIVITY_CHUNK, this, {'json': inJSON});
		inScriptTag.parentNode.removeChild(inScriptTag);
	}
};

// Activity stream chunked frame class. Initialize one of these to get activity stream behavior.
// The chunked response will call the activityStream() shared instance, which publishes a notification
// and triggers a callback.

CC.ActivityStream.ChunkFrame = Class.create({
	mCallback: null,
	mURL: "/__collabd/streams/activity?format=js",
	mFrame: null,
	mFrameReloadThreshold: 5000,
	mFrameReloadInterval: null,
	initialize: function(/* [options] */) {
		if (arguments && arguments.length > 0) Object.extend(this, arguments[0]);
		var frame = document.createElement('iFrame');
		frame.className = 'cc-activity-stream-chunk-frame';
		frame.style.display = 'none';
		document.body.appendChild(frame);
		this.mFrame = frame;
		this.setFrameURL(this.mURL);
		// Listen for notifications.
		globalNotificationCenter().subscribe(CC.ActivityStream.NOTIFICATION_DID_GET_NEW_ACTIVITY_CHUNK, this.handleChunkNotification.bind(this));
		globalNotificationCenter().subscribe(CC.ActivityStream.NOTIFICATION_ACTIVITY_STREAM_SHOULD_RECONNECT, this.reloadFrame.bind(this));
		
		Event.observe(frame, 'load', this.reloadFrame.bind(this));
		Event.observe(frame, 'error', this.reloadFrame.bind(this));
		
		this.setFrameNoActivityTimeout();
	},
	resetFrameNoActivityTimeout: function() {
		if (this.mFrameReloadInterval) {
			clearInterval(this.mFrameReloadInterval);
			this.setFrameNoActivityTimeout();
		}
	},
	setFrameNoActivityTimeout: function() {
		this.mFrameReloadInterval = setInterval(function() {
			logger().info("No stream activity notifications or heartbeat in a while. Reloading stream.");
			globalNotificationCenter().publish(CC.ActivityStream.NOTIFICATION_NO_STREAM_ACTIVITY);
			this.reloadFrame();
		}.bind(this), CC.ActivityStream.IFRAME_NO_ACTIVITY_INTERVAL);
	},
	reloadFrame: function() {
		if (event && event.type == "load") {
			logger().error("Activity frame appears to have fully loaded, will reload in %@ms".fmt(this.mFrameReloadThreshold));
		}
		if (event && event.type == "error") {
			logger().error("Activity frame appears to have encountered an error, will reload in %@ms".fmt(this.mFrameReloadThreshold));
		}
		
		if (this.mFrameReloadTimer) {
			clearTimeout(this.mFrameReloadTimer);
			this.mFrameReloadTimer = null;
		}
		this.mFrameReloadTimer = setTimeout(function() {
			this.setFrameURL(this.mURL);
		}.bind(this), this.mFrameReloadThreshold);
	},
	setFrameURL: function(inURL) {
		logger().debug("Reloading activity frame (url = %@)".fmt(inURL));
		if (this.mFrame) {
			this.mFrame.src = inURL;
		} else {
			logger().error("Activity frame not found, something is really wrong");
		}
	},
	handleChunkNotification: function(inMessage, inObject, inOptExtras) {
		this.resetFrameNoActivityTimeout();
		if (this.mCallback) return this.mCallback(inOptExtras && inOptExtras.json);
		logger().error("No chunk callback registered ... skipping");
	}
});
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.




var ModalDialogManager = Class.createWithSharedInstance('dialogManager');
Object.extend(Object.extend(ModalDialogManager.prototype, CC.Keyboard.Mixins.Responder), {
	mNowShowing: false,
	mSlideFromElement: null,
	mProgressMessageDelay: 700,
	mProgressMessageHideDelay: 850,
	initialize: function(/*[options]*/) {
		bindEventListeners(this, ['handleCancelClick', 'handleOKClick', 'handleDialogMouseDown', 'handleDialogDrag', 'handleDialogEndDrag']);
		if($('dialog_mask')){
			this.mMaskWidget = $('dialog_mask');
		}else{
			// ##5357320 IE6: dialog mask shows up incorrectly
			this.mMaskWidget = Builder.node('div', {id:'dialog_mask', style:(browser().isIE6() ? "position:absolute;top:0;left:0;width:100%;filter:alpha(opacity='50');display:none" : 'display:none')});
			document.body.appendChild(this.mMaskWidget);
		}
		if (arguments.length > 0) Object.extend(this, arguments[0]);
	},
	drawDialog: function(inID, inFields, inOKTitle, inOptFormAction, inOptDialogTitle, inOptCancelTitle) {
		
		var tabIndexOk = accessibility().requestTabIndex(CC.Accessibility.TAB_INDEX_NAME_POPUP_DIALOG_OK_BUTTON);
		var tabIndexCancel = accessibility().requestTabIndex(CC.Accessibility.TAB_INDEX_NAME_POPUP_DIALOG_CANCEL_BUTTON);
		
		// create basic dialog and table structure	
		var tbody = Builder.node('tbody');
		var dialog = Builder.node('div', {id:inID, className:'dialog chrome', style:'display:none', 'role':'dialog', 'aria-label': ((inOptDialogTitle && inOptDialogTitle) || (inID+'_header') || '')}, [
			Builder.node('div', {className:'dialog_contents'}, [
				Builder.node('form', {id:inID+'_form', method:(inOptFormAction?'post':'get'), action:inOptFormAction||'#', enctype:(inOptFormAction?'multipart/form-data':'application/x-www-form-urlencoded'), target:(inOptFormAction?'upload_iframe':'_self')}, [
					Builder.node('table', {'role': 'presentation'}, [
						Builder.node('thead', [Builder.node('tr', [
								Builder.node('td', {colSpan:'2'}, ((inOptDialogTitle && inOptDialogTitle) || (inID+'_header') || ''))
							])
						]),
						tbody
					])
				])
			])
		]);
		
		var tabIndex = accessibility().requestTabIndex(CC.Accessibility.TAB_INDEX_NAME_POPUP_DIALOG_MOVE_SIMPLETEXT);
		
		// set up the fields
		for (index = 0; index < inFields.length; index++) {
			var field = inFields[index];
			var td = Builder.node('td');
			var labelText = field.label ? field.label : "";
			var label = Builder.node('label', labelText); // ##5210590 Accessibility: drawDialog does not label input fields
			var headerArgs = (labelText == '' ? {className:'dialog_empty_header'} : {});
			if (field.contents) {
				tbody.appendChild(Builder.node('tr', [
					// ##5389500
					Builder.node('th', headerArgs, label),
					td
				]));
				replaceElementContents(td, field.contents, true);
				if (field.id) td.id = field.id;
				var inputs = td.getElementsByTagName('input');
				if(inputs.length) label.setAttribute('for', inputs.item(0).getAttribute('id'));
			}
			else {
				var fieldValue = field.contents || field;
				Element.addClassName(td, 'dialog_description');
				td.colSpan = '2';
				if (field.id) td.id = field.id;
				tbody.appendChild(Builder.node('tr', [td]));
				replaceElementContents(td, fieldValue, field.contents);
			}
		}
		// OK and cancel buttons		
		tbody.appendChild(Builder.node('tr', [
			Builder.node('td', {'role': 'presentation', colSpan:'2', className:'form_buttons'}, [
				Builder.node('div', {'role': 'presentation', className:'submit'}, [
					Builder.node('input', {'tabindex': tabIndexOk, 'role': 'button', type:'submit', className:'primaryaction', id:inID+'_ok', value:inOKTitle, name:'ok_button'}),
					Builder.node('input', {'tabindex': tabIndexCancel, 'role': 'button', type:'button', className:'secondaryaction', id:inID+'_cancel', value:((inOptCancelTitle && inOptCancelTitle) || "_Dialogs.Cancel".loc()), name:'cancel_button'})
				])
			])
		]));
		// add the dialog to the document
		document.body.appendChild(dialog);
		if (!inOptFormAction) $(inID+'_form').onsubmit = invalidate;
		return dialog;
	},
	focus: function() {
		if (this.mFocusField) {
			if (this.mFocusField.activate) this.mFocusField.activate();
		}
		else {
			var inputs = this.mActiveElement.getElementsByTagName('input');
			$A(inputs).detect(function(elm) {
				if (elm.type && elm.focus && (elm.type.toLowerCase() == 'text' || elm.type.toLowerCase() == 'search') && (!Element.hasClassName(elm, 'search_field')) && (!elm.disabled)) {
					$(elm).activate();
					return true;
				}
				return false;
			});
		}
		// TODO: move this into the test tool itself
		if (window.unitTestHandler) unitTestHandler.messageFromJS_('dialog');
		globalNotificationCenter().publish('DIALOG_FOCUS', this.mActiveElement);
	},
	prepareToShow: function(inElement, inCancelCallback, inOKCallback, inOptSlideFrom, inOptShowSpinner, inOptFocusField, inOptAllowSubmission) {
		this.hide();
		this.mShowSpinner = inOptShowSpinner;
		this.mFocusField = $(inOptFocusField);
		this.mAllowSubmission = inOptAllowSubmission;
		inOptSlideFrom = inOptSlideFrom || this.mSlideFromElement;
		//this.mActiveParent = (inOptSlideFrom ? $(inOptSlideFrom) : null); ##8531406
		if (this.mTimer) {
			clearTimeout(this.mTimer);
			delete this.mTimer;
		}
		this.mActiveElement = $(inElement);
		this.mCancelCallback = inCancelCallback;
		this.mOKCallback = inOKCallback;
		// ##5357320 IE6: dialog mask shows up incorrectly
		if (browser().isIE6()) this.mMaskWidget.style.height = (document.viewport.getHeight()+document.viewport.getScrollOffsets().top)+'px';
		globalNotificationCenter().publish('DIALOG_WILL_SHOW', this.mActiveElement);
		Element.show(this.mMaskWidget);
	},
	finishShowing: function() {
		// look for a cancel button
		this.mCancelElement = $(this.mActiveElement.id+'_cancel');
		if (this.mCancelElement) {
			Event.observe(this.mCancelElement, 'click', this.handleCancelClick);
		}
		this.mFormElement = $(this.mActiveElement.id+'_form');
		if (this.mFormElement) {
			if (browser().isWebKit() && (this.mFormElement.enctype == 'multipart/form-data') && $(this.mActiveElement.id+'_ok')) {
				$(this.mActiveElement.id+'_ok').type = 'button';
				this.mObservingInfo = {elm:this.mActiveElement.id+'_ok', evt:'click'};
				Event.observe(this.mActiveElement.id+'_ok', 'click', this.handleOKClick);
			}
			else {
				this.mObservingInfo = {elm:this.mFormElement, evt:'submit'};
				Event.observe(this.mFormElement, 'submit', this.handleOKClick);
			}
		}
		if (this.mCancelElement) this.mCancelElement.disabled = false;
		if ($(this.mActiveElement.id+'_ok')) $(this.mActiveElement.id+'_ok').disabled = false;
		// handle dialog drags
		Event.observe(this.mActiveElement, 'mousedown', this.handleDialogMouseDown);
		this.becomeFirstResponder();
		this.mNowShowing = true;
		
		var firstAction = this.mActiveElement.querySelector('input[type="submit"]');
		if(firstAction) firstAction.focus();
	},
	show: function(inElement, inCancelCallback, inOKCallback, inOptSlideFrom, inOptShowSpinner, inOptFocusField, inOptAllowSubmission) {
		this.prepareToShow(inElement, inCancelCallback, inOKCallback, inOptSlideFrom, inOptShowSpinner, inOptFocusField, inOptAllowSubmission);
		if (this.mActiveParent && (inElement != this.mProgressElement)) {
			window.scrollTo(0, 0);
			this.mActiveElement.style.height = ''; // revert to natural size
			Element.setStyle(this.mActiveParent, {position:'relative', zIndex:'504'});
			Element.addClassName(this.mActiveParent, 'dialog_parent');
			// position the sheet
			this.mActiveElement.style.visibility = 'hidden';
			Element.show(this.mActiveElement);
			var cloneOptions = {
				setWidth: false,
				setHeight: false,
				offsetLeft: (this.mActiveParent.offsetWidth / 2) - (this.mActiveElement.offsetWidth / 2),
				offsetTop: Element.getHeight(this.mActiveParent)
			};
			Position.clone(this.mActiveParent, this.mActiveElement, cloneOptions);
		}
		else {
			// center the dialog
			this.mActiveElement.style.visibility = 'hidden';
			Element.show(this.mActiveElement);
			var elementBounds = offsetBoundsForDiv(this.mActiveElement.down('table') || this.mActiveElement);
			var leftd = ((window.innerWidth || document.body.offsetWidth) / 2) - (elementBounds[2] / 2);
			var topd = ((window.innerHeight || document.documentElement.offsetHeight) / 3) - (elementBounds[3] / 2); // skew towards top
			leftd = Math.max(leftd, 0);
			topd = Math.max(topd, 0) + document.viewport.getScrollOffsets().top;
			this.mActiveElement.style.left = leftd+'px';
			this.mActiveElement.style.top = topd+'px';
		}
		// show the sheet
		if (browser().isGecko()) this.mActiveElement.style.position = 'fixed';
		Element.hide(this.mActiveElement);
		this.mActiveElement.style.visibility = 'visible';
		this.mActiveElement.show();
		this.focus();
		
		// IE doesn't support fixed positioning, so match the size of the window
		if (browser().isIE()) {
			Element.setStyle(this.mMaskWidget, {width:document.body.offsetWidth+'px',height:document.documentElement.offsetHeight+'px'});
		}
		this.finishShowing();
		
		// Temporary disabling background items when modal dialog is open in order to avoid bad tabindex-ing
		if (inElement != this.mProgressElement) {
			// Do not modify the accessibility tab index for the progress message dialog.
			accessibility().makeRootViewsAriaHidden(false);
		}
		
		var firstAction = this.mActiveElement.querySelector('input[type="submit"]');
		if(firstAction) firstAction.focus();
	},
	handleDialogMouseDown: function(inEvent) {
		if (inEvent.findElement('thead') || inEvent.findElement('h2')){
			if (Element.hasClassName(inEvent.findElement('table'), 'tableEditor')){
				return; // don't cancel mousedown events on thead in tableEditor table
			} else if (inEvent.findElement('h2') && !inEvent.findElement('h2').up('div.dialog').id == 'tableDialog'){
				return; // only cancel mousedown events on h2 if it is the tableDialog
			}
			Event.stop(inEvent);
			this.mDragPos = [inEvent.pointerX(), inEvent.pointerY()];
			observeEvents(this, d, {mousemove:'handleDialogDrag', mouseup:'handleDialogEndDrag'});
		}
	},
	handleDialogDrag: function(inEvent) {
		Event.stop(inEvent);
		this.mActiveElement.style.left = (parseFloat(this.mActiveElement.style.left) + (inEvent.pointerX() - this.mDragPos[0])) + 'px';
		this.mActiveElement.style.top = (parseFloat(this.mActiveElement.style.top) + (inEvent.pointerY() - this.mDragPos[1])) + 'px';
		this.mDragPos = [inEvent.pointerX(), inEvent.pointerY()];
		return false;
	},
	handleDialogEndDrag: function(inEvent) {
		stopObservingEvents(this, d, {mousemove:'handleDialogDrag', mouseup:'handleDialogEndDrag'});
	},
	showProgressMessage: function(inMessage, inOptShowProgressBar, inOptCancelCallback, inOptShowImmediately) {
		dialogManager().showingProgressMessage = true;
		if (!this.mProgressElement) {
			this.mProgressElement = this.drawDialog('progress_message_dialog', [{id:'progress_spinner', contents:"<span>\u00A0</span>"}, {id:'progress_message', contents:"\u00A0"}], "_Dialogs.Cancel".loc());
			$('progress_message_dialog_ok').remove();
		}
		if (inOptShowProgressBar) {
			Element.removeClassName(this.mProgressElement, 'indeterminate');
			this.mProgressBar = Builder.node('div', {className:'progress_bar'}, [Builder.node('div', {style:'width:0'}, "\u00A0")]);
			replaceElementContents(this.mProgressElement.down('thead td'), inMessage);
			replaceElementContents('progress_message', this.mProgressBar);
		}
		else {
			replaceElementContents('progress_message', inMessage);
			Element.addClassName(this.mProgressElement, 'indeterminate');
			removeAllChildNodes(this.mProgressElement.down('thead td'));
			if (inOptCancelCallback) {
				this.mProgressElement.down('td.form_buttons').show();
			} else {
				this.mProgressElement.down('td.form_buttons').hide();
			}
		}
		if (this.mTimer) {
			clearTimeout(this.mTimer);
		}
		this.mTimer = setTimeout(function() {
			// clear any hide delay timers
			if (this.mHideDelayTimer) {
				clearTimeout(this.mHideDelayTimer);
				delete this.mHideDelayTimer;
			}
			// set up a new hide delay timer (we shouldn't be open for less than 1 second)
			this.mHideDelayTimer = setTimeout(function() {
				delete this.mHideDelayTimer;
				// if we've tried to hide, hide now
				if (this.mShouldHideLater) {
					this.mShouldHideLater = false;
					this.hideProgressMessage();
				}
			}.bind(this), this.mProgressMessageHideDelay);
			this.show(this.mProgressElement, inOptCancelCallback, invalidate);
		}.bind(this), (inOptShowImmediately) ? 0 : this.mProgressMessageDelay);
		delete dialogManager().showingProgressMessage;
	},
	hide: function(inOptElement, inPerformFakeHide) { // so we don't remove active file upload forms from the view hierarchy
		if (!this.mTargeted) globalInfoPanelManager().hide(inOptElement, inPerformFakeHide);
		if (this.mActiveElement && this.mActiveElement == $('progress_message_dialog') && !inOptElement) {
			this.hideProgressMessage();
			return;
		}
		if (this.mObservingInfo) {
			Event.stopObserving(this.mObservingInfo.elm, this.mObservingInfo.evt, this.handleOKClick);
			delete this.mObservingInfo;
		}
		if (browser().isWebKit() && this.mProgressElement && (this.mActiveElement == this.mProgressElement)) {
			$$('div.dialog').each(function(dialogDiv) {
				if (dialogDiv.style.visibility == 'hidden') {
					Element.hide(dialogDiv);
					dialogDiv.style.visibility = '';
				}
			});
		}
		if (inOptElement && (this.mActiveElement != $(inOptElement))) return false;
		if (this.mTimer) {
			clearTimeout(this.mTimer);
			delete this.mTimer;
		}
		if (this.mCancelElement) {
			if (this.mShowSpinner) this.mCancelElement.disabled = false;
			Event.stopObserving(this.mCancelElement, 'click', this.handleCancelClick);
			delete this.mCancelElement;
		}
		if (this.mShowSpinner) {
			$(this.mActiveElement.id+'_ok').disabled = false;
			$A(this.mActiveElement.getElementsByClassName('dialog_progress_row')).invoke('removeClassName', 'dialog_progress_row');
			this.mShowSpinner = false;
		}
		if (this.mActiveElement) {
			Event.stopObserving(this.mActiveElement, 'mousedown', this.handleDialogMouseDown);
			if (this.mEffect) this.mEffect.cancel();
			var elementForm = $(this.mActiveElement).down('form');
			if (browser().isWebKit() && dialogManager().showingProgressMessage && elementForm && elementForm.method == 'post') {
				this.mActiveElement.style.visibility = 'hidden';
			}
			else {
				Element.hide(this.mActiveElement);
			}
			Element.hide(this.mMaskWidget);
			globalNotificationCenter().publish('DIALOG_HIDDEN', this.mActiveElement);
		}
		if (this.mActiveParent) {
			Element.setStyle(this.mActiveParent, {position:'', zIndex:''});
			Element.removeClassName(this.mActiveParent, 'dialog_parent');
		}
		this.loseFirstResponder();
		this.mNowShowing = false;
		
		// Bring background items back to foreground when closing modal dialog to bring back original tabindex-ing
		if (this.mActiveElement && (this.mActiveElement != this.mProgressElement)) {
			// Do not modify the accessibility tab index for the progress message dialog.
			accessibility().makeRootViewsAriaVisible(false);
		}
		
		if (this.mActiveElement) {
			delete this.mActiveElement;
		}
	},
	shakeDialog: function() {
		var element = $(this.mActiveElement);
		element = $(element);
		var oldStyle = { left: element.getStyle('left') };
		  return new Effect.Move(element, 
		    { x:  10, y: 0, duration: 0.05, afterFinishInternal: function(effect) {
		  new Effect.Move(effect.element,
		    { x: -20, y: 0, duration: 0.1,  afterFinishInternal: function(effect) {
		  new Effect.Move(effect.element,
		    { x:  20, y: 0, duration: 0.1,  afterFinishInternal: function(effect) {
		  new Effect.Move(effect.element,
		    { x: -20, y: 0, duration: 0.1,  afterFinishInternal: function(effect) {
		  new Effect.Move(effect.element,
		    { x:  20, y: 0, duration: 0.1,  afterFinishInternal: function(effect) {
		  new Effect.Move(effect.element,
		    { x: -10, y: 0, duration: 0.05, afterFinishInternal: function(effect) {
		      effect.element.setStyle(oldStyle);
		}}); }}); }}); }}); }}); }});
	},
	willResize: function() {
		if (!this.mActiveElement) return;
		var contentsTable = this.mActiveElement.down('table');
		this.mOldStyles = {
			top: parseInt(this.mActiveElement.style.top, 10),
			left: parseInt(this.mActiveElement.style.left, 10),
			width: this.mActiveElement.getWidth(),
			height: this.mActiveElement.getHeight()
		};
		if (contentsTable) {
			this.mOldStyles.tableWidth = contentsTable.getWidth();
			this.mOldStyles.tableHeight = contentsTable.getHeight();
		}
		// move the dialog temporarily to upper/left so that nothing compresses artificially
		this.mActiveElement.setStyle({left:'0', top:'0'});
	},
	didResize: function() {
		if (!this.mActiveElement) return;
		if (!this.mOldStyles) return;
		// get the destination style dimensions
		Element.setOffsetWidth(this.mActiveElement, this.mActiveElement.getWidth());
		Element.setOffsetHeight(this.mActiveElement, this.mActiveElement.getHeight());
		var changedWidth = parseInt(this.mActiveElement.style.width, 10);
		var changedHeight = parseInt(this.mActiveElement.style.height, 10);
		// if there's a contents table, get its dimensions as well
		var contentsTable = this.mActiveElement.down('table');
		var changedTableWidth = 0;
		var changedTableHeight = 0;
		if (contentsTable && this.mOldStyles.tableWidth) {
			Element.setOffsetWidth(contentsTable, contentsTable.getWidth());
			Element.setOffsetHeight(contentsTable, contentsTable.getHeight());
			changedTableWidth = parseInt(contentsTable.style.width, 10);
			changedTableHeight = parseInt(contentsTable.style.height, 10);
		}
		// move back to its original position
		this.mActiveElement.setStyle({left:this.mOldStyles.left+'px', top:this.mOldStyles.top+'px'});
		// if there's a contents table, lock its size so we don't wrap text weirdly
		if (contentsTable && this.mOldStyles.tableWidth) {
			Element.setOffsetWidth(contentsTable, this.mOldStyles.tableWidth);
			Element.setOffsetHeight(contentsTable, this.mOldStyles.tableHeight);
		}
		// set back to the original size
		Element.setOffsetWidth(this.mActiveElement, this.mOldStyles.width);
		Element.setOffsetHeight(this.mActiveElement, this.mOldStyles.height);
		// figure out how far left to move the dialog to keep it centered
		var delta = changedWidth - parseInt(this.mActiveElement.style.width, 10);
		var changedLeft = Math.round(this.mOldStyles.left-(delta/2));
		// if we're moving off-screen, fix that
		changedLeft = Math.max(Math.min(changedLeft, document.viewport.getWidth() - changedWidth - 30), 10);
		// build the new style string for the morph effect
		var resizedStyleString = 'left:'+changedLeft+'px;width:'+changedWidth+'px;height:'+changedHeight+'px';
		// cancel any current resize effects and start a new one
		if (this.mResizeEffect) this.mResizeEffect.cancel();
		var effects = $A([new Effect.Morph(this.mActiveElement, {style:resizedStyleString})]);
		if (contentsTable) {
			effects.push(new Effect.Morph(contentsTable, {style:'width:'+changedTableWidth+'px;height:'+changedTableHeight+'px'}));
		}
		this.mResizeEffect = new Effect.Parallel(effects, {duration:0.20, afterFinish: function(eff) {
			// after we're finished, remove the hard-coded styles
			this.mActiveElement.setStyle({width:'', height:''});
			if (contentsTable) contentsTable.setStyle({width:'', height:''});
		}.bind(this)});
		delete this.mOldStyles;
	},
	hideProgressMessage: function() {
		if (this.mTimer) {
			clearTimeout(this.mTimer);
			delete this.mTimer;
		}
		if (this.mActiveElement == this.mProgressElement) {
			if (this.mHideDelayTimer) {
				this.mShouldHideLater = true;
			}
			else {
				this.hide('progress_message_dialog');
			}
		}
	},
	handleCancelClick: function(inEvent) {
		this.hide();
		if (this.mCancelCallback) this.mCancelCallback();
	},
	handleOKClick: function(inEvent) {
		var elm = Event.element(inEvent);
		if (!this.mAllowSubmission) Event.stop(inEvent);
		if (elm && elm.type && elm.form && (elm.type == 'button') && this.mAllowSubmission) elm.form.submit();
		if (this.mShowSpinner) {
			if (this.mCancelElement) this.mCancelElement.disabled = true;
			$(this.mActiveElement.id+'_ok').disabled = true;
			$A(this.mActiveElement.getElementsByClassName('form_buttons')).invoke('addClassName', 'dialog_progress_row');
		}
		else {
			this.hide();
		}
		if (this.mOKCallback) this.mOKCallback();
		if (!this.mAllowSubmission) return false;
	},
	handleKeyboardNotification: function(inMessage, inObject, inOptExtras) {
		if (inMessage == CC.Keyboard.NOTIFICATION_DID_KEYBOARD_ESC) {
			this.handleCancelClick();
		}
		return true;
	}
});

var InfoPanelManager = Class.createWithSharedInstance('globalInfoPanelManager');
Object.extend(Object.extend(InfoPanelManager.prototype, ModalDialogManager.prototype), {
	mTargeted: true,
	drawInfoPanel: function(inID, inFields) {
		this.drawDialog(inID, inFields, 'OK'); // FIXME: use an empty string when we have the dialog styled
		Element.addClassName(inID, 'infopanel');
		$(inID).appendChild(Builder.node('div', {className:'infopanel_norgie'}, [Builder.node('span')]));
		if (!this.hasBoundListnener) {
			this.hasBoundListnener = true;
			this.handleHideClick = this.handleHideClick.bindAsEventListener(this);
		}
	},
	show: function(inElement, inCancelCallback, inOKCallback, inSlideFrom, inOptShowSpinner, inOptFocusField, inOptAllowSubmission) {
		this.prepareToShow(inElement, inCancelCallback, inOKCallback, inSlideFrom, inOptShowSpinner, inOptFocusField, inOptAllowSubmission);
		this.mMaskWidget.hide();
		// add rounded corners, etc
		Element.addClassName(this.mActiveElement, 'targeted_dialog');
		// overcome firefox cursor bug
		if (browser().isGecko()) this.mActiveElement.style.position = 'fixed';
		Position.clone(inSlideFrom, this.mActiveElement, {limitWithScrollbars:true, offsetLeft:11, offsetTop:-2, setWidth:false, setHeight:false});
		var norgieElm = this.mActiveElement.down('div.infopanel_norgie');
		norgieElm.style.top = ((inSlideFrom.offsetHeight / 2) - 14) + 'px';
		// figure out if we should open above
		var sz = Element.getInvisibleSize(this.mActiveElement);
		if (parseInt(this.mActiveElement.style.top, 10) + sz[1] > (document.viewport.getHeight() - inSlideFrom.cumulativeScrollOffset()[1]) - 10) {
			this.mActiveElement.style.top = (parseInt(this.mActiveElement.style.top, 10) - sz[1] + inSlideFrom.offsetHeight + 3) + 'px';
			norgieElm.style.bottom = norgieElm.style.top;
			norgieElm.style.top = '';
		}
		else {
			this.mActiveElement.style.top = (parseInt(this.mActiveElement.style.top, 10) + 6) + 'px';
		}
		// show the panel
		this.mActiveElement.setStyle({opacity:0});
		this.mActiveElement.show();
		this.mActiveElement.addClassName('animates_opacity');
		setTimeout(function() {this.mActiveElement.setStyle({opacity:0.9})}.bind(this), 10);
		this.finishShowing();
		Event.observe(document, 'mousedown', this.handleHideClick);
		Event.observe(window, 'resize', this.handleHideClick);
	},
	handleHideClick: function(inEvent)
	{
		this.mActiveElement.removeClassName('animates_opacity');
		Event.stopObserving(document, 'mousedown', this.handleHideClick);
		Event.stopObserving(window, 'resize', this.handleHideClick);
		this.hide();
	}
});
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.



CC.DID_FAVORITE_ENTITY_NOTIFICATION = 'DID_FAVORITE_ENTITY';
CC.DID_UNFAVORITE_ENTITY_NOTIFICATION = 'DID_UNFAVORITE_ENTITY';
CC.DID_MARK_ENTITY_AS_READ_NOTIFICATION = 'DID_MARK_ENTITY_AS_READ';
CC.DID_MARK_ENTITY_AS_UNREAD_NOTIFICATION = 'DID_MARK_ENTITY_AS_UNREAD';

// Entity toggle base class.

CC.BaseEntityToggle = Class.create({
	initialize: function(element) {
		this.element = $(element);
		if (this.element.hasClassName('enabled')) return;
		this.element.addClassName('enabled');
		this.element.on(browser().isMobileSafari() ? 'touchstart' : 'mousedown', this.onElementClick.bindAsEventListener(this));
		this.setIsSelected(this.element.hasClassName('selected'), false);
	},
	onElementClick: function(e) {
		Event.stop(e);
		this.toggleIsSelected();
	},
	toggleIsSelected: function() {
		this.setIsSelected(!this.getIsSelected());
	},
	getIsSelected: function() {
		return this.element.hasClassName('selected');
	},
	setIsSelected: function(value, persist) {
		if (persist === undefined) persist = true;
		this.element.setClassName('selected', value);
		this.updateTooltip();
		if (persist) this.persistIsSelected();
	},
	updateTooltip: function() { /* Interface */ },
	persistIsSelected: function() { /* Interface */ }
});

CC.EntityFavoriteToggle = Class.create(CC.BaseEntityToggle, {
	persistIsSelected: function() {
		if (this.getIsSelected()) {
			server_proxy().addEntityToFavorites(this.element.getDataAttributes().guid, function() {
				globalNotificationCenter().publish(CC.DID_FAVORITE_ENTITY_NOTIFICATION, this, {'guid': this.element.getDataAttributes().guid});
			}.bind(this));
		} else {
			server_proxy().removeEntityFromFavorites(this.element.getDataAttributes().guid, function() {
				globalNotificationCenter().publish(CC.DID_UNFAVORITE_ENTITY_NOTIFICATION, this, {'guid': this.element.getDataAttributes().guid});
			}.bind(this));
		}
	}
});

CC.EntityUnreadToggle = Class.create(CC.BaseEntityToggle, {
	persistIsSelected: function() {
		if (this.getIsSelected()) {
			server_proxy().markEntityAsUnread(this.element.getDataAttributes().guid, function() {
				globalNotificationCenter().publish(CC.DID_MARK_ENTITY_AS_READ_NOTIFICATION, this, {'guid': this.element.getDataAttributes().guid});
			}.bind(this));
		} else {
			server_proxy().markEntityAsRead(this.element.getDataAttributes().guid, function() {
				globalNotificationCenter().publish(CC.DID_MARK_ENTITY_AS_UNREAD_NOTIFICATION, this, {'guid': this.element.getDataAttributes().guid});
			}.bind(this));
		}
	}
});

var SearchFieldBase = Class.create({
	mClickedItemCallback: null,
	mStartedItemSearchCallback: null,
	mSearchCancelledCallback: null,
	mResultTable: null,
	mPositionResults: true,
	mHeaderElement: null,
	mMinQueryChars: 1,
	mInterval: 500,
	mNumberOfEntries: 20,
	mSortKey: null,
	mTrapTabs: true,
	mShowPlaceholderStrings: false,
	mCaptureReturnChar: true,
	mSelectOnClick: true,
	initialize: function(inSearchField/*[, options]*/) {
		bindEventListeners(this, ['handleSafariSearch', 'handleKeypress', 'handleChanged', 'mousedOverUser', 'mousedOutUser', 'clickedUser']);
		this.mSearchField = $(inSearchField);
		if (arguments.length > 1) Object.extend(this, arguments[1]);
		if (!this.mResultTable) {
			this.mResultTable = Builder.node('table', {className:'search_field_results', style:'display:none'}, [
				Builder.node('tbody')
			]);
			d.body.appendChild(this.mResultTable);
		}
		this.mIsReallyTable = (this.mResultTable.nodeName.toLowerCase() == 'table');
		observeEvents(this, this.mSearchField, {keydown:'handleKeypress'});
		if (browser().isWebKit() && (this.mSearchField.type == 'search')) Event.observe(this.mSearchField, 'search', this.handleSafariSearch);
	},
	handleSafariSearch: function(e) {
		if (Event.element(e).value == '') this.runQuery(); // handle "x" button in search fields
	},
	handleKeypress: function(e) {
		switch (e.keyCode) {
			case Event.KEY_DOWN:
				this.suggestSibling('nextSibling');
				Event.stop(e);
				break;
			case Event.KEY_UP:
				this.suggestSibling('previousSibling');
				Event.stop(e);
				break;
			case Event.KEY_TAB:
			case Event.KEY_RETURN:
			case 188: // comma
				if (e.keyCode == Event.KEY_TAB && this.mSearchField.value == '') return true;
				if (e.keyCode == Event.KEY_RETURN && !this.mCaptureReturnChar) return true;
				this.handleChanged(e);
				if (e.keyCode == 188 || this.mTrapTabs) Event.stop(e);
				break;
			case Event.KEY_ESC:
				this.mSearchField.value = '';
				this.mLastQuery = null;
				this.mRows = null;
				if (this.mSearchCancelledCallback) this.mSearchCancelledCallback();
				break;
			default:
				if (!this.mTimer) this.mTimer = setTimeout(this.runQuery.bind(this), this.mInterval);
		}
	},
	handleChanged: function(e) {
		if (this.mSearchField.value != '') {
			this.selectSuggestedUID();
			Element.hide(this.mResultTable); // ##6410526
		}
	},
	suggestSibling: function(inKey) { // key = 'nextSibling' or 'previousSibling'
		var elm = $(this.mResultTable.id+'_'+(this.mSuggestedUID||''));
		if (elm && elm.parentNode[inKey]) {
			this.suggestUID(elm.parentNode[inKey].firstChild.dataSource.entityGUID);
		}
		else if ((!elm) && inKey == "nextSibling" && this.mRows && this.mRows.length > 0) {
			this.suggestUID(this.mRows[0].entityGUID);
		}
		// If we're at the first node, and we're keying up, deselect
		// the first item in the list and focus the input field.
		else if (inKey == 'previousSibling' && this.mSuggestedUID == this.mRows[0].entityGUID) {
			this.suggestUID(null);
		}
	},
	suggestUID: function(inUID) {
		Element.removeClassName(this.mResultTable.id+'_'+this.mSuggestedUID, 'suggested');
		this.mSuggestedUID = inUID;
		if (inUID) Element.addClassName(this.mResultTable.id+'_'+inUID, 'suggested');
	},
	selectSuggestedUID: function() {
		this.mChosenUID = this.mSuggestedUID;
		if (this.mChosenUID) {
			var chosenElm = $(this.mResultTable.id+'_'+this.mChosenUID);
			this.mChosenDataSource = chosenElm.dataSource;
			if (this.mPositionResults) {
				Element.hide(this.mResultTable);
				this.mSearchField.value = chosenElm.firstChild.nodeValue;
			}
			if (this.mClickedItemCallback) this.mClickedItemCallback(this.mChosenUID, this.mChosenDataSource.entityURL);
		}
		else if (!Element.hasClassName(this.mSearchField, 'hinted')) {
			if (this.mClickedItemCallback) this.mClickedItemCallback($F(this.mSearchField), null);
		}
		if (this.mTimer) {
			clearTimeout(this.mTimer);
			this.mTimer = null;
		}
	},
	mousedOverUser: function(e) {
		// superclass does nothing
	},
	mousedOutUser: function(e) {
		// superclass does nothing
	},
	clickedUser: function(e) {
		this.suggestUID(Event.findElement(e, (this.mIsReallyTable?'td':'a')).dataSource.entityGUID);
		if (this.mSelectOnClick) this.selectSuggestedUID();
	},
	constructQuery: function(inSearchString) {
		// subclasses should over-ride
	},
	runQuery: function() {
		if ($F(this.mSearchField) != this.mLastQuery) {
			this.mSuggestedUID = null;
			this.mRows = new Array();
			this.draw();
			if (this.mShowPlaceholderStrings) {
				// NOTE: not bothering with table code here because we don't use placeholder strings for tables
				replaceElementContents(this.mResultTable, Builder.node('li', {className:'search_placeholder busy_field'}, [Builder.node('a', {href:'#', onclick:invalidate}, "_Dialogs.LinkSearch.Progress.Searching".loc())]));
			}
			if (this.mPrefetch || ($F(this.mSearchField).length >= this.mMinQueryChars)) {
				Element.addClassName(this.mSearchField, 'busy_field');
				if (this.mStartedItemSearchCallback) this.mStartedItemSearchCallback();
				this.constructQuery($F(this.mSearchField));
			}
			else {
				this.mTimer = null;
				if (this.mSearchCancelledCallback) this.mSearchCancelledCallback();
			}
		}
		else {
			this.mTimer = null;
		}
		this.mLastQuery = $F(this.mSearchField);
	},
	gotSearchResult: function(inRequestObj, inResponseObj) {
		this.mRows = inResponseObj;
		if (this.mSortKey) Array.sortArrayUsingKey(this.mRows, this.mSortKey);
		if (this.mPrefetch && (!this.mCachedRows)) {
			this.mCachedRows = inResponseObj;
			Element.removeClassName(this.mSearchField, 'busy_field');
		}
		else {
			this.draw();
		}
		this.mTimer = null;
		this.runQuery(); // in case field changed while we were querying
		if (this.mSearchResultCallback) this.mSearchResultCallback(inResponseObj);
	},
	handleError: function(inFaultCode, inFaultString) {
		this.mTimer = null;
	},
	getDisplayString: function(inRow) {
		// subclasses should over-ride
	},
	updatePosition: function() {
		if (this.mPositionResults) {
			var cloneOptions = {setHeight:false, offsetTop:Element.getHeight(this.mSearchField)};
			Position.clone(this.mSearchField, this.mResultTable, cloneOptions);
		}
	},
	draw: function() {
		this.updatePosition();
		if (this.mPositionResults) Element.hide(this.mResultTable);
		if (this.mHeaderElement) Element.hide(this.mHeaderElement);
		removeAllChildNodes(this.mIsReallyTable ? this.mResultTable.firstChild : this.mResultTable);
		this.mSuggestedUID = null;
		if (this.mShowPlaceholderStrings && (this.mRows.length == 0)) {
			// NOTE: not bothering with table code here because we don't use placeholder strings for tables
			// also hacking hidden form value in here to avoid sending to another round of loc
			this.mResultTable.appendChild(Builder.node('li', [Builder.node('a', {href:'#', onclick:invalidate, className:'search_placeholder'}, $F('no_results_str'))]));
		}
		this.mRows.each(function(row) {
			row.displayString = this.getDisplayString(row);
			if (row.displayString != '') {
				if (this.mPositionResults) Element.show(this.mResultTable);
				if (this.mHeaderElement) Element.show(this.mHeaderElement);
				var currentCell = Builder.node((this.mIsReallyTable?'td':'a'), {id:this.mResultTable.id+'_'+row.entityGUID});
				currentCell.style.cursor = 'pointer';
				currentCell.dataSource = row;
				this.drawCell(currentCell);
				if (this.mIsReallyTable) {
					this.mResultTable.firstChild.appendChild(Builder.node('tr', [currentCell]));
				}
				else {
					currentCell.href = row.url;
					this.mResultTable.appendChild(Builder.node('li', [currentCell]));
				}
				observeEvents(this, currentCell, {click:'clickedUser', mouseover:'mousedOverUser', mouseout:'mousedOutUser'});
			}
		}.bind(this));
		Element.removeClassName(this.mSearchField, 'busy_field');
	},
	drawCell: function(inCell) {
		replaceElementContents(inCell, inCell.dataSource.displayString);
	}
});

var LinkSearchDialog = Class.create({
	mDialogTitle: "_Dialogs.LinkSearch.Title",
	mSearchFieldPlaceholder: "_Dialogs.LinkSearch.Search.Placeholder",
	mDialogDescription: "_Dialogs.LinkSearch.Description",
	mEntityTypes: ['com.apple.entity.Page', 'com.apple.entity.File'],
	mExcludedGUIDs: [],
	// An array of guids to exclude from search results.
	mExcludedGUIDs: null,
	initialize: function(/* [options] */) {
		if (arguments.length && arguments[0]) Object.extend(this, arguments[0]);
	},
	show: function(inAnchor, inCancelCallback, inOKCallback, inOptSearchString) {
		var tabIndexName = accessibility().requestTabIndex(CC.Accessibility.TAB_INDEX_NAME_POPUP_DIALOG_MOVE_TO_WIKI_NAME);
		var tabIndexResult = accessibility().requestTabIndex(CC.Accessibility.TAB_INDEX_NAME_POPUP_DIALOG_MOVE_TO_WIKI_RESULT);
		
		var linkSearchDialog = $('link_search_dialog');
		if (linkSearchDialog) Element.remove(linkSearchDialog);
		dialogManager().drawDialog('link_search_dialog', [
			{contents:'<input tabindex="' + tabIndexName + '" role="textbox" type="'+(browser().isWebKit?'search':'text')+'" id="link_search_dialog_q" class="search_field" placeholder="'+(this.mSearchFieldPlaceholder || "").loc()+'"+"results="10" incremental>'},
			{contents:'<ul tabindex="' + tabIndexResult + '" role="list" aria-label="' + "_Accessibility.View.SearchResult".loc() + '" id="link_search_dialog_results"></ul>'}
		], "_Dialogs.LinkSearch.Button.OK".loc(), undefined, this.mDialogTitle.loc());
		// don't send the form when the user hits return
		$('link_search_dialog').down('form').onsubmit = invalidate;
		// hook up the search field
		this.mSearchField = new LinkSearchField('link_search_dialog_q', {
			mEntityTypes: this.mEntityTypes,
			mExcludedGUIDs: this.mExcludedGUIDs,
			mResultTable: $('link_search_dialog_results'),
			mClickedItemCallback: this.handleItemClick.bind(this)
		});
		var descriptionRow = Builder.node('tr', [
			Builder.node('td', {colSpan: 2, className: 'description'}, (this.mDialogDescription || "").loc())
		]);
		Element.insert($('link_search_dialog').down('tbody'), {top: descriptionRow});
		this.mCancelCallback = inCancelCallback;
		this.mOKCallback = inOKCallback;
		dialogManager().show('link_search_dialog', this.handleCancel.bind(this), this.handleOK.bind(this), $(inAnchor), undefined, 'link_search_dialog_q');
		if (inOptSearchString) {
			$('link_search_dialog_q').value = inOptSearchString;
			this.mSearchString = inOptSearchString;
			this.mSearchField.runQuery();
		}
		
		// Temporary disabling background items when modal dialog is open in order to avoid bad tabindex-ing
		accessibility().makeRootViewsAriaHidden(false);
	},
	handleCancel: function() {				
		if (this.mCancelCallback) this.mCancelCallback();		
		
		// Bring background items back to foreground when closing modal dialog to bring back original tabindex-ing
		accessibility().makeRootViewsAriaVisible(false);
	},
	handleOK: function() {
		this.mSearchField.selectSuggestedUID();
		var dataSource = (this.mSearchField.mChosenDataSource || {})
		if (this.mOKCallback) this.mOKCallback(dataSource.entityURL, (this.mSearchString || dataSource.entityLongName));
		delete this.mChosenUID;
		delete this.mChosenTitle;
		
		// Bring background items back to foreground when closing modal dialog to bring back original tabindex-ing
		accessibility().makeRootViewsAriaVisible(false);		
	},
	handleItemClick: function(inDisplayString, inOptURL) {
		var dataSource = (this.mSearchField.mChosenDataSource || {});
		this.mChosenUID = dataSource.entityGUID;
		this.mChosenTitle = dataSource.entityLongName;
		return false;
	}
});

var LinkSearchField = Class.create(SearchFieldBase, {
	mEntityTypes: null,
	mExcludedGUIDs: null,
	mPositionResults: false,
	mCaptureReturnChar: true,
	mSelectOnClick: true,
	gotSearchResult: function(inRows) {
		this.mRows = (inRows || []);
		this.draw();
		this.mTimer = null;
	},
	getDisplayString: function(inRow) {
		return inRow.entityLongName || inRow.entityGUID;
	},
	clickedUser: function(e) {
		e.stop();
		this.suggestUID(Event.findElement(e, 'a').dataSource.entityGUID);
		return false;
	},
	constructQuery: function(inSearchString) {
		var searchString;
		if (inSearchString && inSearchString != "") searchString = inSearchString;
		var query = server_proxy().searchQuery(searchString, this.mEntityTypes, 0, 10);
		var callback = function(response) {
			if (response) {
				var r, rentity, rows = [];
				for (var rdx = 0; rdx < response.length; rdx++) {
					r = response[rdx];
					if (r && r.entity) {
						rentity = r.entity;
						if (this.mExcludedGUIDs && this.mExcludedGUIDs.length) {
							if (this.mExcludedGUIDs.indexOf(rentity.guid) > -1) continue;
						}
						rows.push({
							'entityGUID': rentity.guid,
							'entityType': rentity.type,
							'entityURL': CC.entityURL(rentity),
							'entityLongName': (rentity.longName || rentity.shortName)
						});
					}
				}
				return this.gotSearchResult(rows);
			}
			this.mTimer = null;
		}.bind(this);
		return server_proxy().entitiesForSearchQuery(query, callback, callback);
	},
	fieldChanged: function(e) {
		if (!this.mTimer) this.mTimer = setTimeout(this.runQuery.bind(this), this.mInterval);
	},
	handleChanged: function(e) {
		// statically displayed results table, so we shouldn't do the normal hiding stuff in this subclass
	}
});

var UserSearchField = Class.create(SearchFieldBase, {
	mSortKey: 'displayName',
	mValueKey: 'displayName',
	mMinQueryChars: 3,
	mSearchCancelledCallback: function() {
		this.mResultTable.hide();
	},
	filterTagInput: function(inTagName) {
		return inTagName.replace(/[\t\r\n]/g, ' ').replace(/^\s+/, '').replace(/\s+$/, '');
	},
	getDisplayString: function(inRow) {
		return inRow['entityUserLongName'] + ' (' + inRow['entityUserLogin'] + ')';
	},
	constructQuery: function(inSearchString) {
		if (!inSearchString) return;
		server_proxy().odRecordsMatching(inSearchString, this.gotSearchResult.bind(this), function() { this.mTimer = null; }.bind(this));
	},
	gotSearchResult: function(inResponse) {
		this.mRows = inResponse.collect(function(aRow) {
			var anItem = {
				entityUserLogin: aRow.login,
				entityUserLongName: (aRow.longName || aRow.login),
				entityGUID: aRow.externalID,
				url: "#"
			}
			return anItem;
		})
		this.draw();
		this.mTimer = null;
	},
	updatePosition: function($super) {
		$super();
		this.mResultTable.setStyle({
			'top': parseInt(this.mResultTable.getStyle('top'), 10) - 1 + 'px',
			'width': this.mResultTable.getWidth() - 4 + 'px'
		});
	}
});

var TagSearchField = Class.create(UserSearchField, {
	mSearchPath: '/tags/autocomplete',
	getDisplayString: function(inRow) {
		return inRow.entityGUID;
	},
	gotSearchResult: function(inResponse) {
		this.mRows = inResponse.responseJSON.each(function(row) { row.url = "#"; });
		this.draw();
		this.mTimer = null;
	},
	constructQuery: function(inSearchString) {
		if (!inSearchString) return;
		var url = "%@%@?keyword=%@".fmt(env().root_path, this.mSearchPath, inSearchString);
		return new Ajax.Request(url, {
			method: 'get',
			contentType: 'application/json',
			requestHeaders: { Accept: 'application/json' },
			onSuccess: this.gotSearchResult.bind(this),
			onFailure: function() { this.mTimer = null }.bind(this)
		});
	}
});
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.

var Environment = Class.createWithSharedInstance('env');
Environment.prototype = {
	root_path: "/wiki",
	initialize: function () {}
};
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.



// A unified way of displaying notification messages.

CC.Notifier = CC.Notifier || new Object();

// Allowed notification states.

CC.Notifier.NORMAL_STATE = 'normal';
CC.Notifier.BUSY_STATE = 'busy';
CC.Notifier.FAILED_STATE = 'failed';
CC.Notifier.SUCCEEDED_STATE = 'succeeded';

// Model class for a queued notification.

CC.Notifier.Notification = Class.create({
	mDisplayString: null,
	mDisplayParams: null,
	mState: CC.NOTIFIER_MESSAGE_STATE_NORMAL,
	initialize: function(/* [inOptions] */) {
		if (arguments.length > 0 && arguments[0]) Object.extend(this, arguments[0]);
		return this;
	},
	// Private.
	mCompleted: false
});

// Global notifier shared instance.

CC.Notifier.DID_QUEUE_NOTIFICATION = 'DID_QUEUE_NOTIFICATION';
CC.Notifier.DID_UPDATE_NOTIFICATION = 'DID_UPDATE_NOTIFICATION';

var Notifier = Class.createWithSharedInstance('notifier');
Notifier.prototype = {
	// Track the current queue of notifications.
	mNotificationQueue: new Array(),
	// Track all registered notifications.
	mNotifications: new Hash(),
	// Track the currently dispatched notification.
	mActiveNotification: null,
	mNextNotificationIdentifer: 0,
	mTimeout: 1500,
	mFinalDelay: 3000,
	mShowNotifications: false,
	mShowErrorNotifications: true,
	initialize: function() {
		this.render();
		globalNotificationCenter().subscribe(CC.Notifier.DID_QUEUE_NOTIFICATION, this.dispatchNotification.bind(this));
		globalNotificationCenter().subscribe(CC.Notifier.DID_UPDATE_NOTIFICATION, this.updateAndDispatch.bind(this));
		this._initializeInlineContent();
	},
	// Initializes any inline flash messages from the server on load.
	_initializeInlineContent: function() {
		var payload = $('notifier');
		if (!payload) return;
		var alert = payload.down('.alert').innerHTML;
		var notice = payload.down('.notice').innerHTML;
		if (alert && alert != "") this.queueNotificationWithParams(error, undefined, CC.Notifier.FAILED_STATE);
		if (notice && notice != "") this.queueNotificationWithParams(notice);
	},
	// Renders and appends the notification chrome.
	render: function() {
		this.mParentElement = Builder.node('div', {className: 'notifier hidden'}, [
			Builder.node('div', {className: 'content'})
		]);
		document.body.appendChild(this.mParentElement);
	},
	redraw: function() {
		var active = this.mActiveNotification;
		if (!active || !active.mDisplayString) return;
		var displayString = active.mDisplayString;
		var localized = displayString.loc.apply(displayString, active.mDisplayParams || []);
		// Update the display string.
		this.mParentElement.down('.content').innerHTML = localized;
		// Update the state.
		var state = active.mState || CC.Notifier.NORMAL_STATE;
		['normal', 'busy', 'failed', 'succeeded'].each(function(klass) {
			this.mParentElement.removeClassName(klass);
		}, this);
		this.mParentElement.addClassName(state);
	},
	// Hide/show the notification widget. Uses CSS transitions for animation.
	hide: function() {
		this.mParentElement.addClassName('hidden');
	},
	show: function() {
		if (browser().isMobileSafari()) {
			var notification = this.mActiveNotification;
			var displayString = notification.mDisplayString;
			var localized = displayString.loc.apply(displayString, notification.mDisplayParams || []);
			alert(localized);
		} else {
			this.mParentElement.show();
			setTimeout(function() {
				this.redraw();
				this.mParentElement.removeClassName('hidden');
			}.bind(this), 250);
		}
	},
	// Queues a simple notification.
	printMessage: function(inString) {
		return this.queueNotificationWithParams(inString);
	},
	// Queues a simple error notification.
	printErrorMessage: function(inString) {
		var result = this.queueNotificationWithParams(inString, undefined, CC.Notifier.FAILED_STATE);
		return result;
	},
	printBusyMessage: function(inString) {
		return this.queueNotificationWithParams(inString, undefined, CC.Notifier.BUSY_STATE);
	},
	// Pushes a new notification onto the notification queue to be displayed at
	// the next available opportunity. Returns undefined where a notification
	// could not be added, or a notification identifer where the notification was
	// successfully queued. You can use the notification identifer to cancel or
	// update the notification later.
	queueNotification: function(inNotification) {
		if (!inNotification) return undefined;
		var identifier = this.mNextNotificationIdentifer;
		this.mNotifications.set(this.mNextNotificationIdentifer, inNotification);
		this.mNotificationQueue.push(inNotification);
		this.mNextNotificationIdentifer += 1;
		globalNotificationCenter().publish(CC.Notifier.DID_QUEUE_NOTIFICATION, inNotification);
		return identifier;
	},
	queueNotificationWithParams: function(inDisplayString, inDisplayParams, inState) {
		if (inState != CC.Notifier.FAILED_STATE && !this.mShowNotifications) return;
		if (inState == CC.Notifier.FAILED_STATE && !this.mShowErrorNotifications) return;
		var notification = new CC.Notifier.Notification({
			mDisplayString: inDisplayString,
			mDisplayParams: inDisplayParams,
			mState: inState
		});
		return this.queueNotification(notification);
	},
	// Updates an existing notification in the notification queue. Expects a
	// valid notification identifier (returned by addNotification) and a hash
	// of attribute changes. Allowed attributes are mDisplayString,
	// mDisplayParams and mState.
	updateNotification: function(inNotificationID, inUpdates) {
		if (inNotificationID == undefined || !this.mNotifications.get(inNotificationID) || !inUpdates) return false;
		var notification = this.mNotifications.get(inNotificationID);
		if (notification == this.mActiveNotification) this._pendingUpdate = true;
		Object.extend(notification, inUpdates);
		globalNotificationCenter().publish(CC.Notifier.DID_UPDATE_NOTIFICATION, notification, {
			notificationID: inNotificationID,
			updates: inUpdates
		});
		return true;
	},
	// Dispatches the first queued notification.
	dispatchNotification: function() {
		// Dispatch later if a change is-a-pending.
		if (this._pendingUpdate) {
			if (this.mDispatchTimeout) clearTimeout(this.mDispatchTimeout);
			this.mDispatchTimeout = setTimeout(function() {
				this._pendingUpdate = false;
				this._dispatch();
			}.bind(this), this.mTimeout);
		}
		// Dispatch later if we're already dispatching.
		if (this._dispatching) return;
		// Otherwise dispatch.
		this._dispatching = true;
		var queue = this.mNotificationQueue;
		// Mark any in-progress notifications as done.
		var active = this.mActiveNotification;
		if (active) active.mCompleted = true;
		// Pop the next notification in the queue.
		var notification = queue.shift();
		// Bail if the queue was actually empty.
		if (!notification && queue.length == 0) {
			this._dispatching = false;
			// Delay hiding the last notification.
			if (this.mTimer) clearTimeout(this.mTimer);
			this.mTimer = setTimeout(function() {
				this.hide();
				setTimeout(function() {
					this.mParentElement.hide();
				}.bind(this), 400);
			}.bind(this), this.mFinalDelay);
			return;
		}
		// Cache and recurse.
		if (notification) this.mActiveNotification = notification;
		this.hide();
		this.show();
		if (this.mTimer) clearTimeout(this.mTimer);
		this.mTimer = setTimeout(this._dispatch.bind(this), this.mTimeout);
	},
	updateAndDispatch: function() {
		this.redraw();
		this.dispatchNotification();
	},
	_dispatch: function() {
		// It's safe to dispatch if we're not pending an update or busy.
		var pending = this._pendingUpdate == undefined ? false : this._pendingUpdate;
		var busy = (this.mActiveNotification && (this.mActiveNotification.mState == CC.Notifier.BUSY_STATE));
		if (busy) this._pendingUpdate = true;
		if (!pending && !busy) this._dispatching = false;
		this.dispatchNotification();
	}
};
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.



var QTMediaExpander = Class.createWithSharedInstance('qtMediaExpander', true);
QTMediaExpander.prototype = {
	initialize: function() {
		bindEventListeners(this, ['handleClick']);
		this.mEmbedFrameID = 0;
		this.findMedia();
		globalNotificationCenter().subscribe('DIALOG_WILL_SHOW', function(){this.collapseAllMedia()}.bind(this));
		globalNotificationCenter().subscribe('DIALOG_HIDDEN', function(){this.findMedia()}.bind(this));
	},
	findMedia: function() {
		$$('img.posterimg').each(function(img) {
			if (img.onclick != this.handleClick) {
				img.onclick = this.handleClick;
				img.setAttribute('tabindex','0');
				img.setAttribute('role','button');
			}
		}.bind(this));
	},
	collapseAllMedia: function() {
		$$('div.qtmedia').each(function(div) {
			var img = div.next('img');
			if (!img || !img.hasClassName('posterimg')) return false;
			div.remove();
			img.show();
			img.setAttribute('tabindex','0');
			img.setAttribute('role','button');
		});
		$$('img.posterimg').each(function(img) {
			img.onclick = invalidate;
		});
	},
	expandPosterImage: function(inPosterImage, inOptBackgroundColor) {
		if (!inPosterImage) return false;
		var mediaProperties = {
			'src': inPosterImage.getAttribute('longdesc') || inPosterImage.getAttribute('name') || inPosterImage.getAttribute('alt'),
			'width': inPosterImage.width,
			'height': inPosterImage.height
		}
		return this.expandMedia(mediaProperties, inPosterImage, undefined, inOptBackgroundColor);
	},
	expandMedia: function(inMediaProperties, inOptPosterImage, inOptParentElement, inOptBackgroundColor) {
		var src = inMediaProperties.src;
		var width = inMediaProperties.width;
		var height = inMediaProperties.height;
		var backgroundColor = (inOptBackgroundColor || '#FFFFFF');
		var parentElement = $(inOptParentElement) || document.body;
		var posterImage = $(inOptPosterImage);
		if (src && src != '' && width && height) {
			var useHTML5Controls = (browser().isiPad() || browser().isiPhone() || browser().isSafari5Plus());
			var extendHeight = (!useHTML5Controls && height >= 20);
			var wrapper = Builder.node('div', {id:'qtmovie1', className:'qtmedia', style:'width:'+width+'px;height:'+(height+(extendHeight?12:0))+'px'});
			// Append an auth token in case the plugin fails to forward cookies.
			var matches = document.cookie.match(/cc.collabd_session_guid=([a-zA-Z0-9\-]+)/)
			if (matches && matches[1] && !src.match(/auth_token=/)) {
				src += ('?auth_token=' + matches[1] + '&qt=true');
			} else {
				src += '?qt=true';
			}
			// Do we have a poster image?
			if (posterImage) {
				posterImage.parentNode.insertBefore(wrapper, posterImage);
			} else {
				parentElement.appendChild(wrapper);
			}
			if (useHTML5Controls) {
				wrapper.innerHTML = '<video src="'+src+'" width="'+width+'" height="'+height+'" controls autoplay></video>';
				if (posterImage) Element.hide(posterImage);
				// Force autoplay of HTML5 video tags.
				var videoElement = wrapper.down('video');
				if (videoElement) {
					videoElement.load();
					videoElement.play();
				}
				return true;
			}
			// Build an object/embed combination that we can append to the page.
			var envFunction = ((window.env == undefined) ?  window.parent.env() : env()); // Handle iFrames used for migrated content
			var fakeqti = envFunction.root_path + '/__collabd/coreclientbase/static/fake.qti';
			var objectHTMLWithoutClosingTag = '<object classid="clsid:02BF25D5-8C17-4B23-BC80-D3488ABDDC6B" width="'+width+'" height="'+(height+(extendHeight?16:0))+'" codebase="http://www.apple.com/qtactivex/qtplugin.cab"><param name="SRC" value="/static/fake.qti"><param name="QTSRC" value="'+src+'"><param name="TYPE" value="video/quicktime"><param name="SCALE" value="aspect"><param name="AUTOPLAY" value="true"><param name="CONTROLLER" value="true"><param name="TARGET" value="myself"><param name="BGCOLOR" value="'+backgroundColor+'">';
			var objectHTML = objectHTMLWithoutClosingTag+'<embed src="'+fakeqti+'" qtsrc="'+src+'" type="video/quicktime" autoplay="true" controller="true" target="myself" bgcolor="'+backgroundColor+'" width="'+width+'" height="'+(height+(extendHeight?16:0))+'" pluginspage="http://www.apple.com/quicktime/download/" scale="aspect" />'+'</object>';
			// IE requires that the plugin be written using document.write at page load time, so we must create an iframe
			if (browser().isIE()) {
				var frmID = 'qFrame'+(this.mEmbedFrameID++);
				var qFrame = Builder.node('iframe', {border:'0', frameborder:'0', id:frmID, name:frmID, style:'width:'+width+'px;height:'+(height+(extendHeight?16:0))+'px;border:0;overflow:hidden'});
				wrapper.appendChild(qFrame);
				$(frmID).contentWindow.document.write('<html><body style="padding:0;margin:0;overflow:hidden">'+objectHTML.replace(/<object/, '<object id="qtmovie1"')+'</body></html>');
				if (posterImage) Element.hide(posterImage);
				var attempts = 0;
				var checkForPlayer = function() {
					try {
						$(frmID).contentWindow.document.qtmovie1.Play();
					}
					catch(e) {
						if (++attempts > 10) return false;
						setTimeout(checkForPlayer, 1000);
					}
				}
				setTimeout(checkForPlayer, 1000);
			}
			else {
				wrapper.innerHTML = objectHTML;
				// Safari demands that you hide the image last, for some reason.
				if (posterImage) Element.hide(posterImage);
			}
		}
	},
	handleClick: function(inEvent) {
		var img = Event.element(inEvent);
		this.expandPosterImage(img);
	}
};
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.



// A controlled explosion of smoke.

var Smokey = Class.createWithSharedInstance('smokey');
Smokey.prototype = {
	mWidth: 42,
	mHeight: 42,
	mPoofFrameDelay: 90,
	initialize: function() {
		this.mParentElement = document.createElement('div');
		Element.extend(this.mParentElement);
		this.mParentElement.addClassName('smokey').hide();
		document.body.appendChild(this.mParentElement);
	},
	showOverElement: function(elementId) {
		if (!elementId) return null;
		var element = $(elementId);
		if (!element) return null;
		if (element.getStyle('display') == "none") return null;
		Position.clone(element, this.mParentElement, {
			setWidth: false,
			setHeight: false,
			offsetLeft: (element.offsetWidth / 2) - (this.mWidth / 2),
			offsetTop: (element.offsetHeight / 2) - (this.mHeight / 2)
		});
		this.show();
	},
	showAtPosition: function(inPosition) {
		if (!inPosition || !inPosition.left || !inPosition.top) return null;
		this.mParentElement.setStyle({
			'left': inPosition.left + 'px',
			'top': inPosition.top + 'px'
		});
		this.show();
	},
	show: function() {
		this.mParentElement.show();
		this.mCurrentFrame = 0;
		if (this.mTimer) clearTimeout(this.mTimer);
		this.mTimer = setTimeout(this.handleTimerFired.bind(this), this.mPoofFrameDelay);
	},
	handleTimerFired: function() {
		if (this.mCurrentFrame < 5) {
			this.mCurrentFrame++;
			var x = this.mCurrentFrame * this.mHeight * (-1);
			this.mParentElement.style.backgroundPosition = '0px ' + x + 'px';
			this.mTimer = setTimeout(this.handleTimerFired.bind(this), this.mPoofFrameDelay);
		}
		else {
			this.mParentElement.hide();
			delete this.mTimer;
		}
	}	
};
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.

// Scroller capable of scrolling an element inside a overflow scroll container.

CC.Scroller = Class.create({
	initialize: function(/* [options] */) {
		if (arguments.length && arguments[0]) Object.extend(this, arguments[0]);
	},
	scrollToInContainer: function(inElement, inContainer) {
		var elem = $(inElement), container = $(inContainer);
		if (!elem || !container) return true;
		// var containerOffsetTop = container.cumulativeOffset().top;
		var containerHeight = container.getLayout().get('padding-box-height');
		// Find the offset of the child element.
		var elementPositionOffset = Element.positionedOffset(elem);
		// var elementOffsetTop = Element.cumulativeOffset(elem).top;
		// var elementScrollOffsetTop = Element.cumulativeScrollOffset(elem).top;
		var elementHeight = elem.getLayout().get('padding-box-height');
		// Calculate the scroll.
		var scrollFrom = container.scrollTop;
		var containerMidpoint = container.scrollTop + Math.floor(containerHeight / 2);
		var scrollTo = elementPositionOffset.top;
		if (elementPositionOffset.top > containerMidpoint) scrollTo = (elementPositionOffset.top + elementHeight - containerHeight);
		// Scroll, but only if we have to.
		var topEdgeInBounds = (elementPositionOffset.top >= scrollFrom);
		var bottomEdgeInBounds = ((elementPositionOffset.top + elementHeight) <= (scrollFrom + containerHeight));
		if (topEdgeInBounds && bottomEdgeInBounds) return;
		if (this.mScrollEffect) this.mScrollEffect.cancel();
		this.mScrollEffect = new Effect.Tween(container,
			scrollFrom,
			scrollTo,
			{duration: 0.4},
			function(p) { container.scrollTop = p.round(); }
		);
	},
	scrollTo: function(inElement) {
		return Element.scrollTo(inElement);
	}
});
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.





// Base view class.

CC.Mvc.View = Class.create(CC.Object, CC.Keyboard.Mixins.Responder, {
	// The content of this view. Expected to be a CC.Mvc.ObjectController.
	mContent: null,
	// The root element of this view.
	mParentElement: null,
	// Has this view rendered yet?
	mRendered: false,
	// Is this view displayed or hidden?
	mIsVisible: false,
	// The subviews of this view.
	mSubviews: null,
	// The parent view for this view (if it exists).
	mSuperview: null,
	// The class name(s) for this view.
	mClassName: null,
	mClassNames: null,
	// Minimum loading spinner duration for this view.
	mMinimumLoadingTimer: 250,
	initialize: function($super) {
		$super.apply(null, Array.prototype.slice.call(arguments, 1));
		this.mSubviews = new Array();
	},
	// Returns the current rendered version of this view, or optionally a child
	// of this view matching a given selector.
	$: function(inOptSelector) {
		if (inOptSelector) {
			var result = this.mParentElement.select(inOptSelector);
			if (CC.typeOf(result) == CC.T_ARRAY) return result[0];
			return result;
		}
		return this.mParentElement;
	},
	// Forces a render of this view.
	forceRender: function() {
		if (this.rendered()) return this.mParentElement;
		return this._render();
	},
	// Private function for rendering and caching this view. You should not
	// normally override this method. Registers event handlers for this view.
	_render: function() {
		var rendered = this.render();
		if (!rendered) rendered = document.createElement('div');
		rendered.addClassName('cc-view');
		this.handleDidRenderView({'element': Element.extend(rendered)});
		if (this.mClassName) this.mParentElement.addClassName(this.mClassName);
		if (this.mClassNames) this.mParentElement.addClassName(this.mClassNames.join(" "));
		this.makeAccessible();
		return this.mParentElement;
	},
	// Renders and attaches any necessary event handlers to this view. Returns a DOM
	// node ready to be appended to the page.
	render: function() { /* Interface */ },
	// Private function for rendering this view as an HTML fragment. You should not normally
	// override this method.
	_renderAsHTML: function() { /* Interface */ },
	// Renders and returns the contents of this view as an HTML fragment. Returns a tuple of
	// fragment identifier and fragment content. It is expected that the fragment identifer
	// returns corresponds to a class name that can be used to query the DOM later.
	renderAsHTML: function() { /* Interface */ },
	// Make views accessible using the accessible OS X feature
	makeAccessible: function() { /* Interface */},	
	// Private function for registering event handlers. You should not normally override this
	// method.
	_registerEventHandlers: function() {
		this.registerEventHandlers();
	},
	// Is this view rendered?
	rendered: function() {
		return (this.mRendered == true);
	},
	// Registers any event handlers on your rendered view. Called once the view has been
	// rendered and appended to the DOM.
	registerEventHandlers: function() { /* Interface */ },
	// Private observer of view rendering. You should not normally override this method.
	handleDidRenderView: function(inOptInfo) {
		if (inOptInfo && inOptInfo.element) {
			this.mParentElement = Element.extend(inOptInfo.element);
			this._registerEventHandlers();
			this.mRendered = this.mIsVisible = true;
			if (browser().isMobileSafari()) {
				this.mParentElement.select('.clickable').each(function(clickable) {
					clickable.setAttribute('onclick', "function() { return false; }");
				});
			}
		}
	},
	// Appends a subview to this view (by tracking the view instance and appending its
	// rendered element to the parent view of this element). Note that calling this will
	// automatically render the passed subview if it has not yet been drawn. Accepts an
	// optional selector argument that can be used when you want to append this child view
	// at a specific position in the tree of this rendered view.
	addSubview: function(inSubview, inOptPositionSelector, inOptInsertAtTop) {
		if (!CC.kindOf(inSubview, CC.Mvc.View)) {
			logger().error("Cannot append %o as a subview because it does not appear to be a CC.Mvc.View", inBlock);
			return undefined;
		}
		if (!this.mRendered) this._render();
		if (!inSubview.mRendered) inSubview._render();
		this.mSubviews.push(inSubview);
		inSubview.mSuperview = this;
		if (inOptPositionSelector) {
			var selected = this.mParentElement.down(inOptPositionSelector);
			if (selected) {
				if (inOptInsertAtTop) {
					Element.insert(selected, {'top': inSubview.mParentElement});
				} else {
					selected.appendChild(inSubview.mParentElement);
				}
				return;
			}
		}
		if (inOptInsertAtTop) {
			Element.insert(this.mParentElement, {'top': inSubview.mParentElement});
		} else {
			this.mParentElement.appendChild(inSubview.mParentElement);
		}
	},
	// Adds a subview to this view (as above), but allows you to specify where it should
	// appear within the view hierarchy.
	insertSubviewAtIndex: function(inSubview, inIndex, inOptPositionSelector) {
		if (!CC.kindOf(inSubview, CC.Mvc.View)) {
			logger().error("Cannot append %o as a subview because it does not appear to be a CC.Mvc.View", inBlock);
			return undefined;
		}
		
		var container = this.mParentElement;
		if (inOptPositionSelector) {
			container = this.mParentElement.down(inOptPositionSelector) || this.mParentElement;
		}
		
		var children = Element.childElements(container);
		if (inIndex < 0 || inIndex > children.length) {
			logger().error("Cannot append %o as a subview because the index %d is invalid", inSubview, inIndex);
			return undefined;
		}
		
		if (!this.mRendered) this._render();
		if (!inSubview.mRendered) inSubview._render();
		this.mSubviews.push(inSubview);
		inSubview.mSuperview = this;
		
		if (inIndex == children.length) {
			container.appendChild(inSubview.mParentElement);
		} else {
			Element.insert(children[inIndex], {'before': inSubview.mParentElement});
		}
	},
	// Removes a given array of subviews from this view.
	removeSubviews: function(inSubviews) {
		var currentSubviews = this.mSubviews, subviewsToRemove = (inSubviews || []), subviewsToKeep = [], subview, subviewElement;
		for (var idx = 0; idx < currentSubviews.length; idx++) {
			subview = currentSubviews[idx];
			if (subviewsToRemove.indexOf(subview) != -1) {
				subviewElement = subview.$();
				if (subviewElement && subviewElement.parentNode) {
				    subviewElement.parentNode.removeChild(subviewElement);
				}
			} else {
				subviewsToKeep.push(subview);
			}
		}
		this.mSubviews = subviewsToKeep;
	},
	// Removes all subviews from this view.
	removeAllSubviews: function() {
		this.removeSubviews(this.mSubviews);
	},
	// Helper functions for hiding/showing this view.
	setVisible: function(inShouldBeVisible) {
		if (inShouldBeVisible == true) {
			Element.show(this.mParentElement);
			this.mIsVisible = true;
		} else {
			Element.hide(this.mParentElement);
			this.mIsVisible = false;
		}
	},
	// Marks this view as loading.
	markAsLoading: function(inShouldBeLoading) {
		if (inShouldBeLoading == true) {
			this.mParentElement.addClassName('loading');
			this.mIsLoading = true;
		} else {
			if (this.mMarkAsLoadingFalseTimer) clearTimeout(this.mMarkAsLoadingFalseTimer);
			this.mMarkAsLoadingFalseTimer = setTimeout(function() {
				this.mParentElement.removeClassName('loading');
				this.mIsLoading = false;
			}.bind(this), this.mMinimumLoadingTimer);
		}
	}
});
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.




// Base object controller class.

CC.Mvc.ObjectController = Class.create(CC.Object, {
	mStore: null,
	mRecord: null,
	mViewInstance: null,
	// Safe methods for getting and setting model properties on this record backing this
	// object controller. Any changes to the record go through the store.
	// Returns a property at a given path for the record managed by this controller.
	// Returns undefined where the property or record itself doesn't exist.
	getRecordPropertyForPath: function(inPropertyPath, inDefaultValue) {
		if (!inPropertyPath || !this.mRecord) return undefined;
		var property = CC.objectForPropertyPath(inPropertyPath, this.mRecord);
		return (property != undefined ? property : inDefaultValue);
	},
	// Updates the record backing this object controller with a new value for a given
	// property path. Returns true if the property was successfully updated, and false
	// otherwise.
	setRecordPropertyForPath: function(inPropertyPath, inValue) {
		if (!inPropertyPath || !this.mStore || !this.mRecord) return undefined;
		return this.mStore.pushChangeForObject(this.mRecord, inPropertyPath, inValue);
	},
	// Updates the record backing this object controller using a deferred callback.
	setRecordPropertyForPathUsingDeferred: function(inPropertyPath, inDeferredCallback) {
		if (!inPropertyPath || !this.mStore || !this.mRecord) return undefined;
		return this.mStore.pushChangeForObjectUsingDeferred(this.mRecord, inPropertyPath, inDeferredCallback);
	}
});
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.




// Base view controller class.

CC.Mvc.ViewController = Class.create(CC.Object, {
	mViewInstance: null
});
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.






;
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.




// A view that behaves as a panel inside a panel set.

CC.PanelView = Class.create(CC.Mvc.View, {
	getParent: function() {
		return this._parent;
	},
	setParent: function(parent) {
		this._parent = parent;
	},
	select: function() {
		this.getParent().select(this);
	},
	isSelected: function() {
		return (this.getParent().selected() == this);
	},
	setVisible: function($super, inShouldBeVisible) {
		$super(inShouldBeVisible);
		var field = this.$().down('input[type="text"], textarea');
		if (field) field.focus();
	}
});

// A class for a set of ordered views (that include the CC.PanelMixin mixin).

CC.PanelSet = Class.create({
	_panels: null,
	_selected: null,
	initialize: function() {
		this._panels = [];
	},
	add: function(panel) {
		panel.setParent(this);
		this._panels.push(panel);
	},
	remove: function(panel) {
		panel.setParent(null);
		this._panels = this._panels.without(panel);
	},
	select: function(panel) {
		this._panels.each(function(p) {
			p.setVisible(p == panel);
		});
		this._selected = panel;
	},
	first: function() { return this._panels.first(); },
	last: function() { return this._panels.last(); },
	all: function() { return this._panels; },
	selected: function() { return this._selected; },
	previous: function() { return this._selectedOffset(-1); },
	next: function() { return this._selectedOffset(1); },
	itemAtIndex: function(idx) { return this._panels[idx]; },
	_selectedOffset: function(offset) {
		var firstIdx  = 0;
		var lastIdx   = this._panels.length - 1;
		var offsetIdx = this._panels.indexOf(this.selected()) + offset;
		if (offsetIdx < firstIdx) {
			offsetIdx = lastIdx;
		} else if (offsetIdx > lastIdx) {
			offsetIdx = firstIdx;
		}
		return this._panels[offsetIdx];
	}
});
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.

// An error view class.

CC.ErrorMessageView = Class.create(CC.Mvc.View, {
	mErrorMessage: "",
	render: function() {
		return Builder.node('div', {className: 'cc-error-message-view error'}, [
			Builder.node('p', this.mErrorMessage)
		]);
	}
});
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.

CC.Menu = Class.create({

	initialize: function(element, anchor, inOptBeforeShowCallback) {
		var element = $(element);
		if (element.parentNode) element.remove();
		element.show();
		
		this.menu = $(Builder.node('div'));
		this.menu.addClassName('cc-menu');
		this.menu.setStyle({
			position: 'absolute',
			zIndex: '800'
		});
		this.menu.insert(element);
		this.menu.hide();
		this.menu.on('click', this.onMenuClick.bindAsEventListener(this));
		
		this.anchor = $(anchor);
		this.anchor.on('click', this.onAnchorClick.bindAsEventListener(this));
		
		this.mask = $(Builder.node('div'));
		this.mask.addClassName('cc-menu-mask');
		this.mask.setStyle({
			position: 'fixed',
			top: '0px',
			bottom: '0px',
			left: '0px',
			right: '0px',
			zIndex: '700'
		});
		this.mask.on('click', this.onMaskClick.bindAsEventListener(this));
		this.mask.hide();
		
		if (inOptBeforeShowCallback) this.mBeforeShowCallback = inOptBeforeShowCallback;
		
		if (window.orientation || window.orientation === 0)
			this.menu.on('orientationchange', this.onOrientationChange.bindAsEventListener(this));
		
		document.body.appendChild(this.mask);
		document.body.appendChild(this.menu);
	},
	
	onMenuClick: function(e) {
		this.close();
	},
	onAnchorClick: function(e) {
		e.stop();
		this.open();
	},
	onMaskClick: function(e) {
		e.stop();
		this.close();
	},
	
	onOrientationChange: function() {
		if (this.anchor.up('li')) this.anchor.up('li').removeClassName('open');
		this.mask.hide();
		this.menu.hide();
	},
	
	open: function() {
		if (this.anchor.up('li')) this.anchor.up('li').addClassName('open');
		this.positionElementToAnchor();
		this.mask.show();
		this.menu.show();
		if (this.mBeforeShowCallback) this.mBeforeShowCallback();
	},
	close: function() {
		if (this.anchor.up('li')) this.anchor.up('li').removeClassName('open');
		this.mask.hide();
		this.menu.hide();
	},
	toggle: function() {
		this.menu.visible() ? this.close() : this.open();
	},
	
	positionElementToAnchor: function() {
		this.menu.show();
		var mLayout = this.menu.getLayout();
		var aLayout = this.anchor.getLayout();
		this.menu.clonePosition(this.anchor, {
			setWidth:   false,
			setHeight:  false,
			offsetTop:  aLayout.get('border-box-height') - 2, // 2px  is to account for the difference between the real and apparent boundaries of the anchor, because of the use of a background image to simulate the anchor borders
			offsetLeft: aLayout.get('border-box-width') - mLayout.get('border-box-width')
		});
		this.menu.hide();
	},
	
	destroy: function() {
		this.anchor.stopObserving('click', this.onAnchorClick.bindAsEventListener(this));
		Element.remove(this.menu);
		Element.remove(this.mask);
		delete this;
	}

});

// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.






CC.FILTER_BAR_DID_CHANGE_KEYWORD = "FILTER_BAR_DID_CHANGE_KEYWORD";
CC.FILTER_BAR_DID_CHANGE_FILTER = "FILTER_BAR_DID_CHANGE_FILTER";
CC.FILTER_BAR_DID_CHANGE_SORT_KEY = "FILTER_BAR_DID_CHANGE_SORT_KEY";

// Default filtering/sorting options.

CC.FILTER_BAR_ALLOWED_FILTERS = ['everything', 'unread', 'favorites'];
CC.FILTER_BAR_ALLOWED_SORT_KEYS = $H({
	'title': '-longName'
});

// Basic filter bar view.

CC.FilterBarView = Class.create(CC.Mvc.View, {
	mKeyword: null,
	mTags: [],
	mFilter: 'everything',
	// mSortKey is the query-compatible key.
	mSortKey: '+longName',
	// _mSortKey is the sort direction agnostic version of the sort key.
	_mSortKey: 'title',
	// Allow overriding the filters/sort keys used by this filter bar.
	mAllowedFilters: CC.FILTER_BAR_ALLOWED_FILTERS,
	mAllowedSortKeys: CC.FILTER_BAR_ALLOWED_SORT_KEYS,
	// Format strings (substituted with capitilized filter/sort keys at runtime).
	mFilterTitleFormatString: "_FilterBarView.Filters.%@.Title",
	mFilterTooltipFormatString: "_FilterBarView.Filters.%@.Tooltip",
	mSortKeyTitleFormatString: "_FilterBarView.SortKeys.%@.Title",
	mSortKeyTooltipFormatString: "_FilterBarView.SortKeys.%@.Tooltip",
	// Popup menu.
	mSortDirectionMenu: null,
	mFilterBarKeypressDelay: 500,
	initialize: function($super) {
		$super();
		this.mAllowedFilters = (this.mAllowedFilters || new Array());
		this.mAllowedSortKeys = (this.mAllowedSortKeys || new Hash());
	},
	render: function() {
		var filterTooltipFormat = this.mFilterTooltipFormatString;
		var filterTitleFormat = this.mFilterTitleFormatString;
		var sortTooltipFormat = this.mSortKeyTooltipFormatString;
		var sortTitleFormat = this.mSortKeyTitleFormatString;
		var currentCapitalizedSortKey = this._mSortKey.capitalizeFirstCharacter();
		var tabIndexFilterMain = accessibility().requestTabIndex(CC.Accessibility.TAB_INDEX_NAME_FILTER_MAIN);
		var tabIndexFilterSortBy = accessibility().requestTabIndex(CC.Accessibility.TAB_INDEX_NAME_FILTER_SORT_BY);
		var tabIndexFilterSortByType = accessibility().requestTabIndex(CC.Accessibility.TAB_INDEX_NAME_FILTER_SORT_BY_TYPE);
		var tabIndexFilterKeyWord = accessibility().requestTabIndex(CC.Accessibility.TAB_INDEX_NAME_FILTER_KEYWORD);
						
		var elem = Builder.node('div', {className: 'cc-filter-bar-view'}, [
			Builder.node('div', {'role': 'presentation', className: 'section first'}, this.mAllowedFilters.collect(function(filter) {
				var capitalizedFilterName = filter.capitalizeFirstCharacter();
				var button = Builder.node('a', {'tabindex': tabIndexFilterMain++, className: 'button' + (filter == this.mFilter ? ' selected' : ''), name: filter, title: filterTooltipFormat.fmt(capitalizedFilterName).loc()}, filterTitleFormat.fmt(capitalizedFilterName).loc());
				Event.observe(button, 'click', this.handleFilterButtonClicked.bind(this));
				return button;
			}, this)),
			Builder.node('div', {'tabindex': '-1', className: 'section'}),
			Builder.node('div', {'tabindex': '-1', className: 'section last'}, [
				Builder.node('div', {className: 'cc-filter-bar-view-popup'}, [
					Builder.node('a', {'tabindex': tabIndexFilterSortBy, href: '#'}, "_FilterBarView.SortBy".loc()),
					Builder.node('span', {'tabindex': tabIndexFilterSortByType, className: 'cc-filter-bar-view-popup-selected', title: sortTooltipFormat.fmt(currentCapitalizedSortKey).loc()}, sortTitleFormat.fmt(currentCapitalizedSortKey).loc()),
					Builder.node('div', {className: 'cc-filter-bar-popup-menu', style: 'display: none;'}, [
						Builder.node('ul', {className: 'items'}, this.mAllowedSortKeys.collect(function(value, index) {
							var sortKey = value[0];
							var capitalizedSortKey = sortKey.capitalizeFirstCharacter();
							var listItem = Builder.node('li', [
								Builder.node('a', {'tabindex': tabIndexFilterSortByType, 'role': 'button', className: 'button' + (sortKey == this._mSortKey ? ' selected' : ''), name: sortKey, title: sortTooltipFormat.fmt(capitalizedSortKey).loc()}, sortTitleFormat.fmt(capitalizedSortKey).loc())
							]);
							Event.observe(listItem, 'click', this.handleSortOptionClicked.bind(this));
							return listItem;
						}, this))
					])
				]),
				Builder.node('div', {className: 'cc-filter-bar-view-keyword'}, [
					Builder.node('input', {'tabindex': tabIndexFilterKeyWord, 'id': 'filter_keyword', 'type': 'text', 'placeholder': "_FilterBarView.Filter".loc()})
				])
			])
		]);
		// Observe keyup events in the filter field.
		var filterInput = elem.down('.cc-filter-bar-view-keyword input');
		Event.observe(filterInput, 'keyup', this.handleFilterInputKeyUp.bind(this));
		// Initialize the sort popup menu if we have items, otherwise hide it.
		if (this.mAllowedSortKeys.keys().length <= 0) {
			elem.down('.cc-filter-bar-view-popup').hide();
		} else {
			this.mSortDirectionMenu = new CC.Menu(elem.down('.cc-filter-bar-popup-menu'), elem.down('.cc-filter-bar-view-popup-selected'));
		}
		return elem;
	},
	makeAccessible: function() {
		// Set Navigation landmark (Filter/Nav)
		this.mParentElement.writeAttribute('role', 'navigation');
		this.mParentElement.writeAttribute('aria-label', "_Accessibility.MenuBar.Filter".loc());
				
		var navigationItems = this.mParentElement.querySelectorAll("a");
		var sortBy = this.mParentElement.querySelector('span');
		var keywordInput = this.mParentElement.querySelector('#filter_keyword');
		sortBy.writeAttribute("role", "listbox");
		keywordInput.writeAttribute("role", "search");
		
		for (var i = 0; i < navigationItems.length; i++) {			
			navigationItems[i].writeAttribute("role", "link");
		}
		
	},
	handleFilterButtonClicked: function(inEvent) {
		var source = Event.findElement(inEvent, '.button');
		if (source) this.setFilter(source.getAttribute('name'));
	},
	handleSortOptionClicked: function(inEvent) {
		var item = Event.findElement(inEvent, 'a.button');
		if (item) this.setSortKey(item.getAttribute('name'));
	},
	handleFilterInputKeyUp: function(inEvent) {
		var keyword = Event.findElement(inEvent, 'input').getValue();
		if (this.mFilterInputKeyTimer) clearTimeout(this.mFilterInputKeyTimer);
		this.mFilterInputKeyTimer = setTimeout(function() {
			this.setKeyword(keyword);
		}.bind(this), this.mFilterBarKeypressDelay);
	},
	setKeyword: function(inKeyword) {
		this.mKeyword = inKeyword;
		globalNotificationCenter().publish(CC.FILTER_BAR_DID_CHANGE_KEYWORD, this, {keyword: this.mKeyword});
	},
	setFilter: function(inFilter) {
		if (!inFilter) return false;
		this.mFilter = inFilter;
		var buttons = this.$().select('.section.first .button'), button;
		for (var bdx = 0; bdx < buttons.length; bdx++) {
			button = buttons[bdx];
			if (button) {
				button.removeClassName('selected');
				if (button.getAttribute('name') == inFilter) {
					button.addClassName('selected');
				}
			}
		}
		globalNotificationCenter().publish(CC.FILTER_BAR_DID_CHANGE_FILTER, this, {filter: this.mFilter});
	},
	setSortKey: function(inSortKey) {
		if (!inSortKey) return false;
		this._mSortKey = inSortKey;
		this.mSortKey = this.mAllowedSortKeys.get(this._mSortKey);
		// Update the currently selected filter.
		var selected = this.$().down('.cc-filter-bar-view-popup-selected');
		var capitalizedSortKey = this._mSortKey.capitalizeFirstCharacter();
		selected.setAttribute('title', this.mSortKeyTooltipFormatString.fmt(capitalizedSortKey).loc());
		selected.innerHTML = this.mSortKeyTitleFormatString.fmt(capitalizedSortKey).loc();
		// Update the popup menu.
		if (this.mSortDirectionMenu) {
			var buttons = this.mSortDirectionMenu.menu.select('.items .button');
			buttons.invoke('removeClassName', 'selected');
			var foundButton = buttons.find(function(b) {
				return (b && b.getAttribute('name') == inSortKey);
			});
			if (foundButton) foundButton.addClassName('selected');
		}
		globalNotificationCenter().publish(CC.FILTER_BAR_DID_CHANGE_SORT_KEY, this, {sortKey: this._mSortKey});
	},
	setTags: function(inTags) {
		if (inTags == undefined) return false;
		this.mTags = inTags;
		globalNotificationCenter().publish(CC.FILTER_BAR_DID_CHANGE_TAGS, this, {tags: this.mTags});
	}
});
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.






CC.DID_UPDATE_PAGINATING_LIST_VIEW = "DID_UPDATE_PAGINATING_LIST_VIEW";

// Base classes for paginating list behavior.

CC.PaginatingListView = Class.create(CC.Mvc.View, {
	mIsPaginating: false,
	mFilterBarViewClass: 'CC.FilterBarView',
	mFilterBarView: null,
	mPlaceholderString: "_General.No.Results.Found".loc(),
	mFilterBarChangedDelay: 100,
	render: function() {
		var tabIndex = accessibility().requestTabIndex(CC.Accessibility.TAB_INDEX_NAME_BOT_SUMMARY_BOTTOM);
		var tabIndexList = accessibility().requestTabIndex(CC.Accessibility.TAB_INDEX_NAME_BOT_SUMMARY_BOTTOM_LIST);
		var elem = Builder.node('div', {'tabindex': tabIndex, 'role': 'navigation', 'aria-label': "_Accessibility.View.BotList".loc(), className: 'cc-paginating-list-view'}, [
			Builder.node('div', {className: 'cc-paginating-list-view-filters'}),
			Builder.node('div', {'tabindex': tabIndexList, 'role': 'navigation', 'aria-label': "_Accessibility.View.ListView".loc(), className: 'cc-paginating-list-view-content loading'}),
			Builder.node('div', {className: 'cc-paginating-list-view-placeholder'}, this.mPlaceholderString),
			Builder.node('div', {className: 'cc-paginating-list-view-pagination', style: 'display: none;'}, "_General.Load.More".loc())
		]);
		elem.down('.cc-paginating-list-view-pagination').observe('click', this.handlePaginationLinkClicked.bind(this));
		// Append a filter bar instance.
		var konstructor = CC.objectForPropertyPath(this.mFilterBarViewClass);
		this.mFilterBarView = new konstructor();
		this.mFilterBarView._render();
		elem.down('.cc-paginating-list-view-filters').appendChild(this.mFilterBarView.$());
		var boundFilterBarChanged = this.handleFilterBarChangedNotification.bind(this);
		globalNotificationCenter().subscribe(CC.FILTER_BAR_DID_CHANGE_KEYWORD, boundFilterBarChanged, this.mFilterBarView);
		globalNotificationCenter().subscribe(CC.FILTER_BAR_DID_CHANGE_FILTER, boundFilterBarChanged, this.mFilterBarView);
		globalNotificationCenter().subscribe(CC.FILTER_BAR_DID_CHANGE_SORT_KEY, boundFilterBarChanged, this.mFilterBarView);
		globalNotificationCenter().subscribe(CC.FILTER_BAR_DID_CHANGE_TAGS, boundFilterBarChanged, this.mFilterBarView);
		return elem;
	},
	reset: function() {
		this.setIsPaginating(false);
		delete this.mPaginationState;
		this.$().down('.cc-paginating-list-view-content').innerHTML = "";
		this.$().down('.cc-paginating-list-view-content').addClassName('loading');
		this.paginate();
	},
	// Sets the paginating state of this paginating list view based on the boolean value inIsPaginating
	// that is passed. Note that if we're thought to be paginating and a pagination event comes in, it
	// will be ignored.
	setIsPaginating: function(inIsPaginating) {
		this.mIsPaginating = (inIsPaginating != undefined ? inIsPaginating : false);
		var content = this.$().down('.cc-paginating-list-view-content'), link = this.$().down('.cc-paginating-list-view-pagination');
		if (this.mIsPaginating) {
			link.addClassName('loading');
		} else {
			content.removeClassName('loading');
			link.removeClassName('loading');
		}
	},
	showPaginationLink: function(inShouldBeVisible) {
		var paginationLink = this.$().down('.cc-paginating-list-view-pagination');
		if (inShouldBeVisible) {
			paginationLink.show();
		} else {
			paginationLink.hide();
		}
	},
	setIsEmpty: function(inIsEmpty) {
		if (inIsEmpty) {
			this.$().addClassName('empty');
		} else {
			this.$().removeClassName('empty');
		}
	},
	handlePaginationLinkClicked: function(inEvent) {
		if (this.mIsPaginating) return false;
		this._paginate();
	},
	// Handle changed notifications on the filter bar view. 
	handleFilterBarChangedNotification: function(inMessage, inObject, inOptExtras) {
		// Since multiple filter bar notifications may come in in quick succession, use a timeout here
		// so we don't lose successive paginations while the previous pagination is in progress.
		if (this.mFilterBarChangedTimer) clearTimeout(this.mFilterBarChangedTimer);
		this.mFilterBarChangedTimer = setTimeout(function() {
			this.reset();
		}.bind(this), this.mFilterBarChangedDelay);
	},
	// Private wrapper function for pagination. You should not normally override this method.
	_paginate: function(inOptForcePaginate) {
		if (this.mIsPaginating && !inOptForcePaginate) return;
		this.setIsPaginating(true);
		var paginationGUID = this.mPaginationState.guid;
		var startIndex = ((this.mPaginationState.startIndex == undefined) ? 0 : this.mPaginationState.startIndex) + this.mPaginationState.previousResults.length;
		return this.paginate(paginationGUID, startIndex);
	},
	// Loads more items from the server. This is indirectly called when the pagination link is clicked
	// You should override this method to call a method in server_proxy asynchronously. You should use the
	// default pagination callback method below in doing so (and you should unless you're doing something
	// really funky).
	paginate: function(inPaginationGUID, inStartIndex) { /* Interface */ },
	// Default pagination callback.
	defaultPaginationCallback: function(inResults, inStartIndex, inTotal, inPaginationGUID) {
		this.setIsPaginating(false);
		// Is the list empty?
		this.setIsEmpty((inStartIndex == undefined || inStartIndex <= 0) && (!inResults || inResults.length == 0));
		var hasMoreResults = ((inTotal - ((inStartIndex || 0) + inResults.length)) > 0);
		// Update the pagination state.
		this.mPaginationState = {
			'previousResults': inResults,
			'startIndex': inStartIndex,
			'total': inTotal,
			'guid': inPaginationGUID,
			'hasMoreResults': hasMoreResults
		};
		// Show the paginator if we have more activity to show, otherwise hide it.
		this.showPaginationLink(hasMoreResults);
		// Render the results we got.
		if (inResults) this.renderResults(inResults);
		// Trigger a notification once the pagination is done.
		globalNotificationCenter().publish(CC.DID_UPDATE_PAGINATING_LIST_VIEW, this);
	},
	defaultPaginationErrback: function() { /* Interface */ },
	// Prepares a set of results for rendering.  You might want to override this if you're doing
	// grouping or client-side manipulation of data.
	prepareResultsForRendering: function(inResults) { /* Interface */
		return inResults;
	},
	// Renders a set of pagination results and appends them to the DOM.  You should not normally
	// override this method.
	renderResults: function(inResults, inOptAppendAtTop) {
	    if (!inResults || inResults.length == 0) return false;
		var rootElement = this.$().down('.cc-paginating-list-view-content');
		if (!rootElement) return;
		var preparedResults = this.prepareResultsForRendering(inResults) || inResults;
		var result, renderedResult;
		for (var resultIdx = 0; resultIdx < preparedResults.length; resultIdx++) {
			result = preparedResults[resultIdx];
			if (result) {
				renderedResult = this.renderResultItem(result);
				if (inOptAppendAtTop) {
					Element.insert(rootElement, {'top': renderedResult});
				} else {
					rootElement.appendChild(renderedResult);
				}
			}
		}
		globalNotificationCenter().publish(CC.Routes.NOTIFICATION_ROUTES_SHOULD_UPDATE);
	},
	// Returns a rendered DOM node for an individual pagination result item.  You should override this.
	renderResultItem: function(inResultItem) { /* Interface */ }
});
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.



CC.PAGINATING_SEARCH_QUERY_LIST_ALLOWED_FILTERS = ['everything', 'favorites'];
if (CC.meta('x-apple-user-is-admin') == "true") {
	CC.PAGINATING_SEARCH_QUERY_LIST_ALLOWED_FILTERS.push('deleted');
}
CC.PAGINATING_SEARCH_QUERY_LIST_ALLOWED_SORT_KEYS = $H({
	'title': 'longName',
	'mostRecent': '-lastActivityTime',
	'leastRecent': 'lastActivityTime'
});

CC.PaginatingSearchQueryListFilterBarView = Class.create(CC.FilterBarView, {
	mAllowedFilters: CC.PAGINATING_SEARCH_QUERY_LIST_ALLOWED_FILTERS,
	mAllowedSortKeys: CC.PAGINATING_SEARCH_QUERY_LIST_ALLOWED_SORT_KEYS
});

// A search-backed paginating list view base class.

CC.PaginatingSearchQueryListView = Class.create(CC.PaginatingListView, {
	mEntityTypes: ['com.apple.entity.Page', 'com.apple.entity.File'],
	mSearchFields: null,
	mSubFields: null,
	mRequestOptions: null,
	mOwnerGUID: null,
	mDefaultPaginationHowMany: 25,
	mStashedRecordedQuery: null,
	mRecordedQueryGUID: null,
	mFilterBarViewClass: 'CC.PaginatingSearchQueryListFilterBarView',
	buildQuery: function(inStartIndex, inHowMany) {
		var keyword = this.mFilterBarView.mKeyword;
		// Are we filtering by favorites only?
		var filter = this.mFilterBarView.mFilter;
		var favoritesOnly = (filter == 'favorites');
		var deletedOnly = (filter == 'deleted');
		// Grab the sort order of the filter bar.
		var sortOrder = this.mFilterBarView.mSortKey;
		// Grab the scope of the filter bar.
		var ownerGUID = this.mOwnerGUID;
		// Build a query to search with.
		var query = server_proxy().searchQuery((keyword ? [keyword] : []), this.mEntityTypes);
		var tags = this.mFilterBarView.mTags;
		if (tags && tags.length > 0) {
			query = server_proxy().addTagsToQuery(tags, query);
		}
		if (deletedOnly) {
			query.onlyDeleted = true;
		}
		// Update the query with favorite/sort settings.
		query = server_proxy().searchQueryFavoritesOnly(query, favoritesOnly);
		query = server_proxy().searchQueryUpdateSort(query, sortOrder);
		query = server_proxy().searchQueryUpdateOwnerGUID(query, ownerGUID);
		// Fake a start index (we use the query range here instead of the pagination API).
		var startIndex = (inStartIndex || query.range[0]);
		// Fake pagination by requesting n+1 items.  We'll throw away the last item later.
		// Set the query range.
		query.range = [startIndex, (inHowMany || this.mDefaultPaginationHowMany + 1)];
		// Does this view specify custom search/sub/sort fields for the search?
		if (this.mSearchFields) query.fields = this.mSearchFields;
		if (this.mSubFields) query.subFields = this.mSubFields;
		return query;
	},
	// Use a custom pagination method that actually adjusts the range of a search query instead
	// of the paginateQuery API.
	paginate: function(inPaginationGUID, inStartIndex) {
		var howMany = this.mDefaultPaginationHowMany + 1;
		var query = this.buildQuery(inStartIndex, howMany);
		// Stash the query so we can record it.
		this.mStashedRecordedQuery = CC.deepClone(query);
		// Paginate using a custom callback that fakes the pagination API.
		var _callback = function(inResponse) {
			var models = server_proxy()._parseSearchResultsAndStoreEntities(inResponse);
			var total = ((inStartIndex || 0) + models.length + 1);
			// Did we get less than a full window of items?  If we did, we don't need to continue paginating.
			if (models.length < howMany) total -= 1;
			// Otherwise, drop the last item.
			if (models.length == howMany) {
				models.pop();
			}
			return this.defaultPaginationCallback(models, (inStartIndex || 0), total);
		}.bind(this);
		server_proxy().entitiesForSearchQueryWithOptions(query, this.mRequestOptions, _callback, this.defaultPaginationErrback.bind(this));
	},
	// Override this function so we can fetch a recorded query GUID out-of-band.
	defaultPaginationCallback: function($super, inResults, inStartIndex, inTotal, inPaginationGUID) {
		$super(inResults, inStartIndex, inTotal, inPaginationGUID);
		// Once we've rendered the list, record the query if query recording is enabled.
		if (CC.meta('x-apple-config-RecordSearchStats') == "true") {
			server_proxy().recordQuery(this.mStashedRecordedQuery, function(guid) {
				this.mRecordedQueryGUID = guid;
				// Attach an event handler that will fire before the route.
				var results = $$('.cc-search-item-entity span.title:not(.cc-search-recording-enabled)');
				var boundHandler = this.handleRecordedSearchResultMouseDown.bind(this);
				results.each(function(result) {
					// Use mousedown to ensure the event handler fires before the default route handler.
					Event.observe(result, 'mousedown', boundHandler);
					result.addClassName('cc-search-recording-enabled');
				});
			}.bind(this), Prototype.emptyFunction);
		}
	},
	// Records a result.
	handleRecordedSearchResultMouseDown: function(inEvent) {
		var clickedResult = Event.findElement(inEvent, '.cc-search-item-entity');
		var clickedDataAttributes = clickedResult.getDataAttributes();
		var clickedGUID = clickedDataAttributes['guid'];
		var clickedSnippets = JSON.parse(clickedDataAttributes['snippets']);
		var allSearchResults = $$('.cc-search-item-entity');
		var index = allSearchResults.indexOf(clickedResult);
		server_proxy().recordClickInResultsWithGUID(this.mRecordedQueryGUID, index, clickedSnippets, clickedGUID);
	}
});
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.

// Container paginating list view.

CC.PaginatingContainerListView = Class.create(CC.PaginatingSearchQueryListView, {
	// Default to displaying actual preview icons.
	mDisplayGenericPreviewIcons: false,
	renderResultItem: function(inResultItem) {
		if (!inResultItem) return;
		var isFavorite = (inResultItem.isFavorite || false);
		var entityTitle = (inResultItem.longName || inResultItem.shortName);
		var entityURL = CC.entityURL(inResultItem, true);
		var iconURI = iconURIForEntity(inResultItem, this.mDisplayGenericPreviewIcons, 32, 32);
		var description = inResultItem.description;
		var contentListItem = accessibility().requestTabIndex(CC.Accessibility.TAB_INDEX_NAME_LIST_ITEMS);
		var rowItems = [
			Builder.node('a', {'href': '#', 'role': 'checkbox', 'aria-label': "_Accessibility.CheckboxFavorite".loc(), 'className': 'cc-entity-favorite-toggle' + (isFavorite ? ' selected' : ''), 'data-guid': inResultItem.guid, 'title': "_General.Favorite.Toggle.Title".loc()}),
			Builder.node('span', { 'role': 'presentation', 'className': 'modtime'}, "_General.LastActivity.Format".loc(globalLocalizationManager().localizedDateTime(inResultItem.lastActivityTime || inResultItem.createTime))),
			Builder.node('span', { 'role': 'presentation', 'className': 'cc-entity-icon', 'style': 'background-image: url(%@); background-size: 32px 32px;'.fmt(iconURI)}, [
				Builder.node('img', {'role': 'presentation', 'src': (iconURI || "")})
			]),
			Builder.node('span', {'role': 'presentation', 'className': 'title ellipsis'}, [
				Builder.node('a', {'role': 'link', 'href': entityURL}, entityTitle)
			])
		];
		if (description) {
			var infoButton = Builder.node('span', {'className': 'infoButton'});
			infoButton.addEventListener('click', function(event){
				if (infoButton.childElementCount == 0) {
					infoButton.appendChild(Builder.node('div', {'className': 'descriptionPopup'}, [
					Builder.node('h1', "_General.Container.Description".loc()),
					Builder.node('h2', description)
					]));
				} else {
					infoButton.removeChild(infoButton.children[0]);
				}
			}, false);
			rowItems.push(infoButton);
		}
		var elem = Builder.node('div', {className: 'cc-container-list-item'}, rowItems);
		// Enable the favorite toggle.
		elem.select('.cc-entity-favorite-toggle').each(function(toggle) {
			new CC.EntityFavoriteToggle(toggle);
		});
		return elem;
	}
});
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.





CC.Activity = CC.Activity || new Object();

// An array of supported entity types.

CC.Activity.SUPPORTED_ENTITY_TYPES = $A([
	"com.apple.entity.Page",
	"com.apple.entity.File"	
]);

// An array of supported activity types.

CC.Activity.SUPPORTED_ACTIVITY_TYPES = $A([
	"com.apple.activity.TagAdded",
	"com.apple.activity.TagRemoved",
	"com.apple.activity.EntityCreated",
	"com.apple.activity.EntityUpdated",
	"com.apple.activity.EntityRenamed",
	"com.apple.activity.EntityMoved",
	"com.apple.activity.EntityRemoved",
	"com.apple.activity.RelationshipAdded",
	"com.apple.activity.RelationshipRemoved",
	"com.apple.activity.CommentAdded",
	"com.apple.activity.CommentRemoved",
	"com.apple.activity.CommentApproved"
]);

// An array of activity types that coalesce, e.g. "added 3 tags".

CC.Activity.COALESCING_ACTIVITY_TYPES = $A([
	"com.apple.activity.TagAdded",
	"com.apple.activity.TagRemoved",
	"com.apple.activity.EntityUpdated",
	"com.apple.activity.RelationshipAdded",
	"com.apple.activity.RelationshipRemoved",
	"com.apple.activity.CommentAdded",
	"com.apple.activity.CommentRemoved",
	"com.apple.activity.CommentApproved"
]);

// Grouped activity view.

CC.Activity.GroupedPaginatingActivityView = Class.create(CC.PaginatingListView, {
	mDefaultActivityRequestWindow: 250,
	mWatchedOnly: true,
	mMinimumItemsPerActivityBucket: 1,
	// Coalescing window (in seconds). Multiple sequential activity by the same user in this window will be collapsed.
	// Defaults to 30 minutes.
	mActivityCoalescingWindow: 1800,
	mEnableActivityWindowCoalescing: false,
	// Scoping GUIDs which triggers the container or user-specific activity list behaviors. When you pass a containerGUID,
	// we see all activity under that GUID, and when you pass a userGUID, you see all activity by that user.  Note that
	// this is not the same as container/owner meta tags.
	mScopingUserGUID: null,
	mScopingOwnerGUID: null,
	mScopingContainerGUID: null,
	mPlaceholderString: "_Activity.No.Results.Found".loc(),
	mSomethingUnread: false,
	initialize: function($super) {
		$super.apply(null, Array.prototype.slice.call(arguments, 1));
		bindEventListeners(this, ['toggleCollapsed']);
	},
	render: function($super) {
		var elem = $super();
		var markAllReadButton = Builder.node('a', {className:'cc-mark-all-read-button cc-filter-bar-right-button', id:'cc-mark-all-read-button', style: 'display: none;'}, "_Activity.MarkAllRead".loc());
		Event.observe(markAllReadButton, 'click', this.handleMarkAllReadButtonClicked.bind(this));
		Element.insert(elem.down('.section.last'), {'top': markAllReadButton});
		return elem;
	},
	activityStreamCallback: function() {
		var callback = function(inResults, inStartIndex, inTotal, inPaginationGUID) {
			// Drop any activity items we are already displaying.
			var topLevelActivityGUIDs = this.$().select('.cc-activity-item').invoke('getAttribute', 'data-guid');
			var filteredResults = [], resultItem;
			for (var rdx = 0; rdx < inResults.length; rdx++) {
				resultItem = inResults[rdx];
				if (topLevelActivityGUIDs.indexOf(resultItem.guid) != -1) break;
				filteredResults.push(resultItem);
				continue;
			}
			this.renderResults(filteredResults, true, true);
		}
		this.paginatedActivity(undefined, 0, callback.bind(this), Prototype.emptyFunction);
	},
	paginate: function(inPaginationGUID, inStartIndex) {
		// Set up an activity page stream after our first pagination.
		if (!this.mActivityStream) {
			var url = "/__collabd/streams/activity?format=js";
			if (this.mScopingContainerGUID) url += "&containerGUID=" + this.mScopingContainerGUID;
			if (this.mScopingOwnerGUID) url += "&ownerGUID=" + this.mScopingOwnerGUID;
			if (this.mScopingUserGUID) url += "&userGUID=" + this.mScopingUserGUID;
			this.mActivityStream = new CC.ActivityStream.ChunkFrame({mURL: url, mCallback: this.activityStreamCallback.bind(this)});
		}
		this.paginatedActivity(inPaginationGUID, inStartIndex, this.defaultPaginationCallback.bind(this), this.defaultPaginationErrback.bind(this));
	},
	paginatedActivity: function(inOptPaginationGUID, inOptStartIndex, inOptCallback, inOptErrback) {
		// Do we have a filter?
		var filter = this.mFilterBarView.mFilter;
		var favoritesOnly = (filter == 'favorites');
		var unreadOnly = (filter == 'unread');
		server_proxy().paginatedActivity(this.mScopingUserGUID, this.mScopingOwnerGUID, this.mScopingContainerGUID, inOptPaginationGUID, (inOptStartIndex || 0), this.mDefaultActivityRequestWindow, favoritesOnly, unreadOnly, this.mWatchedOnly, null, inOptCallback, inOptErrback);
	},
	// Buckets an array of activity model objects based on root entity. Returns an array of 2-part
	// tuples. The first entry in the tuple is the entity model, the second a date-ordered array
	// of activity models. We assume that activity items are already sorted in date order (newest
	// to oldest).
	groupActivity: function(inActivityItems) {
		var bucketed = [];
		var orderedEntityGUIDs = new Array();
		var activityHashByGUID = new Hash();
		// First partition the activity by entityGUID.
		for (var idx = 0; idx < inActivityItems.length; idx++) {
			var item = inActivityItems[idx];
			// Skip unsupported activity types.
			if (!CC.Activity.SUPPORTED_ACTIVITY_TYPES.include(item.action)) continue;
			// Skip unsupported entity types.
			var subFields = item.subFields;
			if (subFields.entityType && !CC.Activity.SUPPORTED_ENTITY_TYPES.include(subFields.entityType)) continue;
			// Push the entity guid on to the stack.
			var entityGUID = item.entityGUID;
			orderedEntityGUIDs.push(entityGUID);
			// Push this activity item into the activity stack for the corresponding entity.
			if (!activityHashByGUID[entityGUID]) activityHashByGUID[entityGUID] = [];
			activityHashByGUID[entityGUID].push(item);
		}
		// Flatten the ordered entity guid array.
		var uniq = orderedEntityGUIDs.uniq();
		// Sort each activity partition by actionTime (newest to oldest).
		for (var idx = 0; idx < uniq.length; idx++) {
			var guid = uniq[idx];
			var activityItems = activityHashByGUID[guid];
			activityHashByGUID[guid] = activityItems.sort(function(a, b) {
				return b.actionTime - a.actionTime;
			});
		}
		// Build the result.
		for (var idx = 0; idx < uniq.length; idx++) {
			var entityGUID = uniq[idx];
			bucketed.push([entityGUID, activityHashByGUID[entityGUID]]);
		}
		return bucketed;
	},
	// Renders an individual array of grouped activity.
	renderGrouping: function(inGrouping) {
		if (!inGrouping || inGrouping.length != 2) return;
		var entityGUID = inGrouping[0], activityItems = inGrouping[1];
		var firstActivity = activityItems[0];
		var isUnread = firstActivity.isUnread, isFavorite = firstActivity.isFavorite, subFields = firstActivity.subFields || {};
		var entityType = subFields.entityType;
		if (!this.mSomethingUnread && isUnread) this.mSomethingUnread = isUnread;
		var remainingActivity = activityItems.splice(1, activityItems.length - 1);
		var iconURI = iconURIForEntityType(subFields.entityType, 32, 32);
		var elem = Builder.node('div', {className: 'cc-activity-item collapsed', 'data-guid': firstActivity.guid}, [
			Builder.node('div', {className: 'cc-activity-item-entity'}, [
				Builder.node('a', {'role': 'checkbox', 'href': '#', 'className': 'cc-entity-unread-toggle' + (isUnread ? ' selected' : ''), 'data-guid': entityGUID, 'title': "_General.Unread.Toggle.Title".loc()}),
				Builder.node('a', {'role': 'checkbox', 'href': '#', 'className': 'cc-entity-favorite-toggle' + (isFavorite ? ' selected' : ''), 'data-guid': entityGUID, 'title': "_General.Favorite.Toggle.Title".loc()}),
				Builder.node('span', {'role': 'presentation', 'className': 'modtime'}, [
					this.__renderActivityItem(firstActivity),
					Builder.node('span', {'role': 'presentation', 'className': 'moreupdates'})
				]),
				Builder.node('span', {'role': 'presentation', 'className': 'cc-entity-icon', 'style': 'background-image: url(%@); background-size: 32px 32px;'.fmt(iconURI)}, [
					Builder.node('img', {'role': 'presentation', 'src': (iconURI || "")})
				]),
				Builder.node('span', {'role': 'link', 'className': 'title ellipsis'}),
				Builder.node('span', {'role': 'link', 'className': 'owner ellipsis'})
			]),
			Builder.node('div', {className: 'cc-activity-item-actions'}, [
				Builder.node('div', {className: 'cc-activity-item-actions-wrapper'}, [
					Builder.node('span', {'className': 'norgie'}),
					Builder.node('div', {className: 'cc-activity-item-actions-inner'})
				])
			])
		]);
		// Render the more activity bucket.
		var otherActivityCount = remainingActivity.length;
		if (isUnread && (remainingActivity && remainingActivity.length > 0)) {
			var fragment = document.createDocumentFragment();
			// 10938920
			// Collapse updates of the same type, by the same user together.
			var coalesced = [], previousCoalescedActivityType, nextActivity;
			for (var idx = 0; idx < remainingActivity.length; idx++) {
				nextActivity = remainingActivity[idx];
				// If we're starting a new coalesce stack, push this activity item onto it.
				if (!coalesced || coalesced.length == 0) {
					coalesced.push(nextActivity);
					continue;
				}
				// If the next activity item is the same activity type as the previously coalesced activity item,
				// by the same user within the coalescing window, push it onto the stack.
				var firstCoalescedActivity = coalesced[0];
				var lastCoalescedActivity = coalesced[coalesced.length - 1];
				if ((CC.Activity.COALESCING_ACTIVITY_TYPES.indexOf(nextActivity.action) == -1) ||
					((lastCoalescedActivity && (lastCoalescedActivity.action == nextActivity.action)) &&
					(lastCoalescedActivity.subFields.userTinyID == nextActivity.subFields.userTinyID) &&
					(!this.mEnableActivityWindowCoalescing || ((Math.abs(firstCoalescedActivity.actionTime - lastCoalescedActivity.actionTime) / 1000) <= this.mActivityCoalescingWindow)))) {
					coalesced.push(nextActivity);
					continue;
				}
				// Otherwise flush the coalesced list.
				fragment.appendChild(this.__renderActivityItem(coalesced[0], coalesced.length));
				otherActivityCount -= (coalesced.length - 1);
				coalesced = [nextActivity];
			}
			// Catch any trailing items.
			if (coalesced && coalesced.length) {
				fragment.appendChild(this.__renderActivityItem(coalesced[0], coalesced.length));
				otherActivityCount -= (coalesced.length - 1);
			}
			elem.down('.cc-activity-item-actions-inner').appendChild(fragment);
			var fold = elem.down('span.moreupdates');
			if (fold) {
				fold.addClassName('hasmore');
				var moreLink = Builder.node('a', {'className': 'count'}, (otherActivityCount > 1 ? "_Activity.More.Count.Plural".loc(otherActivityCount) : "_Activity.More.Count.Singular".loc()));
				var hideLink = Builder.node('a', {'className': 'hide'}, "_Activity.More.Hide".loc());
				Event.observe(moreLink, 'click', this.toggleCollapsed);
				Event.observe(hideLink, 'click', this.toggleCollapsed);
				fold.appendChild(moreLink);
				fold.appendChild(hideLink);
			}
		}
		// Enable unread and favorite toggles.
		elem.select('.cc-entity-unread-toggle').each(function(toggle) {
			new CC.EntityUnreadToggle(toggle);
		});
		elem.select('.cc-entity-favorite-toggle').each(function(toggle) {
			new CC.EntityFavoriteToggle(toggle);
		});
		// Notify after animation.
		var actionElements = elem.select('.cc-activity-item-actions');
		var boundToggledCollapsed = this.didToggleCollapsed.bind(this);
		for (var idx = 0; idx < actionElements.length; idx++) {
			Event.observe(actionElements[idx], 'webkitTransitionEnd', boundToggledCollapsed);
		}
		// Localize title in owner and last modified author.
		var entityTitle = (subFields.entityLongName || subFields.entityShortName).escapeHTML();
		var entityID = subFields.entityTinyID;
		if (subFields.entityType == "com.apple.entity.User") entityID = subFields.entityShortName;
		var entityLink = "<a href='%@'>%@</a>".fmt(CC.entityURLForTypeAndTinyID(subFields.entityType, entityID, entityTitle), entityTitle);
		elem.down('.title').innerHTML = entityLink;
		var ownerTitle = (subFields.ownerLongName || subFields.ownerShortName).escapeHTML();
		var ownerID = subFields.ownerTinyID;
		if (subFields.ownerType == "com.apple.entity.User") ownerID = subFields.ownerShortName;
		var ownerLink = "<a href='%@'>%@</a>".fmt(CC.entityURLForTypeAndTinyID(subFields.ownerType, ownerID, ownerTitle), ownerTitle);
		elem.down('.owner').innerHTML = ownerLink;
		return elem;
	},
	// Renders an individual activity item. Localizes the activity type and activity data into
	// a friendly activity string with a link to the triggering user. Supports rendering an activity
	// item as a coalesced activity item (where a single activity item represents a collapsed set of
	// sequential similar activity).
	__renderActivityItem: function(inActivityItem, inCoalescedCount) {
		if (!inActivityItem) return undefined;
		if (!inCoalescedCount) inCoalescedCount = 0;
		var elem = Builder.node('span', {'role': 'presentation', className: 'cc-activity-item-action ellipsis', 'data-guid': inActivityItem.guid, 'data-action': inActivityItem.action});
		// Build a localized activity string (including the user link and timestamp).
		var userDisplayName = (inActivityItem.subFields.userLongName || inActivityItem.subFields.userShortName);
		var userURL = CC.entityURLForTypeAndTinyID(inActivityItem.subFields.userType, inActivityItem.subFields.userShortName, userDisplayName);
		var userLink = "<a tabindex='-1' class='user ellipsis' href='%@'>%@</a>".fmt(CC.entityURLForTypeAndTinyID(inActivityItem.subFields.userType, inActivityItem.subFields.userShortName.escapeHTML(), userDisplayName.escapeHTML()), userDisplayName.escapeHTML());
		var localizedTimestamp = globalLocalizationManager().localizedDateTime(inActivityItem.actionTime);
		var localizedString, activityData = inActivityItem.data || {};
		switch (inActivityItem.action) {
			case "com.apple.activity.TagAdded":
				if (inCoalescedCount > 1) {
					localizedString = "_Activity.Action.Coalesced.TagAdded".loc(userLink, inCoalescedCount, localizedTimestamp);
				} else {
					localizedString = "_Activity.Action.TagAdded".loc(userLink, activityData.tag.escapeHTML(), localizedTimestamp);
				}
				break;
			case "com.apple.activity.TagRemoved":
				if (inCoalescedCount > 1) {
					localizedString = "_Activity.Action.Coalesced.TagRemoved".loc(userLink, inCoalescedCount, localizedTimestamp);
				} else {
					localizedString = "_Activity.Action.TagRemoved".loc(userLink, activityData.tag.escapeHTML(), localizedTimestamp);
				}
				break;
			case "com.apple.activity.EntityUpdated":
				if (inCoalescedCount > 1) {
					localizedString = "_Activity.Action.Coalesced.EntityUpdated".loc(userLink, inCoalescedCount, localizedTimestamp);
				} else {
					localizedString = "_Activity.Action.EntityUpdated".loc(userLink, localizedTimestamp);
				}
				break;
			case "com.apple.activity.EntityRenamed":
				localizedString =  "_Activity.Action.EntityRenamed".loc(userLink, activityData.oldLongName.escapeHTML(), activityData.newLongName.escapeHTML(), localizedTimestamp);
				break;
			case "com.apple.activity.EntityMoved":
				localizedString = "_Activity.Action.EntityMoved".loc(userLink, (inActivityItem.subFields.ownerLongName || inActivityItem.subFields.ownerShortName).escapeHTML(), localizedTimestamp);
				break;
			case "com.apple.activity.CommentAdded":
			case "com.apple.activity.CommentRemoved":
			case "com.apple.activity.CommentApproved":
				var locString = "_Activity.Action." + ((inCoalescedCount > 1) ? "Coalesced." : "") + inActivityItem.action.split('.').last();
				if (inCoalescedCount > 1) {
					localizedString = locString.loc(userLink, inCoalescedCount, localizedTimestamp);
				} else {
					localizedString = locString.loc(userLink, activityData['body'].escapeHTML(), localizedTimestamp);
				}
				break;
			case "com.apple.activity.EntityCreated":
			case "com.apple.activity.EntityRemoved":
			case "com.apple.activity.RelationshipAdded":
			case "com.apple.activity.RelationshipRemoved":
			case "com.apple.activity.BlogEnabled":
			case "com.apple.activity.BlogDisabled":
			case "com.apple.activity.CalendarEnabled":
			case "com.apple.activity.CalendarDisabled":
				var locString = "_Activity.Action." + inActivityItem.action.split('.').last();
				localizedString = locString.loc(userLink, localizedTimestamp);
		}
		elem.innerHTML = localizedString;
		return elem;
	},
	prepareResultsForRendering: function(inResults) {
		return this.groupActivity(inResults);
	},
	renderResults: function($super, inResults, inOptAppendAtTop) {
		$super(inResults, inOptAppendAtTop);
		// Hide or show the mark all as read button.
		if (this.mSomethingUnread) {
			$('cc-mark-all-read-button').show();
		} else {
			$('cc-mark-all-read-button').hide();
		}
		// Enable any routes we need to.
		globalNotificationCenter().publish(CC.Routes.NOTIFICATION_ROUTES_SHOULD_UPDATE);
		globalNotificationCenter().publish(CC.DID_UPDATE_PAGINATING_LIST_VIEW, this);
	},
	renderResultItem: function(inResultItem) {
		return this.renderGrouping(inResultItem)
	},
	defaultPaginationCallback: function($super, inResults, inStartIndex, inTotal, inPaginationGUID) {
		$super(inResults, inStartIndex, inTotal, inPaginationGUID);
		// Is the list empty? We check here because our bucketing/grouping algorithms might
		// have filtered everything out even though we got results from the server.
		if (this.$().select('.cc-activity-item').length == 0) this.setIsEmpty(true);
	},
	toggleCollapsed: function(inEvent) {
		var activityItem = Event.findElement(inEvent, '.cc-activity-item');
		if (activityItem) {
			if (activityItem.hasClassName('collapsed')) {
				var actionsElement = activityItem.down('.cc-activity-item-actions');
				var actionsWrapper = actionsElement.down('.cc-activity-item-actions-wrapper');
				actionsElement.style.height = actionsWrapper.clientHeight + 'px';
				activityItem.removeClassName('collapsed');
			}
			else {
				var actionsElement = activityItem.down('.cc-activity-item-actions');
				actionsElement.style.height = '0px';
				activityItem.addClassName('collapsed');
			}
		}
		this.didToggleCollapsed();
	},
	didToggleCollapsed: function() {
		globalNotificationCenter().publish(CC.DID_UPDATE_PAGINATING_LIST_VIEW, this);
	},
	handleMarkAllReadButtonClicked: function() {
		if (!$('mark_all_read_dialog')) {
			dialogManager().drawDialog('mark_all_read_dialog', [
				"_MarkAllAsRead.Description".loc()
			], "_Dialogs.OK".loc(), false, "_MarkAllAsRead.Title".loc(), "_Dialogs.Cancel".loc());
		}
		dialogManager().show('mark_all_read_dialog', null, this.onMarkAllConfirm.bind(this));
	},
	onMarkAllConfirm: function() {
		var callback = function(result) {
			$('cc-mark-all-read-button').hide();
			$$('.cc-entity-unread-toggle').invoke('removeClassName', 'selected');
		};
		var errback = function() {
		
		};
		server_proxy().markAllAsRead(callback, errback);
	}
});
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.





CC.Search = CC.Search || new Object();

// Create a custom filter bar so we can sort by rank too.

CC.Search.CustomFilterBarViewFilters = $H({
	'rank': '-rank',
	'title': '+longName',
	'mostRecent': '-lastActivityTime',
	'leastRecent': '+lastActivityTime'
});

CC.Search.ReverseCustomFilterBarViewFilters = $H({
	'-rank': 'rank',
	'+longName': 'title',
	'-lastActivityTime': 'mostRecent',
	'+lastActivityTime': 'leastRecent'
});

CC.Search.PaginatingSearchResultsFilterBarView = Class.create(CC.FilterBarView, {
	mSortKey: '-rank',
	_mSortKey: 'rank',
	mAllowedFilters: CC.PAGINATING_SEARCH_QUERY_LIST_ALLOWED_FILTERS,
	mAllowedSortKeys: CC.Search.CustomFilterBarViewFilters,
	mAllowSavingSearch: true
});

// Paginating search results view.

CC.Search.PaginatingSearchResultsView = Class.create(CC.PaginatingSearchQueryListView, {
	mFilterBarViewClass: 'CC.Search.PaginatingSearchResultsFilterBarView',
	// Override the pagination callback so we can append a save search button. We do it here because
	// we're accessing the sessions global and need to be sure the session information is there (which
	// it may not be until at least one collabdproxy request has been made).
	defaultPaginationCallback: function($super, inResults, inStartIndex, inTotal, inPaginationGUID) {
		$super(inResults, inStartIndex, inTotal, inPaginationGUID);
		sessions().currentUserAsynchronously(function(user) {
			if (user && user.isAuthenticated) {
				if (!this.$().down('.cc-save-search-button')) {
					var savedSearchButton = Builder.node('a', {className:'cc-save-search-button cc-filter-bar-right-button'}, "_Search.SavedSearch.Save".loc());
					Event.observe(savedSearchButton, 'click', this.handleSaveSearchButtonClicked.bind(this));
					Element.insert(this.$().down('.section.last'), {'top': savedSearchButton});
				}
			}
		}.bind(this));
	},
	renderResultItem: function(inResultItem) {
		var entity = inResultItem;
		if (!entity) return;
		var isFavorite = entity.isFavorite ? entity.isFavorite : false;
		var iconURI = iconURIForEntity(inResultItem, true, 32, 32);
		var elem = Builder.node('div', {'role': 'presentation', className: 'cc-search-item'}, [
			Builder.node('div', {'role': 'presentation', className: 'cc-search-item-entity', 'data-guid': entity.guid, 'data-snippets': JSON.stringify(entity.snippets || {})}, [
				Builder.node('a', {'role': 'checkbox', 'href': '#', 'className': 'cc-entity-favorite-toggle' + (isFavorite ? ' selected' : ''), 'data-guid': entity.guid, 'title': "_General.Favorite.Toggle.Title".loc()}),
				Builder.node('span', {'role': 'presentation', 'className': 'modtime ellipsis'}),
				Builder.node('span', {'role': 'presentation', 'className': 'cc-entity-icon', 'style': 'background-image: url(%@); background-size: 32px 32px;'.fmt(iconURI)}, [
					Builder.node('img', {'role': 'presentation', 'src': (iconURI || "")})
				]),
				Builder.node('span', {'role': 'presentation', 'className': 'title ellipsis'}),
				Builder.node('span', {'role': 'presentation', 'className': 'owner ellipsis'}),
				Builder.node('div', {className:'cc-search-item-snippet-content'}),
				Builder.node('div', {className:'cc-search-item-snippet-tags'})
			])
		]);
		elem.select('.cc-entity-favorite-toggle').each(function(toggle) {
			new CC.EntityFavoriteToggle(toggle);
		});
		// Handle a title snippet up-front so we can use it to localize.
		var entityTitle = (entity.longName || entity.shortName).escapeHTML();
		if (entity.snippets) {
			var titleSnippet = (entity.snippets['longName'] || entity.snippets['shortName']);
			if (titleSnippet) {
				entityTitle = this.__wrapSnippetInHighlightTags(titleSnippet.escapeHTML());
			}
		}
		// Render the titles and last modified timestamp.
		var entityLink = "<a href='%@'>%@</a>".fmt(CC.entityURL(entity, true), entityTitle);
		elem.down('span.title').innerHTML = entityLink;
		var ownerLink = "<a href='%@'>%@</a>".fmt(CC.entityURL(entity.container, true), (entity.container.longName || entity.container.shortName).escapeHTML());
		elem.down('span.owner').innerHTML = "_Search.Owner.Title.Format".loc(ownerLink);
		var userLink = "<a href='%@'>%@</a>".fmt(CC.entityURL(entity.updatedByUser, true), (entity.updatedByUser.longName || entity.updatedByUser.shortName).escapeHTML());
		elem.down('span.modtime').innerHTML = "_Search.LastModified.Subtitle.Format".loc(globalLocalizationManager().localizedDateTime(entity.lastActivityTime || entity.createTime), userLink);
		// Handle content and tag snippets.
		if (entity.snippets) {
			var contentSnippet = (entity.snippets['extendedAttributes.pageTextValue'] || entity.snippets['content']);
			// HTML snippets are annotated html fragments with {{{ snippet decorations.
			var htmlSnippet = entity.snippets['extendedAttributes.renderedPage'];
			if (!contentSnippet && htmlSnippet) {
				var tempNode = document.createElement("div");
				// If htmlSnippet is an array, we need to join them to get one string.
				if (Object.isArray(htmlSnippet)) htmlSnippet = htmlSnippet.join("_Search.MultipleSnippet.Divider".loc());
				tempNode.innerHTML = htmlSnippet;
				contentSnippet = tempNode.textContent || tempNode.innerText;
			}
			if (contentSnippet) {
				elem.down('.cc-search-item-snippet-content').innerHTML = this.__wrapSnippetInHighlightTags(contentSnippet);
			}
			var tagsSnippet = entity.snippets['tags'];
			if (tagsSnippet) {
				// When one tag matched, the snippet is a string, otherwise it's an array.  Always work with arrays.
				if (!Object.isArray(tagsSnippet)) tagsSnippet = [tagsSnippet];
				// Always show all tags.  Build a list of all tags interleaved with matching tag snippets.
				var allTags = $A(entity.tags || []);
				// First sort the original tags alphabetically (case insensitive).
				var sortedTags = allTags.sortBy(function(n) { return n.toLowerCase(); });
				for (var i = 0; i < sortedTags.length; i++) {
					sortedTags[i] = sortedTags[i].escapeHTML();
				}
				
				var tag, originalTag, sortedTagIndex;
				for (var tdx = 0; tdx < tagsSnippet.length; tdx++) {
					// Get the original unwrapped tag.
					tag = tagsSnippet[tdx];
					originalTag = tag.replace(/{{{|}}}/g, '');
					// Replace the original tag with an annotated version.
					sortedTagIndex = sortedTags.indexOf(originalTag);
					if (sortedTagIndex != -1) {
						sortedTags[sortedTagIndex] = this.__wrapSnippetInHighlightTags(tag);
					}
				}
				// Build out the tags list.
				elem.down('.cc-search-item-snippet-tags').innerHTML = "<span>%@</span>&nbsp;&nbsp;%@".fmt("_Search.Tags.Subtitle".loc(), sortedTags.join("&nbsp;&nbsp;"));
			}
		}
		return elem;
	},
	__wrapSnippetInHighlightTags: function(inSnippet) {
		var snippets = (Object.isArray(inSnippet) ? inSnippet : [inSnippet]), s, result = [];
		for (var sdx = 0; sdx < snippets.length; sdx++) {
			s = snippets[sdx];
			result.push(s.replace(/{{{/g, '<span class="highlight">').replace(/}}}/g, '</span>'));
		}
		return result.join("_Search.MultipleSnippet.Divider".loc());
	},
	handleSaveSearchButtonClicked:function(inEvent) {
		if (!$('save_search_dialog')) {
			dialogManager().drawDialog('save_search_dialog', [
				{ label: "_Search.SavedSearch.Save.Dialog.Label".loc(), contents: '<input type="text" id="save_search_dialog_input" />' },
			], "_Search.SavedSearch.Save.Dialog.OK".loc(), false, "_Search.SavedSearch.Save.Dialog.Title".loc(), "_Dialogs.Cancel".loc());
		}
		var input = $('save_search_dialog_input');
		var callback = function() {
			dialogManager().hide();
			dialogManager().showProgressMessage("_Search.SavedSearch.Save.Dialog.Progress".loc());
			var name = input.value;
			var query = this.buildQuery();
			return server_proxy().saveQueryAsSavedSearchWithName(query, name, this.handleDidSaveSearch.bind(this), this.handleDidSaveSearch.bind(this));
		}
		input.value = (this.mFilterBarView.mKeyword || "_Search.SavedSearch.Untitled".loc());
		dialogManager().show('save_search_dialog', null, callback.bind(this), null, input);
	},
	handleDidSaveSearch: function(inResponse) {
		dialogManager().hide();
		if (inResponse && inResponse.succeeded) {
			this.mParentElement.down('.cc-save-search-button').hide();
			// Publish a notification to say the search saved.
			globalNotificationCenter().publish(CC.SEARCH_VIEW_DID_SAVE_SEARCH, this);
		}
	}
});

CC.Search.queryToURL = function(inQuery) {
	// utility method for munging from a query to url parameters...
	var onlyDeleted = inQuery.onlyDeleted;
	// go through the actual query and snarf out what we can
	var keywords = [];
	var tags = [];
	var favoritesOnly = false;
	var sortKeys = [];
	// assume it's an and node for now
	$A(inQuery.query.and).each(function(aNode) { 
		if (aNode.field) {
			if (aNode.field == "isFavorite") {
				favoritesOnly = aNode.match;
			}
			if (aNode.field == "tags") {
				tags.push(aNode.value);
			}
		} else {
			if (aNode.value) {
				// assume it's a keyword search
				keywords.push(aNode.value);
			}
			if (aNode.match) {
				keywords.push(aNode.match);
			}
		}
	});
	$A(inQuery.sortFields).each(function(aSortKey) {
		sortKeys.push(aSortKey);
	});
	
	// now construct the query string based on the values we've snarfed
	var queryString = "/find?";
	if (keywords.length > 0) {
		queryString = queryString + "keyword=" + keywords.join("&keyword=");
	}
	if (tags.length > 0) {
		if (keywords.length > 0) {
			queryString = queryString + "&";
		}
		queryString = queryString + "tags=" + tags.join("&tags=");
	}
	if (favoritesOnly) {
		if (tags.length || keywords.length) {
			queryString = queryString + "&";
		}
		queryString = queryString + "favorites_only=true";
	}
	if (sortKeys.length > 0) {
		if (favoritesOnly || tags.length || keywords.length) {
			queryString = queryString + "&";
		}
		queryString = queryString + "sortKey=" + sortKeys.join("&sortKey=");
	}
	return queryString;
};

// Helper function that updates a CC.FilterBarView with a set of URL query params.
// Note that it bypasses the setters for the view deliberately so it can be used to
// set up initial state.

CC.Search.setupFilterForQuery = function(filter, params) {
	if (params['favorites_only'] == 'true') {
		filter.setFilter('favorites');
	} else if (params['deleted_only'] == 'true') {
		filter.setFilter('deleted')
	} else {
		filter.setFilter('everything');
	}
	if (params['sortKey']) {
		var aSortKey = CC.Search.ReverseCustomFilterBarViewFilters.get(params['sortKey']);
		if (aSortKey) {
			filter.setSortKey(aSortKey);
		}
	} else {
		filter.setSortKey('mostRecent');
	}
	if (!params['sortKey']) {
		filter.setSortKey('rank');
	}
	filter.setTags(params['tags']);
	filter.setKeyword(params['keyword']);
};

CC.Search.translateOldQueryParamsToNew = function() {
	var queryString = "/find?";
	var queryParams = [];
	// old urls are in the form ?q[keyword]=test&q[tags][]=find&q[tags][]=hot&q[owners][]=
	// or q[deleted_only]=false&q[favorites_only]=true&q[how_many]=25&q[keyword]=&q[mine_only]=false&q[owners][]=&q[sort_direction]=desc&q[sort_property]=rank&q[start_index]=0&q[tags][]=tag&q[unread_only]=false&q[watched_only]=false
	// we only care about keyword, tags, favorites_only, sort_property, sort_direction, tags, owners
	var params = CC.params();
	if (params['q[keyword]']) {
		var keywords = Object.isArray(params['q[keyword]']) ? params['q[keyword]']: [params['q[keyword]']];
		queryParams.push("keyword="+keywords.join('&keyword='));
	}
	if (params['q[tags][]']) {
		var tags = Object.isArray(params['q[tags][]']) ? params['q[tags][]'] : [params['q[tags][]']];
		queryParams.push("tags="+params['q[tags][]'].join('&tags='));
	}
	if (params['q[owners][]']) {
		var owners = Object.isArray(params['q[owners][]']) ? params['q[owners][]'] : [params['q[owners][]']];
		queryParams.push("scopeGUID="+owners.join('&scopeGUID='));
	}
	if (params['q[deleted_only]']) {
		var deletedOnly = Object.isArray(params['q[deleted_only]']) ? params['q[deleted_only]'][0] : params['q[deleted_only]'];
		queryParams.push("deletedOnly="+deletedOnly);
	}
	if (params['q[favorites_only]']) {
		var favoritesOnly = Object.isArray(params['q[favorites_only]']) ? params['q[favorites_only]'][0] : params['q[favorites_only]'];
		queryParams.push("favoritesOnly="+favoritesOnly);
	}
	queryString = queryString + queryParams.join('&');
	
	return env().root_path + queryString;
};
// Copyright (c) 2012-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.





// ACL Editor view.

CC.DocumentSharingView = Class.create(CC.Mvc.View, {
	mAccessEditor: null,
	mACLs: [],
	mSharingListElement: null,
	mWidgetElement: null,
	mStashedCurrentUser: null,
	initialize: function($super, acls, entityGUID) {
		$super();
		this.mACLs = acls;
		this.mEntityGUID = entityGUID;
	},
	_buildSharingElement: function(anACL) {
		var accessString = "_Access.Role." + anACL['action'];
		var aclElement = Builder.node('li', {className:'cc-sharing-item'}, [
			Builder.node('span', {className:'icon'}),
			Builder.node('span', {className:'username'}, anACL.userLongName || anACL.userLogin),
			Builder.node('span', {className:'access'}, accessString.loc())
		]);
		
		return aclElement;
	},
	_buildSharingList: function() {
		// build list of people shared with
		var sharingItemElements = this._sharingItemsToShow().collect(function(anACL) {
			return this._buildSharingElement(anACL);
		}.bind(this));
		
		return sharingItemElements;
	},
	_sharingItemsToShow: function() {
		var sharingItems = [];
		for (i = 0; i < this.mACLs.length; i++) {
			var anACL = this.mACLs[i];
			if (anACL.action != 'none' && anACL.allow != 'false') {
				if (this.mStashedCurrentUser && this.mStashedCurrentUser.externalID != anACL.userExternalID) {
					sharingItems.push(anACL);
				}
			}
		}
		return sharingItems;
	},
	showOrHideEmptyMessage: function() {
		var placeholder = this.mWidgetElement.down('.cc-sharing-empty-message');
		if (placeholder)
			(this._sharingItemsToShow().length > 0) ? placeholder.hide() : placeholder.show();
	},
	render: function() {
		var tagItemSharing = accessibility().requestTabIndex(CC.Accessibility.TAB_INDEX_NAME_SIDEBAR_SHARING);
		// build the label and edit button
		var editButton = Builder.node('a', {'tabindex': tagItemSharing, 'role': 'button', className:'cc-sidebar-rounded-button'}, "_Sharing.Sidebar.Edit".loc());
		Event.observe(editButton, 'click', this.edit.bind(this));
		var headerElement = Builder.node('div', {className:'cc-sharing-header'}, [
			Builder.node('span', {'tabindex': '-1', className:'label'}, "_Sharing.Sidebar.SharingWith".loc()),
			editButton
		]);
		
		// build the access editor
		this.mAccessEditor = new CC.AccessEditorView(this.mACLs, false, this.mEntityGUID);
		this.mAccessEditor._render();
		
		// build the whole thing
		this.mWidgetElement = Builder.node('div', {className:'cc-sharing-view'}, [
			headerElement,
			Builder.node('h2', {className:'cc-sharing-empty-message placeholder', style:'display:none'}, "_Sharing.Sidebar.EmptyPlaceholder".loc()),
			Builder.node('div', {className:'cc-sharing-dialog', style:'display:none'})
		]);
		
		// We require the current user actually rendering the sharing list, so fetch it before
		// drawing. In most cases this call will come back immediately. We cache it here to avoid
		// wrapping all our drawing code in asynchronous user calls.
		sessions().currentUserAsynchronously(function(currentUser) {
			this.mStashedCurrentUser = currentUser;
			this.redrawSharingList();
		}.bind(this));
		
		return this.mWidgetElement;
	},
	redrawSharingList: function() {
		if (this.mSharingListElement) this.mSharingListElement.remove();
		this.mSharingListElement = Builder.node('ul', {className:'cc-sharing-items'}, this._buildSharingList());
		this.mWidgetElement.appendChild(this.mSharingListElement);
		this.showOrHideEmptyMessage();
	},
	onSharingDialogOkButtonClick: function() {
		// mACLs is only used for refreshing the UI. It is not sent out to the server when invoking save()
		this.mACLs = this.mAccessEditor.validItems();				
		this.mAccessEditor.save(this.redrawSharingList.bind(this));
	},
	edit: function(inEvent) {
		if (!$('sharing_dialog')) {
			dialogManager().drawDialog('sharing_dialog', [
				""
			], "_Dialogs.OK".loc(), false, "_SharingDialog.Title".loc(), "_Dialogs.Cancel".loc());
			var editor_element = this.mAccessEditor.$();
			editor_element.show();
			$("sharing_dialog").down(".dialog_description").insert(editor_element);
		}
		dialogManager().show('sharing_dialog', null, this.onSharingDialogOkButtonClick.bind(this));
	}
});
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.





// Create a namespace.

CC.AccessEditor = CC.AccessEditor || new Object();

CC.AccessEditor.DefaultAllUsersACL = {
	userExternalID:'unauthenticated',
	userLogin:'unauthenticated',
	userLongName:"_Access.User.unauthenticated".loc(),
	action:'none',
	allow: true
};

CC.AccessEditor.DefaultLoggedInUsersACL = {
	userExternalID:'authenticated',
	userLogin:'authenticated',
	userLongName:"_Access.User.authenticated".loc(),
	action:'none',
	allow: true
};

CC.AccessEditor.ACCESS_EDITOR_VIEW_LIST_DID_CHANGE = 'NOTIFICATION_ACCESS_EDITOR_VIEW_LIST_DID_CHANGE';

// ACL Editor view.

CC.AccessEditorView = Class.create(CC.Mvc.View, {
	// The original set of acl items we were passed when this view was initialized.
	mPassedACLItems: [],
	// A computed set of acl items being used to render (after we exclude duplicates and include the logged in user etc).
	mACLItems: [],
	// Prevents from spamming the permission list when edit permission
	// Unlike mACLItems, mNewPermissionList only contains the new permission used for sending 'share document' notifications 
	mNewPermissionList: [],	
	mAllUsers: null,
	mLoggedInUsers: null,
	mEntityGUID: null,
	mShowMe: false,
	dirty: false,
	mStashedCurrentUser: null,
	initialize: function($super, aclItems, mShowMe, inOptEntityGuid, inOptDefaultAllUsersACL, inOptDefaultLoggedInUsersACL) {
		$super();
		this.mPassedACLItems = aclItems;
		this.mAllUsers = (inOptDefaultAllUsersACL || CC.deepClone(CC.AccessEditor.DefaultAllUsersACL));
		this.mLoggedInUsers = (inOptDefaultLoggedInUsersACL || CC.deepClone(CC.AccessEditor.DefaultLoggedInUsersACL));
		this.mEntityGUID = inOptEntityGuid;
		this.mShowMe = mShowMe;
		this.dirty = false;
	},
	_itemIsPublic: function(anItem) {
		return (anItem['userLogin'] == 'unauthenticated' || anItem['userLogin'] == 'authenticated');
	}, 
	_itemIsMe: function(anItem) {
		var currentUser = this.mStashedCurrentUser;
		return (currentUser && (anItem['userExternalID'] == currentUser.externalID));
	},
	_rolesForItem: function(inItem) {
		if (this._itemIsPublic(inItem)) {
			return ['write', 'read', "none"];
		}
		return ['own', 'write', 'read'];
	},
	_itemAlreadyPresent: function(inItem) {
		return this._itemForLogin(inItem.userLogin) != null;
	},
	_itemForLogin:function(inLogin) {
		for (var i = 0; i < this.mACLItems.length; i++) {
			if (this.mACLItems[i].userLogin == inLogin) {
				return this.mACLItems[i];
			}
		}
		return null;
	},
	_update: function(inDirty) {
		// this will go through and clean up anything that needs to get cleaned up
		if (inDirty) this.dirty = true;
		var unauthedElement = this.mAllUsers.element.down('.permissions select')
		var unauthedRole = unauthedElement.value;
		var authedElement = this.mLoggedInUsers.element.down('.permissions select')
		var authedRole = authedElement.value;
		// authed can't be less than unauthed
		if (unauthedRole == "read") {
			if (authedRole == "none") {
				// set auth to read
				authedElement.setValue('read');
			}
		}
		if (unauthedRole == "write") {
			if (authedRole == "none" || authedRole == "read") {
				// set authed role to write
				authedElement.setValue("write");
			}
		}
		// publish a notification since the UI might need to be refreshed
		if (this.dirty) {
			globalNotificationCenter().publish(CC.AccessEditor.ACCESS_EDITOR_VIEW_LIST_DID_CHANGE, this);
		}
	},
	_buildAccessItemView: function(inItem) {
		// fix longname if it is empty
		if (!inItem.userLongName) {
			inItem.userLongName = inItem.userLogin;
		}
		var meAcl = this._itemIsMe(inItem);
		var removeClass = "remove";
		if (this._itemIsPublic(inItem) || meAcl) {
			removeClass = "remove disabled";
		}
		var removeButton = Builder.node('a', {className:removeClass, href:'#', userlogin:inItem.userLogin, title:"_Access.Remove".loc()}, "_Access.Remove".loc());
		Event.observe(removeButton, 'click', this.remove.bind(this));
		
		var tabIndexName = accessibility().requestTabIndex(CC.Accessibility.TAB_INDEX_NAME_POPUP_SETTINGS_PERMISSIONS_ACCESS);		
		var token = Builder.node('span', {className: 'token'}, [
			removeButton,
			Builder.node('span', {'tabindex': tabIndexName, 'aria-label': inItem['userLongName'], className:'label', title:inItem['userLongName'] + " (" + inItem['userLogin'] + ")"}, inItem['userLongName']),
		]);
		var accessSelect = Builder.node('select', {'tabindex': tabIndexName, 'role': 'listbox', 'aria-label': "_Accessibility.Editor.AccessRoles".loc(), userlogin:inItem.userLogin}, this._rolesForItem(inItem).collect(function(aRole) {
			var accessString = "_Access.Role." + aRole;
			return Builder.node('option', {'role': 'option', value: aRole}, accessString.loc());
		}));
		// Setting selected programatically on the node rather than declaratively in Builder.node to workaround a weird bug in FF. 12236806.
		accessSelect.setValue(inItem['action']);
		if (meAcl) accessSelect.setAttribute('disabled', true);
		Event.observe(accessSelect, 'change', this.handleAccessChanged.bind(this));
		var accessElement = Builder.node('span', {className:"permissions"}, accessSelect);
		var elem = Builder.node('li', {className: 'item'}, [ token, accessElement]);
		inItem.element = elem;
		if (meAcl && !this.mShowMe) elem.style.display = 'none';
		return elem;
	},
	render: function() {						
		// Rendering the access editor view requires the current user, so draw what we can first
		// and fill in the rest in a callback. Start by building the auto-completing user search
		// field.		
		var tabIndexName = accessibility().requestTabIndex(CC.Accessibility.TAB_INDEX_NAME_POPUP_SETTINGS_PERMISSIONS_NAME);				
		this.textfield = Builder.node('input', {'tabindex': tabIndexName, 'role': 'textbox', 'aria-label': "_Access.Autocomplete.Placeholder".loc(), 
												'type':"text", name:"", value:"", placeholder:"_Access.Autocomplete.Placeholder".loc()});
		var randomID = "cc-menu-autocomplete-%@".fmt(buildRandomString(5));
		this.resultList = Builder.node('ul', {'id': randomID, 'className': 'cc-menu-autocomplete cc-access-editor-view-autocomplete-menu'});
		document.body.appendChild(this.resultList);
		this.resultList.hide();
		this.userSearchField = new UserSearchField(this.textfield, {
			mResultTable: this.resultList,
			mClickedItemCallback: this.handleClickedRecord.bind(this)
		});
		
		// Build out a shell.
		var elem = Builder.node('div', {className: 'cc-access-editor-view loading'}, [
			Builder.node('div', {className: 'field'}, this.textfield),
			Builder.node('div', {className:'items'})
		]);
		
		// Grab the current user, and update the ACLs asynchrounously.  Do this after 500ms so the view
		// has time to render (bit of a hack).
		setTimeout(function() {
			sessions().currentUserAsynchronously(function(currentUser) {
				this.mStashedCurrentUser = currentUser;
				this.$().removeClassName('loading');
				this.redrawACLItems();
			}.bind(this));
		}.bind(this), 500);
		
		return elem;
	},
	redrawACLItems: function() {
		// First recompute the ACLs we will draw.
		this.mACLItems = new Array();
		this.mNewPermissionList = new Array();
		// Add an owner ACL entry for me.  We assume that if you can see the ACL settings, you own the item.
		var currentUser = this.mStashedCurrentUser;
		if (currentUser) {
			var meACL = {
				userExternalID: currentUser.externalID,
				userLogin: currentUser.login,
				userLongName: (currentUser.longName || currentUser.shortName),
				action: 'own',
				allow: true
			};
			this.mACLItems.push(meACL);
		}
		// Add acl entries for every acl in the array we were passed
		var aclItems = $A(this.mPassedACLItems).reverse(); // reverse the aclItems so the first version of the same acl will overwrite the second
		for (var i = 0; i < aclItems.length; i++) {
			var anItem = aclItems[i];
			if (anItem.userExternalID == 'unauthenticated') {
				this.mAllUsers['action'] = anItem['action'];
				this.mAllUsers.allow = anItem.allow;
			} else if (anItem.userExternalID == 'authenticated') {
				this.mLoggedInUsers['action'] = anItem['action'];
				this.mLoggedInUsers.allow = anItem.allow;
			} else if (anItem.userExternalID == '*'){
				// special user that is a cons of allUsers and allLoggedInUsers
				this.mLoggedInUsers['action'] = anItem['action'];
				this.mLoggedInUsers.allow = anItem.allow;
				this.mAllUsers['action'] = anItem['action'];
				this.mAllUsers.allow = anItem.allow;
			} else if (currentUser && (anItem.userExternalID == currentUser.externalID)) {
				if (!this.mShowMe) continue; // don't add me twice
			} else {
				if (!this._itemAlreadyPresent(anItem)) { // my algorithms professor would slap me for this
					this.mACLItems.push(anItem);
				}
			}
		}
		// Add the public acl items
		this.mACLItems.push(this.mLoggedInUsers);
		this.mACLItems.push(this.mAllUsers);
		// Build out the UI.
		var recordListElements = []
		for (var i = 0; i < this.mACLItems.length; i++) {
			var anItem = this.mACLItems[i];
			if (this._itemIsPublic(anItem)) continue;
			recordListElements.push(this._buildAccessItemView(anItem));
		}
		var publicRecordsElements = [
			this._buildAccessItemView(this.mLoggedInUsers),
			this._buildAccessItemView(this.mAllUsers)
		];
		this.recordList = Builder.node('ul', {className: 'cc-acl-list'}, recordListElements);
		this.publicRecordList = Builder.node('ul', {className: 'cc-acl-list'}, publicRecordsElements);
		var fragment = document.createDocumentFragment();
		fragment.appendChild(this.recordList);
		fragment.appendChild(this.publicRecordList);
		var itemsElement = this.$().down('div.items');
		itemsElement.update();
		itemsElement.appendChild(fragment);
		this._update(false);
	},
	remove: function(inEvent) {
		var elem = inEvent.element();
		var item = this._itemForLogin(elem.getAttribute('userlogin')); 
		if (item) {
			this.mACLItems = this.mACLItems.without(item);
			this.mNewPermissionList = this.mNewPermissionList.without(item);
			smokey().showOverElement(item.element);
			item.element.remove();
			item = null;
		}
		this._update(true);
	},
	handleAccessChanged: function(inEvent) {
		// if it was authed that changed, then check that unauthed isn't better
		if (inEvent.element().getAttribute('userlogin') == "authenticated") {
			var unauthedElement = this.mAllUsers.element.down('.permissions select')
			var unauthedRole = unauthedElement.value;
			var authedElement = this.mLoggedInUsers.element.down('.permissions select')
			var authedRole = authedElement.value;
			if (authedRole == "none") {
				if (unauthedRole != "none") {
					unauthedElement.setValue("none");
				}
			}
			if (authedRole == "read") {
				if (unauthedRole != "none" && unauthedRole != "read") {
					unauthedElement.setValue("read");
				}
			}
		}
		// now that the UI elements agree, set the in memory attributes
		for (var i = 0; i < this.mACLItems.length; i++) {
			var anItem = this.mACLItems[i];
			// update action and allow...
			var selElement = anItem.element.down('.permissions select');
			anItem.action = selElement.value;
		}
		
		this._update(true);
	},
	handleClickedRecord: function(inUnusedDisplayString, inUnusedURL) {
		var dataSource = (this.userSearchField.mChosenDataSource || {});
		if (!dataSource.entityGUID)
			return; // empty click, or bad record, don't add it 
		var item = {
			action: "read",
			allow: "true",
			userExternalID: dataSource.entityGUID,
			userLogin: dataSource.entityUserLogin,
			userLongName: dataSource.entityUserLongName
		};
		this.textfield.value = '';
		if (this._itemAlreadyPresent(item)) return; // don't add something more than once
		this.mACLItems.push(item);
		this.mNewPermissionList.push(item);
		this.recordList.appendChild(this._buildAccessItemView(item));
		this._update(true);
	},
	validItems: function() {
		var val = [];
		for (var i = 0; i < this.mACLItems.length; i++) {
			var anItem = this.mACLItems[i];
			if (anItem.allow && (anItem.action != "none")) {
				val.push(anItem);
			}
		}
		return val;
	},
	validNewItems: function() {
		var val = [];
		for (var i = 0; i < this.mNewPermissionList.length; i++) {
			var anItem = this.mNewPermissionList[i];
			if (anItem.allow && (anItem.action != "none")) {
				val.push(anItem);
			}
		}
		return val;
	},	
	serialize: function(isUpdatedList) {
		// go through and only serialize special users if their allow is not none
		var val = [];
		// Valid entity acl fields (because validItems includes extra junk like DOM element pointers).
		var fields = 'allow action userExternalID userLogin userLongName'.w();
		
		// use the same function to serialize either the new updatedALCs List or the new sharedNotifications List
		// both are sent out to the server (setACLs)
		var currentList = [];
		if (isUpdatedList)
			currentList = this.validItems();
		else
			currentList = this.validNewItems();
					
		currentList.each(function(anItem) {	
			var newItem = {};
			for (var i = 0; i < fields.length; i++) {
				newItem[fields[i]] = anItem[fields[i]];
			}
			var acl = new CC.EntityTypes.EntityACL(newItem);
			val.push(acl);
		});
		return val;
	},
	save: function(inOptCallback, inOptErrback) {
		var callback = function() {
			this.onSaveSuccess();
			if (inOptCallback) inOptCallback();
		}.bind(this);
		var errback = function(response) {
			this.onSaveFailure();
			if (inOptErrback) inOptErrback(response);
		}.bind(this);
		
		// Updated list of ACLs that has to be sent to the server
		var updatedACLs = this.serialize(true);
		
		// New notification list (send email when document is shared to the related users only, not all the subscribed users!)
		var sharedNotifications = this.serialize(false);	
			
		if (updatedACLs.length > 0) {
			server_proxy().setACLsOnEntity(sharedNotifications, updatedACLs, this.mEntityGUID, callback, errback);
			
			// resets shared notifications list for the next permission edition
			this.mNewPermissionList = [];			
		}
	},
	onSaveSuccess: function(request) {
		this.dirty = false;
	},
	onSaveFailure: function(request) {
		notifier().printErrorMessage("_AccessEditor.SaveFailure".loc());
	}
});
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.



// A disclosure view with an open/close triangle, title row and content view.

CC.DisclosureView = Class.create(CC.Mvc.View, {
	mClassName: 'cc-disclosure-view',
	// Is this disclosure view open or closed?
	mOpen: true,
	// The title row text we display.
	mTitleRowText: "",
	// The content view for this disclosure view.
	mContentView: null,
	initialize: function($super) {
		$super.apply(null, Array.prototype.slice.call(arguments, 1));
		if (this.mContentView) {
			this.addSubview(this.mContentView, 'div.content', false);
		} else {
			logger().error("Content view is not specified for disclosure view, skipping addSubview call");
		}
	},
	render: function() {
		var randomString = buildRandomString();
		globalEventDelegate().registerDomResponderForEventByIdentifer('click', randomString, this.handleTitleClicked.bindAsEventListener(this));
		return Builder.node('div', {className: 'open'}, [
			Builder.node('div', {className: 'title', 'data-responder-id': randomString}, [
				Builder.node('span', {className: 'beforetitle'}),
				(this.mTitleRowText || "").loc(),
				Builder.node('span', {className: 'aftertitle'})
			]),
			Builder.node('div', {className: 'content selectable'})
		]);
	},
	setIsOpen: function(inShouldBeOpen) {
		if (inShouldBeOpen == this.mOpen) return;
		if (inShouldBeOpen == true) {
			this.mOpen = true;
			this.mParentElement.addClassName('open');
		} else {
			this.mOpen = false;
			this.mParentElement.removeClassName('open');
		}
	},
	handleTitleClicked: function(inEvent) {
		this.setIsOpen(!this.mOpen);
	}
});
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.



// Simple stack view implementation. 

CC.StackedView = Class.create(CC.Mvc.View, {
	mClassName: 'cc-stacked-view',
	setContentViews: function(inContentViews) {
		for (var idx = 0; idx < inContentViews.length; idx++) {
			this.addSubview(inContentViews[idx]);
		}
	}
});
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.



var FileUploadPanel = Class.createWithSharedInstance('fileUploadManager');
FileUploadPanel.prototype = {
	fileDialog: null,
	chosenFile: null,
	existingFilesList: [],
	callbacks: [],
	initialize: function() {},
	createUploadPanel: function(inOptUpdateGUID, inOptOwnerGUID, inOptCallbacks, inOptHideFileOnUpload, inOptIsAvatar, inOptSkipDefaultACLs) {
		if (inOptCallbacks != undefined) {
			this.callbacks = inOptCallbacks;
		} else {
			this.callbacks = {};
		}
		document.body.appendChild(Builder.node('iframe', {
			name: 'upload_iframe',
			id: 'upload_iframe',
			src: '',
			style: 'position:absolute;top:-10000px;left:-10000px;width:0px;height:0px;border:10px'
		}));
		$('upload_iframe').show();
		
		var existing = $('upload_file_dialog');
		if (existing) Element.remove(existing);
		var formAction = "/wiki/files/upload";
		var tabIndex = accessibility().requestTabIndex(CC.Accessibility.TAB_INDEX_NAME_POPUP_DIALOG_UPLOAD_FILE_TO_DOCUMENTS);
		dialogManager().drawDialog('upload_file_dialog', [
			{label: "_Files.Upload.Dialog.Label".loc(), contents: '<input aria-label="' + "_Accessibility.Dialog.UploadFile".loc() + '" tabindex="' + tabIndex + '" role="menuitem" type="file" id="fileChooser" name="filedata" class="cc-file-upload"/>' +
				'<input type="hidden" name="updateGUID" id="updateGUID" value="%@"/>'.fmt(inOptUpdateGUID ? inOptUpdateGUID : "0") +
				'<input type="hidden" name="isHidden" value="%@"/>'.fmt((inOptHideFileOnUpload == true)) +
				'<input type="hidden" name="isAvatar" value="%@"/>'.fmt((inOptIsAvatar == true)) +
				'<input type="hidden" name="skipDefaultACLs" value="%@"/>'.fmt((inOptSkipDefaultACLs == true)) + 
				(inOptOwnerGUID ? '<input type="hidden" name="ownerGUID" id="ownerGUID" value="%@"/>'.fmt(inOptOwnerGUID) : '')
			}
		], "_Files.Upload.Dialog.OK".loc(), formAction, "_Files.Upload.Dialog.Title".loc(), "_Dialogs.Cancel".loc());
		dialogManager().show('upload_file_dialog', this.handleUploadPanelCancel.bind(this), this.handleUploadPanelOK.bind(this));		
		$('fileChooser').focus();
	},
	handleUploadPanelOK: function(inEvent) {
		var fileChooser = $$('.cc-file-upload')[0];
	    if (fileChooser && fileChooser.value.length == 0 )
	        return;
		this.startUpload();
		dialogManager().showProgressMessage("_Files.Progress.Uploading".loc(), false, this.handleProgressPanelCancel.bind(this));
	},
	handleUploadPanelCancel: function(inEvent) {
		
	},
	handleProgressPanelCancel: function(inEvent) {
		$('upload_iframe').remove();
		dialogManager().hideProgressMessage();
	},
	startUpload: function() {
		var form = document.forms.upload_file_dialog_form;
		
		// get an action token, inject it into the form before submitting
		var req = new Ajax.Request(form.action, {
			method: 'GET',
			onSuccess: function(response) {
				var token = response.getHeader('X-Apple-Action-Token');
				if (token)
				{
					var el = document.createElement('input');
					el.type = 'hidden';
					el.name = 'actionToken';
					el.value = token;
					form.appendChild(el);
				}
				
				form.submit();
			},
			onFailure: function() {
				form.submit();
			}
		});
	},
	
	// callbacks
	uploadComplete: function(fileDataObject) {
		// create a new com.apple.entity.File object
		var updateGUID = fileDataObject['updateGUID'];
		var fileDataGUID = fileDataObject['fileGUID'];
		
		// CONSIDER: Do we need both of these? Or can we just listen for notifications?
		// I think both is good. When you want to redirect to a new page, or do something big, use a callback
		// when you just want to update something when the upload is done, use notifications
		
		// Fire an upload complete callback, if we have it.
		var callbacks = this.callbacks;
		if (callbacks && callbacks['complete']) {
			var callback = callbacks['complete'];
			(callback.target || window)[callback.callback](fileDataObject);
		}
		globalNotificationCenter().publish("FILE_UPLOAD_DID_SUCCEED", this, fileDataObject);
		
		//$('upload_iframe').hide();
		//$('upload_iframe').remove();
		
		// oldDialogManager().destroyDialog();
		
		dialogManager().hide();
		
	},
	uploadError: function(errorObject) {
		var errorString = errorObject['errorString'];
		
		var uploadErrorText = Builder.node("div", {className:"upload_error"}, [
			Builder.node("div", {className:"label"}, "Upload Error"),
			Builder.node("div", {className:"error_string"}, errorString)
		]);
		
		// oldDialogManager().updateDialog(uploadErrorText);
		// oldDialogManager().enableCancelButton();
		// Fire an upload error callback, if we have it.
		var callbacks = this.callbacks;
		if (callbacks && callbacks['error']) {
			var callback = callbacks['error'];
			(callback.target || window)[callback.callback](errorObject);
		}
		// broadcast a message
		globalNotificationCenter().publish("FILE_UPLOAD_DID_ERROR", this, errorObject);
		dialogManager().hide();
	},
	
	// **** New File
	uploadNewFileInContainerGUID: function(inContainerGUID) {
		this.createUploadPanel(undefined, inContainerGUID, {'complete':{callback:'uploadNewFileCallback', target:this}, 'error': {callback: 'uploadNewFileErrback', target: this}});
	},
	uploadNewFileCallback: function(fileEntityObject) {
		// push them to the new url
		var url = window.location.protocol + '//' + window.location.host + env().root_path + '/files/' + fileEntityObject['fileTinyID'];
		window.location.href = url;
	},
	uploadNewFileErrback: function(inError) {
		notifier().printErrorMessage("File could not be uploaded. Please try again.");
	},
	
	//**** Update File
	updateFile: function() {
		var updateGUID = CC.meta('x-apple-entity-guid');
		if (!updateGUID) { 
			logger().warn("Unable to get the file guid we are supposed to be updating");
			return; 
		}
		this.createUploadPanel(updateGUID, undefined, {'complete':{callback:'updateFileCallback', target:this}, 'error': {callback: 'updateFileErrback', target: this}});
	},
	updateFileCallback: function(fileEntityObject) {
		window.location.reload();
	},
	updateFileErrback: function(inError) {
		notifier().printErrorMessage("File could not be updated. Please try again.");
	}
	
};
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.

CC.AvatarEditorView = Class.create(CC.Mvc.View, {
	initialize: function($super, inType) {
		$super();
		this.entityType = inType;
	},
	render: function() {
		var tabIndex = accessibility().requestTabIndex(CC.Accessibility.TAB_INDEX_NAME_POPUP_SETTINGS_APPEARANCE_PARAMS);
		return Builder.node('div', {className:"cc-avatar-editor"}, [
			Builder.node('div', {className:"cc-avatar-preview default %@".fmt((this.entityType == 'people') ? 'user' : 'project')} ),
			Builder.node('div', {className:"cc-avatar-controls"}, [
				Builder.node('input', {'tabindex': tabIndex, 'role': 'button', 'aria-label': "_Accessibility.Button.UploadImage".loc(), type: 'button', value: "_Settings.Avatar.UploadButton".loc(), className:"cc-avatar-upload-button"}),
				Builder.node('input', {'tabindex': tabIndex, 'role': 'button', 'aria-label': "_Accessibility.Button.DeleteImage".loc(), type: 'button', value: "_Settings.Avatar.DeleteButton".loc(), className:"cc-avatar-delete-button"})
			])
		]);
	}
});

CC.AvatarEditor = Class.create({
	
	initialize: function(element, guid, is_avatar, skipDefaultACLs) {
		this.element = $(element);
		this.skipDefaultACLs = (skipDefaultACLs != undefined) ? skipDefaultACLs : false;
		this.is_avatar = is_avatar;
		
		var upButton = this.element.down('.cc-avatar-upload-button');
		if (upButton) upButton.on('click', this.onUploadButtonClick.bindAsEventListener(this));
		
		var delButton = this.element.down('.cc-avatar-delete-button');
		if (delButton) delButton.on('click', this.onRemoveButtonClick.bindAsEventListener(this));
		
		this.file_guid = (guid && guid != '') ? guid : null;
		
		this.updateElementState();
	},
	clear: function() {
		this.file_guid = null;
		this.updateElementState();
		dialogManager().hide();
	},
	buildPreviewURLForDataGUID: function(guid) {
		if (guid == null || guid == '') return;
		var url = "#{prefix}/files/download/#{guid}".interpolate({
			prefix: env().root_path,
			guid: guid
		});
		return url;
	},
	updateElementState: function() {
		var preview = this.element.down('.cc-avatar-preview');
		(this.file_guid) ? preview.removeClassName('default') : preview.addClassName('default');
		var uploadButton = this.element.down('.cc-avatar-upload-button');
		if (uploadButton) uploadButton.value = (this.file_guid) ? "_AvatarEditor.Replace".loc() : "_AvatarEditor.Upload".loc();
		preview.removeAttribute('style');
		var url = this.buildPreviewURLForDataGUID(this.file_guid);
		if (url) {
			// Preload the image and center it using background-size.
			var img = new Image();
			img.onload = function() {
				var ratio = (img.height / img.width);
				var width = Math.min(img.width, 44);
				var height = Math.ceil(44 * ratio);
				preview.style.backgroundImage = "url(%@)".fmt(url);
				preview.style.backgroundSize = "%@px %@px".fmt(width, height);
				preview.style.backgroundPosition = "center center";
			};
			img.src = url;
		}
		var button = this.element.down('.cc-avatar-delete-button');
		if (button) {
			(this.file_guid) ? button.show() : button.hide();
		}
	},
	onUploadButtonClick: function(e) {
		e.stop();
		fileUploadManager().createUploadPanel(undefined, undefined, { 
			'complete': { callback: 'onUploadSuccess', target: this },
			'error': { callback: 'onUploadFailure', target: this }
		}, true, this.is_avatar, this.skipDefaultACLs);
	},
	onUploadSuccess: function(inResponse) {
		var file_entity = (inResponse && inResponse["fileEntity"]);
		if (file_entity) {
			this.file_guid = file_entity.guid;
			this.updateElementState();
		}
	},
	onUploadFailure: function(err) {
		alert("_AvatarEditor.UploadFailed".loc());
		this.clear();
	},
	
	onRemoveButtonClick: function(e) {
		e.stop();
		this.clear();
	}
	
});
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.

CC.RecentSearches = Class.createWithSharedInstance('globalRecentSearches');
CC.RecentSearches.prototype = {
	mStackSize: 5,
	mStackName: 'x-apple-wiki-recent-searches',
	initialize: function() {
		globalNotificationCenter().subscribe("AUTHENTICATION_LOGGED_OUT", this.flush.bind(this));
	},
	_stackRepository: function() {
		if (browserSupportsLocalStorage()) {
			var repoStr = window.localStorage.getItem(this.mStackName);
			if (!repoStr || repoStr == 'null') {
				repoStr = Object.toJSON({tags:[], searches:[]});
				window.localStorage.setItem(this.mStackName, repoStr);
			}
			return repoStr.evalJSON();
		}
		return {};
	},
	_addItemToStack: function(inItem, inStackKey, inOptRemoveInstead) {
		if (!browserSupportsLocalStorage()) return false;
		// bail if there's no item (or it's an empty string)
		if (!inItem) return null;
		// bail if we can't get a repo
		var repo = this._stackRepository();
		if (!repo) return false;
		// get the array for the key
		var keyArray = repo[inStackKey];
		// remove the item if there's another instance in the stack
		if (keyArray.indexOf(inItem) >= 0) keyArray.splice(keyArray.indexOf(inItem), 1);
		// reduce it to stackSize-1
		while (keyArray.length >= this.mStackSize) {
			keyArray.pop();
		}
		// add the item to the beginning of the array
		if (!inOptRemoveInstead) keyArray.unshift(inItem);
		window.localStorage.setItem(this.mStackName, Object.toJSON(repo));
		return true;
	},
	_getStack: function(inStackKey) {
		var repo = this._stackRepository();
		return (repo ? repo[inStackKey] : []);
	},
	searchStack: function() {
		return this._getStack('searches');
	},
	addSearchToStack: function(inSearchString) {
		return this._addItemToStack(inSearchString, 'searches');
	},
	removeSearchFromStack: function(inSearchString) {
		return this._addItemToStack(inSearchString, 'searches', true);
	},
	flush: function() {
		if (browserSupportsLocalStorage()) {
			if (window.localStorage.getItem(this.mStackName)) window.localStorage.removeItem(this.mStackName);
		}
	}
};
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.

CC.EntityTitle = CC.EntityTitle || new Object();
CC.EntityTitle.NOTIFICATION_TITLE_SHOULD_UPDATE = 'ENTITY_TITLE_SHOULD_UPDATE';
CC.EntityTitle.NOTIFICATION_TITLE_DID_CHANGE = 'ENTITY_TITLE_DID_CHANGE';

// Base class for an editable page title view.  Used by the editor to display the page title,
// last modified information and a favorite star.  Also used to display standalone file titles.

CC.EntityTitle.EntityTitleView = Class.create(CC.Mvc.View, {
	// Should this title be editable or not?
	mEditable: false,
	// Renders the title view.
	render: function() {
		return Builder.node('div', {className: 'cc-entity-title chrome'}, [
			Builder.node('div', {className: 'title-container'}, [
				Builder.node('h1', {className: 'title-readonly'}),
				Builder.node('div', {className: 'title-edit'}, [
					Builder.node('input', {type: 'text'})
				]),
				Builder.node('h2'),
				Builder.node('a', {className: 'cc-entity-favorite-toggle'})
			])
		]);
	},
	// Watches for a page title changed notification and updates the title. Reverts to a
	// default placeholder where the title is undefined. It is assumed the notification
	// includes a store-compatible instance backed by a suitable record.
	updateDisplay: function(inMessage, inObject, inOptExtras) {
		// Update the page title.
		var title = (inObject && inObject.mRecord && inObject.getRecordPropertyForPath('longName'));
		var displayTitle = (!title || (title && title.isWhitespace())) ? "_EntityTitle.PageTitle.Untitled".loc() : title;
		var strippedTitle = displayTitle.strip();
		var entityURL = CC.entityURL(inObject.mRecord, true);
		var titleElement = this.$().down('h1.title-readonly');
		var tabIndex = accessibility().requestTabIndex(CC.Accessibility.TAB_INDEX_NAME_BOT_HEADER_VIEW_ENTITY_TITLE);
		titleElement.innerHTML = "";
		titleElement.appendChild(Builder.node('a', {'tabindex': tabIndex, 'href': '#', 'data-href': entityURL, 'title': displayTitle}, strippedTitle));
		// Update the favorite widget and last modified information.
		if (inObject && inObject.mRecord && inObject.mRecord.updatedByUser) {
			var entity = inObject.mRecord;
			var favoriteToggle = this.$().down('.cc-entity-favorite-toggle');
			favoriteToggle.setAttribute('data-guid', entity.guid);
			entity.isFavorite ? favoriteToggle.addClassName('selected') : favoriteToggle.removeClassName('selected');
			var updatedTimestamp = globalLocalizationManager().localizedDateTime(entity.updateTime);
			var updatedDisplayName, updatedShortName, updatedByURL, updatedMarkup;
			if (entity.updatedByUser.shortName == "unauthenticated") {
				updatedMarkup = "_EntityTitle.LastModified.Unauthenticated".loc();
			} else {
				updatedDisplayName = (entity.updatedByUser.longName || entity.updatedByUser.shortName).escapeHTML();
				updatedShortName = (entity.updatedByUser.shortName || "").escapeHTML();
				updatedByURL = CC.entityURL(entity.updatedByUser);
				updatedMarkup = "<a href='%@'>%@</a>".fmt(updatedByURL, updatedDisplayName);
			}
			this.$().down('h2').innerHTML = "_EntityTitle.LastModified".loc(updatedTimestamp, updatedMarkup);
		}
		globalNotificationCenter().publish(CC.Routes.NOTIFICATION_ROUTES_SHOULD_UPDATE, undefined, {'rootElement': this.$()});
		return true;
	},
	updateTitle: function() {
		var elem = this.$();
		var updatedTitle = $F(elem.down('input'));
		if (this._cachedTitle != updatedTitle) {
			this._cachedTitle = updatedTitle;
			elem.down('h1.title-readonly a').innerHTML = this._cachedTitle.escapeHTML();
			globalNotificationCenter().publish(CC.EntityTitle.NOTIFICATION_TITLE_DID_CHANGE, this, {title: this._cachedTitle});
		}
	},
	registerEventHandlers: function() {
		var elem = this.mParentElement;
		bindEventListeners(this, [
			'handleDisplayTitleClick',
			'handleDisplayTitleFieldBlur',
			'handleDisplayTitleFieldKeyDown',
			'handleDisplayTitleFieldKeyUp'
		]);
		Event.observe(elem.down('h1.title-readonly'), 'click', this.handleDisplayTitleClick);
		Event.observe(elem.down('input'), 'blur', this.handleDisplayTitleFieldBlur);
		Event.observe(elem.down('input'), 'keydown', this.handleDisplayTitleFieldKeyDown);
		Event.observe(elem.down('input'), 'keyup', this.handleDisplayTitleFieldKeyUp);
		elem.select('.cc-entity-favorite-toggle').each(function(toggle) { new CC.EntityFavoriteToggle(toggle); });
		globalNotificationCenter().subscribe(CC.EntityTitle.NOTIFICATION_TITLE_SHOULD_UPDATE, this.updateDisplay.bind(this), this.mContent);
	},
	handleDisplayTitleClick: function(inEvent) {
		if (!this.mEditable) {
			// Grab the data-href from the source.
			var header = Event.findElement(inEvent, 'h1');
			var source = header.down('a');
			var dataHref = source.getAttribute('data-href');
			if (dataHref) {
				globalRouteHandler().routeURL(dataHref);
				return true;
			}
		};
		// Stop the event so we don't trigger the link.
		Event.stop(inEvent);
		var elem = this.$();
		elem.addClassName('editing');
		this._cachedTitle = elem.down('h1.title-readonly a').innerHTML.unescapeHTML();
		this.$().down('input').value = this._cachedTitle;
		this.$().down('input').activate();
	},
	handleDisplayTitleFieldBlur: function(inEvent) {
		this.updateTitle();
		this.$().removeClassName('editing');
	},
	handleDisplayTitleFieldKeyDown: function(inEvent) {
		inEvent.stopPropagation();
		var keyCode = inEvent.keyCode;
		if (keyCode == Event.KEY_RETURN) this.handleDisplayTitleFieldBlur(inEvent);
		if (keyCode == Event.KEY_TAB) this.handleDisplayTitleFieldTab(inEvent);
	},
	handleDisplayTitleFieldKeyUp: function(inEvent) {
		this.updateTitle();
	},
	handleDisplayTitleFieldTab: function(inEvent) {
		Event.stop(inEvent);
		this.updateTitle();
		globalNotificationCenter().publish(CC.Keyboard.NOTIFICATION_DID_KEYBOARD_TAB, this);
	}
});
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.




// Editor namespace.

CC.WikiEditor = CC.WikiEditor || new Object();
CC.WikiEditor.Mixins = CC.WikiEditor.Mixins || new Object();
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.

Object.extend(Array.prototype, {
	// Removes all instances of an item from an array.
	remove: function(item) {
		var result = [];
		for (var i = 0; i < this.length; i++) {
			if (this[i] != item) result.push(this[i]);
		}
		return result;
	}
});
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.

CC.TRAILING_WHITESPACE_TAGS = 'blockquote div dd dt h1 h2 h3 h4 h5 h6 li ol p pre ul span'.w();
CC.HEADER_TAGS = 'h1 h2 h3 h4 h5 h6'.w();
CC.FORMATTING_TAGS = 'b i u strong em'.w();
CC.LIST_TAGS = 'ol ul'.w();
CC.BLOCK_LEVEL_TAGS = 'blockquote code div dl fieldset form h1 h2 h3 h4 h5 h6 hr img ol p pre table ul'.w();

// Cleans any unwanted trailing whitespace or whitespace-containing text nodes,
// or empty trailing tags from the end of an element. Optionally accepts a boolean
// parameter where leading whitespace is removed instead of trailing.

var cleanTrailingWhitespace = function(inElement, inOptLeadingInstead) {
	if (!inElement) return false;
	// Does the node just contain whitespace nodes, or empty meaningless tags?
	var recursivelyClean = function(rootNode) {
		if (!rootNode) return false;
		if (rootNode.nodeType == 3) {
			// If the text node is just a whitespace node, remove it.
			if (isWhitespaceNode(rootNode)) {
				rootNode.parentNode.removeChild(rootNode);
				return true;
			}
			// Otherwise clean any leading/trailing whitespace from the text node.
			else {
				var nodeValue = (rootNode.nodeValue || "");
				var matches = nodeValue.match(/^(\s*)(.*)(\s*)$/);
				if (matches && matches.length == 4) {
					rootNode.nodeValue = matches.splice((inOptLeadingInstead ? 2 : 1), 2).join('');
				}
			}
			return false;
		}
		// Is the node an empty block-level node?
		var children = rootNode.childNodes;
		if (children.length == 0) {
			var rootNodeName = rootNode.nodeName.toLowerCase();
			if (rootNodeName == 'br' || CC.TRAILING_WHITESPACE_TAGS.indexOf(rootNodeName) != -1) {
				rootNode.parentNode.removeChild(rootNode);
				return true;
			}
			return false;
		}
		// Otherwise recurse over each of the children.
		var bubbleDeleteToParentNode = true;
		var childrenLength = children.length, childNode;
		for (var j = 0; j < childrenLength; j++) {
			childNode = children.item(j);
			if (!recursivelyClean(childNode)) {
				bubbleDeleteToParentNode = false;
				break;
			}
		}
		// If every nested child node was empty or whitespace, nuke the parent.
		if (bubbleDeleteToParentNode) {
			rootNode.parentNode.removeChild(rootNode)
			return true;
		}
		return false;
	};
	// Recursively clean trailing or leading whitespace from the element.
	var element = $(inElement), node = (inOptLeadingInstead ? element.firstChild : element.lastChild), nextNode;
	while (node) {
		nextNode = (inOptLeadingInstead ? node.nextSibling : node.previousSibling);
		if (!recursivelyClean(node)) break;
		node = nextNode;
		continue;
	}
	// Return the cleaned element.
	return element;
};

var cleanLeadingWhitespace = function(inElement) {
	return cleanTrailingWhitespace(inElement, true);
};

// Whitespace nodes are text nodes with nothing but whitespace in them. Formatting
// nodes are bold, italic or underline tags.

var isWhitespaceNode = function(node) {
	return (node && node.nodeType == 3 && !/\S/.test(node.nodeValue));
};

var isFormattingNode = function(node) {
	return (node && CC.FORMATTING_TAGS.indexOf(node.nodeName.toLowerCase()) >= 0);
};

// Returns true if a node is a span tag with a recognized styling class name applied.

var isStyledSpanTag = function(node) {
	return (node && node.nodeName.toLowerCase() == 'span' && (node.className && node.className.match(/important|emphasis|highlight/)));
};

// Defining a bogus div child as another div or a line break.

var isBogusDivChild = function(node) {
	return (node && (['br', 'div'].indexOf(node.nodeName.toLowerCase()) >= 0) && !node.hasChildNodes());
};

// Returns true if a node is a empty list node.

var isEmptyList = function(inNode) {
	if (!inNode) return false;
	var childNodes, childNodesLength, childNode, childNodeIdx;
	var subChildNodes, subChildNodesLength, subChildNode, subChildNodeIdx;
	childNodes = inNode.childNodes;
	childNodesLength = childNodes.length;
	// A list is empty if it has no child nodes.
	if (childNodesLength == 0) return true;
	// A list is empty if it contains empty/whitespace child nodes.
	for (childNodeIdx = 0; childNodeIdx < childNodesLength; childNodeIdx++) {
		childNode = childNodes.item(childNodeIdx);
		if (childNode) {
			subChildNodes = childNode.childNodes;
			subChildNodesLength = subChildNodes.length;
			for (subChildNodeIdx = 0; subChildNodeIdx < subChildNodesLength; subChildNodeIdx++) {
				subChildNode = subChildNodes.item(subChildNodeIdx);
				// Is the child node a nested list?
				if (CC.LIST_TAGS.indexOf(subChildNode && subChildNode.nodeName.toLowerCase())) {
					if (!isEmptyList(subChildNode)) return false;
				}
				// Is the child node a whitespace node?
				if (!isWhitespaceNode(subChildNode)) return false;
			}
		}
	}
	return true;
};

// Returns true if a node only contains text or line-break nodes.

var onlyTextOrLineBreaks = function(inNode) {
	if (!inNode) return false;
	var childNodes, childIdx, currentChild, only = true;
	childNodes = inNode.childNodes;
	for (childIdx = 0; childIdx < childNodes.length; childIdx++) {
		currentChild = childNodes.item(childIdx);
		if (currentChild.nodeType != 3 && currentChild.nodeName.toLowerCase() != 'br') {
			only = false;
			break;
		}
	}
	return only;
};

// Removes any unwanted markup turds.

var removeMeaninglessMarkup = function(inElement) {
	var elem = $(inElement);
	// Remove any unnecessary header tags.
	var headers = elem.select(CC.HEADER_TAGS.join(','));
	var headerIndex, header, children, childrenLength, zombieHeader, childIndex, child;
	for (headerIndex = 0; headerIndex < headers.length; headerIndex++) {
		header = headers[headerIndex];
		// If the header only contains block level elements and/or whitespace
		// nodes, promote the children and zap the header.
		children = header.childNodes;
		childrenLength = children.length;
		zombieHeader = true;
		for (childIndex = 0; childIndex < childrenLength; childIndex++) {
			child = children[childIndex];
			// Bail if we find something non-zombie-esque.
			if ((CC.BLOCK_LEVEL_TAGS.include(child.nodeName.toLowerCase()) || isWhitespaceNode(child)) == false) {
				zombieHeader = false;
				break;
			}
		}
		if (zombieHeader) {
			promoteElementChildren(header);
		}
	}
	// Nuke any superfluous div tags.
	var pageDivs = elem.getElementsByTagName('div');
	var divIdx, div, node, whitespace, whitespaceIdx, whitespaceNode, nextNode, childNodes;
	for (divIdx = (pageDivs.length - 1); divIdx >= 0; divIdx--) {
		div = pageDivs.item(divIdx);
		// Bail if we have an identifer or a class name.
		if ((div.className && div.className != '') || (div.id && div.id != '')  || (div.style && div.style != '')) continue;
		// If the div is completely empty, nuke it.
		if (div.childNodes.length == 0) {
			div.parentNode.removeChild(div);
			continue;
		}
		// If the first child of the div is a block-level element, promote
		// the children and nuke the div.
		node = div.childNodes.item(0);
		whitespace = new Array(), bail = false;
		while (node) {
			nextNode = node.nextSibling;
			if (!isWhitespaceNode(node)) {
				if (CC.BLOCK_LEVEL_TAGS.include(node.nodeName.toLowerCase())) {
					for (whitespaceIdx = 0; whitespaceIdx < whitespace.length; whitespaceIdx++) {
						whitespaceNode = whitespace[whitespaceIdx];
						whitespaceNode.parentNode.removeChild(whitespaceNode);
					}
					promoteElementChildren(div);
					bail = true;
				}
				break;
			}
			whitespace.push(node);
			node = nextNode;
		}
		if (bail) continue;
		// If the first node is a whitespace node wih no next sibling, remove
		// the div.
		node = div.childNodes.item(0);
		if (isWhitespaceNode(node)) {
			if (!node.nextSibling) {
				node.parentNode.removeChild(node);
				continue;
			}
			node = node.nextSibling;
		}
		// Is the tag an empty/meaningless formatting tag.
		if (isFormattingNode(node)) {
			if (node.className || node.id) continue;
			// Is the node empty?
			childNodes = node.childNodes;
			if (isWhitespaceNode(node) || childNodes.length == 0) {
				node.parentNode.removeChild(node);
				continue;
			}
		}
		if (isBogusDivChild(node)) {
			// Bail if there is a non-whitespace node that follows this one.
			if (node.nextSibling && !isWhitespaceNode(node.nextSibling)) continue;
			// Zap!
			promoteElementChildren(div);
		}
	}
	// Nuke any superfluous span tags.
	var pageSpans = elem.getElementsByTagName('span');
	var spanIdx, span;
	for (spanIdx = (pageSpans.length - 1); spanIdx >= 0; spanIdx--) {
		span = pageSpans.item(spanIdx);
		if ((span.className && span.className != '') || (span.id && span.id != '') || (span.style && span.style != '')) continue;
		promoteElementChildren(span);
	}
	// Nuke any empty list elements.
	var lists = elem.select(CC.LIST_TAGS.join(','));
	var list, listIdx;
	for (listIdx = (lists.length - 1); listIdx >= 0; listIdx--) {
		list = lists[listIdx];
		if (isEmptyList(list)) {
			list.parentNode.removeChild(list);
		}
	}
	// Nuke any HR tags.
	var hrs = elem.select('hr');
	var hrIdx, hr;
	for (hrIdx = (hrs.length - 1); hrIdx >= 0; hrIdx--) {
		hr = hrs[hrIdx];
		hr.parentNode.removeChild(hr);
	}
	// Fix any unnecessarily nested lists where the only child of an li tag is a ul tag.
	var nestedBullets = elem.select('li ul, li ol'), bulletIdx, bullet, oldParent;
	for (bulletIdx = (nestedBullets.length - 1); bulletIdx >= 0; bulletIdx--) {
		bullet = nestedBullets[bulletIdx];
		oldParent = bullet.parentNode;
		if (oldParent.nodeName.toLowerCase() == 'li' && oldParent.childNodes.length == 1) {
			promoteElementChildren(oldParent);
		}
	}
	// Return.
	return elem;
};

// Reduces the child nodes of a supplied DOM element to be only a combination of
// text nodes, inline styles and link nodes.

var isTextNodeFormattingNodeOrLinkNode = function(inNode) {
	if (!inNode) return false;
	return (inNode.nodeType == 3 || isFormattingNode(inNode) || isStyledSpanTag(inNode) || inNode.nodeName.toLowerCase() == 'a');
};

var reduceToTextLinksAndStyles = function(inElement) {
	var elem = removeMeaninglessMarkup(inElement);
	var rootNode, childNodesLength, childIdx;
	var recursivelyReduce = function(elementsToReduce) {
		// If we have nothing left to reduce, we're done.
		if (elementsToReduce.length == 0) return elem;
		// Reduce the first element in the queue.
		rootNode = elementsToReduce.shift();
		// Continue reducing if the first element has no children and is a text/link/formatting node.
		if (rootNode.childNodes.length == 0 && isTextNodeFormattingNodeOrLinkNode(rootNode)) return recursivelyReduce(elementsToReduce);
		// Otherwise, push each of the current nodes children on to the reduction queue.
		childNodesLength = rootNode.childNodes.length;
		for (childIdx = 0; childIdx < childNodesLength; childIdx++) {
			elementsToReduce.push(rootNode.childNodes.item(childIdx));
		}
		// If the wrapping node is not a text node, link or formatting node, remove it.
		if (!isTextNodeFormattingNodeOrLinkNode(rootNode)) promoteElementChildren(rootNode);
		// Recurse on the remaining elements to reduce.
		return recursivelyReduce(elementsToReduce);
	}
	var childNodes = elem.childNodes, topLevelChildren = new Array();
	for (var childNodeIdx = 0; childNodeIdx < childNodes.length; childNodeIdx++) {
		topLevelChildren.push(childNodes.item(childNodeIdx));
	}
	return recursivelyReduce(topLevelChildren);
};

// Is the node a <br> tag.

var isBrTag = function(inElement) {
	return (inElement && inElement.nodeType == 1 && inElement.nodeName.toLowerCase() == 'br');
};

// A fast document fragment friendly version of Element#insert. You should only
// ever call this if you know what you're doing.

var fragmentSafeElementInsert = function(inElement, inPosition) {
	if (!inElement || !inPosition) return inElement;
	if (Object.isString(inPosition) || Object.isNumber(inPosition) || Object.isElement(inPosition) || (inPosition && (inPosition.toElement || inPosition.toHTML))) {
		inPosition = {'bottom': inPosition};
	}
	var key, element, _wrapper, position;
	for (key in inPosition) {
		element  = inPosition[key];
		if (!element) continue;
		position = key.toLowerCase();
		_wrapper = null;
		if (Object.isString(element)) {
			_wrapper = new Element('div').update(element);
		}
		switch (position) {
			case 'before':
				if (inElement.parentNode) inElement.parentNode.insertBefore((_wrapper || element), inElement);
				break;
			case 'after':
				if (inElement.parentNode) inElement.parentNode.insertBefore((_wrapper || element), inElement.nextSibling);
				break;
			case 'top':
				inElement.insertBefore((_wrapper || element), inElement.firstChild);
				break;
			case 'bottom':
				inElement.appendChild((_wrapper || element))
				break;
		}
		if (_wrapper && _wrapper.parentNode) {
			element = _wrapper.firstChild;
			_wrapper.parentNode.replaceChild(element, _wrapper);
		}
	}
	return Element.extend(element);
};
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.

// Zero-pads a given number up to a supplied length (defaults to 3)
// and returns the result as a string, e.g. pad(13, 3) = "013".
// Handy for building random guids in fixture data.

var pad = function(x, length) {
	var val = "" + x;
	while (val.length < (length || 3)) {
		val = "0" + val;
	}
	return val;
}

// Returns a random integer between 0 and the supplied limit (returns
// 0 or 1 by default).

var randomInt = function(limit) {
	return Math.floor(Math.random() * (limit || 2));
}
;
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.

CC.WikiEditor.RANDOM_STRING_CACHE = {};

var generateRamdomAlphanumericString = function(len) {
	var result = "";
	var alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
	for (var idx = 0; idx < len; idx++) {
		result += alphabet.charAt(Math.floor(Math.random() * alphabet.length));
	}
	while (CC.WikiEditor.RANDOM_STRING_CACHE[result]) result = generateRamdomAlphanumericString(len);
	CC.WikiEditor.RANDOM_STRING_CACHE[result] = true;
	return result;
};
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.







// Notifications.

CC.WikiEditor.NOTIFICATION_EDITOR_READY = 'EDITOR_READY';
CC.WikiEditor.NOTIFICATION_EDITOR_DID_TOGGLE_DEBUG_MODE = 'EDITOR_DID_TOGGLE_DEBUG_MODE';
CC.WikiEditor.NOTIFICATION_EDITOR_WILL_LOSE_FOCUS = 'EDITOR_WILL_LOSE_FOCUS';
CC.WikiEditor.NOTIFICATION_EDITOR_SHOULD_UPDATE_TOOLBAR = 'EDITOR_SHOULD_UPDATE_TOOLBAR';
CC.WikiEditor.NOTIFICATION_DID_REGISTER_BLOCK_TYPE = 'DID_REGISTER_BLOCK_TYPE';
CC.WikiEditor.NOTIFICATION_DID_UNREGISTER_BLOCK_TYPE = 'DID_UNREGISTER_BLOCK_TYPE';
CC.WikiEditor.NOTIFICATION_PAGE_WAS_INITIALIZED = 'PAGE_WAS_INITIALIZED';
CC.WikiEditor.NOTIFICATION_PAGE_DID_CHANGE = 'PAGE_DID_CHANGE';
CC.WikiEditor.NOTIFICATION_PAGE_DID_MIGRATE = 'PAGE_DID_MIGRATE';
CC.WikiEditor.NOTIFICATION_DID_START_EDITING = 'DID_START_EDITING';
CC.WikiEditor.NOTIFICATION_DID_FINISH_EDITING = 'DID_FINISH_EDITING';
CC.WikiEditor.NOTIFICATION_DID_CANCEL_EDITING = 'DID_CANCEL_EDITING';
CC.WikiEditor.NOTIFICATION_DID_SELECT_ALL = 'DID_SELECT_ALL';
CC.WikiEditor.NOTIFICATION_DID_DESELECT_ALL = 'DID_DESELECT_ALL';
CC.WikiEditor.NOTIFICATION_WILL_SAVE_PAGE = 'WILL_SAVE_PAGE';
CC.WikiEditor.NOTIFICATION_DID_SAVE_PAGE = 'DID_SAVE_PAGE';
CC.WikiEditor.NOTIFICATION_DID_SAVE_PAGE_WITH_GUID = 'DID_SAVE_PAGE_WITH_GUID';
CC.WikiEditor.NOTIFICATION_ERROR_SAVING_PAGE = 'ERROR_SAVING_PAGE';
CC.WikiEditor.NOTIFICATION_DID_SHOW_BLOCK_TOOLBAR = 'DID_SHOW_BLOCK_TOOLBAR';
CC.WikiEditor.NOTIFICATION_DID_HIDE_BLOCK_TOOLBAR = 'DID_HIDE_BLOCK_TOOLBAR';
CC.WikiEditor.NOTIFICATION_DID_RESTORE_OBJECT_FROM_LOCAL_STORAGE = 'DID_RESTORE_OBJECT_FROM_LOCAL_STORAGE';
CC.WikiEditor.NOTIFICATION_BLOCK_CONTENTEDITABLE_DID_FOCUS = 'BLOCK_CONTENTEDITABLE_DID_FOCUS';
CC.WikiEditor.NOTIFICATION_BLOCK_CONTENTEDITABLE_DID_BLUR = 'BLOCK_CONTENTEDITABLE_DID_BLUR';

// Prediction mixin for blocks. Predicts the next block in a container (page or block).

CC.WikiEditor.Mixins.Prediction = {
	// Predict like a duck.
	mSupportsPrediction: true,
	// Predicts and returns a hash of prediction information, including the blockType, and any
	// attributes for the block e.g. {blockType: 'text', attributes: {placeholder: true}}.
	predictNextBlock: function() {}
};

// Comparable mixin for block. Used for sorting.

CC.WikiEditor.Mixins.Comparable = {
	// Compare like a duck.
	mIsComparable: true,
	// Returns a comparable value for this block.
	getComparableValue: function() {}
};

// View mixin that provides confirm to delete behavior.

CC.WikiEditor.Mixins.AskBeforeDeleting = {
	mShouldAskBeforeDeleting: true,
	mDeleteDialogTitle: "Delete",
	mDeleteDialogDescription: "Are you sure you want to delete?",
	handleDeleteButtonClick: function(inEvent) {
		if (inEvent) Event.stop(inEvent);
		// Bail if we're not editing.
		if (!globalEditorController().mEditMode) return true;
		// First draw the dialog, if we need to.
		if ($('block_delete_dialog')) Element.remove('block_delete_dialog');
		dialogManager().drawDialog('block_delete_dialog', [(this.mDeleteDialogDescription || "").loc()], "_Editor.Block.Table.Dialog.Delete.OK".loc(), null, (this.mDeleteDialogTitle || "").loc());
		// Show the delete block dialog.
		dialogManager().show('block_delete_dialog', null, function() {
			globalEditorController().removeBlock(this.mContent);
		}.bind(this), undefined, false, undefined, false);
	}
};

// Abstract block container controller.

CC.WikiEditor.AbstractBlockContainer = Class.create(CC.Mvc.ObjectController, CC.Notifications.Mixins.SupportsOptimizedNotifications, CC.WikiEditor.Mixins.Prediction, {
	// Can this block container actually contain blocks?
	mIsContainer: true,
	// A cache of block controllers keyed by guid.
	mBlocks: null,
	// The parent abstract block container parent for this container.
	mParentContainer: null,
	// All abstract block containers are autosave aware.
	mIsAutosaveAware: true,
	initialize: function($super) {
		$super.apply(null, Array.prototype.slice.call(arguments, 1));
		this.mBlocks = new Hash();
		return this;
	},
	// Notifications optimization.
	getNotificationsIdentifer: function() {
		return this.getRecordPropertyForPath('guid');
	},
	// Adds a new child block to this block container. It is the responsibility of a blocks
	// container to render and position a block once a DID_ADD_BLOCK notification is recieved.
	// The recommended way to do this is to implement handleDidAddBlock in your view.
	addBlock: function(inBlock, inOptPosition, inOptAddQuietly, inOptDoNotTriggerContainerChanges, inOptWorkingElement) {
		if (!inBlock || !CC.kindOf(inBlock, CC.WikiEditor.Block)) return undefined;
		// Update the local mBlocks property for this controller.
		this.mBlocks.set(inBlock.getRecordPropertyForPath('guid'), inBlock);
		// Mark this container as being the container for our new block.
		inBlock.mParentContainer = this;
		// Notify and return.
		this.handleDidAddBlock({'block': inBlock, 'position': inOptPosition, 'quietly': inOptAddQuietly, 'workingElement': inOptWorkingElement});
		if (inOptDoNotTriggerContainerChanges != true) {
			this.handleBlocksDidChange({'added': inBlock, 'quietly': inOptAddQuietly, 'workingElement': inOptWorkingElement});
		}
		return inBlock;
	},
	// Removes a child block from this block container, if it exists.
	removeBlock: function(inBlock, inOptControlledExplosion, inOptRemoveQuietly, inOptDoNotTriggerContainerChanges) {
		if (!inBlock || !CC.kindOf(inBlock, CC.WikiEditor.Block)) return false;
		// First remove the block view in an optional puff of smoke.
		var blockView = inBlock.mViewInstance;
		if (!blockView && !blockView.mParentElement) return true;
		if (inBlock.isExplosive() && !inOptControlledExplosion) smokey().showOverElement(blockView.$());
		var blockViewElement = blockView.$();
		if (blockViewElement && blockViewElement.parentNode) blockViewElement.parentNode.removeChild(blockViewElement);
		// Notify.
		this.handleDidRemoveBlock({'block': inBlock, 'quietly': inOptRemoveQuietly});
		if (inOptDoNotTriggerContainerChanges != true) {
			this.handleBlocksDidChange({'removed': inBlock, 'quietly': inOptRemoveQuietly});
		}
		// Nuke the unwanted controller.
		this.mBlocks.unset(inBlock.getRecordPropertyForPath('guid'));
	},
	// Add/remove block notification callbacks. You should render and position child blocks here.
	handleDidAddBlock: function(inOptInfo) {
		if (inOptInfo.block) inOptInfo.block.handleFinishedAddingBlock();
	},
	handleFinishedAddingBlock: function(inOptInfo) { /* Interface */ },
	handleDidRemoveBlock: function(inOptInfo) {
		if (inOptInfo.block) inOptInfo.block.handleFinishedRemovingBlock();
	},
	handleFinishedRemovingBlock: function(inOptInfo) { /* Interface */ },
	handleBlocksDidChange: function(inOptInfo) {
		if (this.mBlocksDidChangeTimer) clearTimeout(this.mBlocksDidChangeTimer);
		// Update the blockGUIDs property for this container. We defer setting this key to buffer
		// rapid changes, and give any views a chance to render before we query the DOM.
		this.mBlocksDidChangeTimer = setTimeout(function() {
			if (!inOptInfo || (inOptInfo && !inOptInfo.quietly)) {
				var blockGUIDs = this.computeBlockGUIDs();
				this.setRecordPropertyForPath('extendedAttributes.blockGUIDs', blockGUIDs);
			}
		}.bind(this), 100);
	},
	// Returns an (ordered) array of child block GUIDs for this container. Your
	// custom block controller can choose to override this. The default implementation
	// plucks GUIDs from the for attribute of every direct-descendant block view.
	computeBlockGUIDs: function() {
		if (!this.mViewInstance || !this.mViewInstance.$()) return [];
		var _v = this.mViewInstance.$();
		var blockViews = _v.select('.block'), nestedBlockViews = _v.select('.block .block');
		return stringArrayDifference(blockViews.invoke('getAttribute', 'data-guid'), nestedBlockViews.invoke('getAttribute', 'data-guid'));
	},
	// Returns the first or last block in this container. Returns undefined if
	// this container is empty. Your block should implement these methods to
	// support keyboard navigation between block containers.
	firstBlock: function() { /* Interface */ },
	lastBlock: function() { /* Interface */ },
	// Predicts the next block in this container. The default prediction is just
	// a placeholder text block. Accepts an optional previous block (usually the
	// currently active block) that can be used to calculate the prediction.
	// Also accepts an inOptForceEmpty parameter that should override any template
	// or placeholder behavior of the new block.
	predictNextBlock: function(inOptPreviousBlock, inOptIsPlaceholder) {
		var defaultPrediction = {blockType: 'text', attributes: {}};
		if (inOptIsPlaceholder) defaultPrediction.attributes = {content: "_Editor.Block.Text.Placeholder".loc(), placeholder: true};
		var prediction;
		// If we have an block to use as a context, and that block implements the prediction
		// mixin, delegate to that.
		if (inOptPreviousBlock && inOptPreviousBlock.mSupportsPrediction) prediction = inOptPreviousBlock.predictNextBlock(undefined, inOptIsPlaceholder);
		if (!prediction) prediction = defaultPrediction;
		return prediction;
	},
	// Restores an array of changset tuples. Each changeset corresponds to a change to the model
	// object backing your controller. An appropiate implementation of this method will update the
	// state of the view (and controller if needed) and push the changeset into the content store
	// by calling setRecordPropertyForPath on your object controller. We don't automatically push
	// the change back into the store on restore, because the changeset could be tracking transient
	// state you want to know about, but not necessarily persist.
	restore: function(inChangesets) {
		// Remove any child blocks that were removed.
		var changesetKey, changesetValue, changesetIdx, changes;
		for (var changesetIdx = 0; changesetIdx < inChangesets.length; changesetIdx++) {
			changes = inChangesets[changesetIdx];
			if (changes.length < 2) return;
			changesetKey = changes[0];
			changesetValue = changes[1];
			if (changesetKey == 'extendedAttributes') {
				var currentBlockGUIDs = this.getRecordPropertyForPath('extendedAttributes.blockGUIDs');
				var blockGUIDs = changesetValue['blockGUIDs'];
				if (!blockGUIDs || blockGUIDs.length == 0) continue;
				// Calculate a set difference between existing blocks on the page, and those in
				// the changeset we're restoring. Any blocks that are in the existing set, but not
				// in the new set are deleted.
				var difference = stringArrayDifference(currentBlockGUIDs, blockGUIDs), differenceIdx, guid;
				for (var differenceIdx = 0; differenceIdx < difference.length; differenceIdx++) {
					guid = difference[differenceIdx];
					if (currentBlockGUIDs.include(guid)) {
						this.removeBlock(this.mBlocks.get(guid), true, false, true);
					}
				}
			}
			this.setRecordPropertyForPath(changesetKey, changesetValue);
		}
		globalNotificationCenter().publish(CC.WikiEditor.NOTIFICATION_DID_RESTORE_OBJECT_FROM_LOCAL_STORAGE, this, {
			'changesets': inChangesets,
			'object': this
		});
	}
});

// Simple page controller.

CC.WikiEditor.Page = Class.create(CC.WikiEditor.AbstractBlockContainer, {
	mIsContainer: true,
	firstBlock: function() {
		var blockGUIDs = this.computeBlockGUIDs();
		return this.mBlocks.get(blockGUIDs.first());
	},
	lastBlock: function() {
		var blockGUIDs = this.computeBlockGUIDs();
		return this.mBlocks.get(blockGUIDs.last());
	},
	// Autosave support.
	restore: function($super, inChangesets) {
		var changesetKey, changesetValue, changesetIdx, changes;
		for (changesetIdx = 0; changesetIdx < inChangesets.length; changesetIdx++) {
			changes = inChangesets[changesetIdx];
			if (changes.length < 2) continue;
			changesetKey = changes[0];
			changesetValue = changes[1];
			// Restore page titles and child block ordering.
			if (changesetKey == 'longName') {
				this.setRecordPropertyForPath('longName', changesetValue);
			} else if (changesetKey == 'extendedAttributes') {
				if (changesetValue['blockGUIDs'] && (changesetValue['blockGUIDs'] != this.getRecordPropertyForPath('extendedAttributes.blockGUIDs'))) {
					var blockGUIDs = changesetValue['blockGUIDs'];
					var blockElements = this.mViewInstance.$().up().select('.page.blocks > .block');
					var removedBlocks = {}, removedBlock;
					// Remove and stash any block elements we've already rendered.
					for (var blockElementIdx = 0; blockElementIdx < blockElements.length; blockElementIdx++) {
						removedBlock = Element.remove(blockElements[blockElementIdx]);
						removedBlocks[removedBlock.getAttribute('data-guid')] = removedBlock;
					}
					// Restore the block elements in order.
					for (var blockGUIDIdx = 0; blockGUIDIdx < blockGUIDs.length; blockGUIDIdx++) {
						removedBlock = removedBlocks[blockGUIDs[blockGUIDIdx]];
						if (removedBlock) this.mViewInstance.$().appendChild(removedBlock);
					}
				}
			}
		}
		$super(inChangesets);
	},
	handleDidAddBlock: function($super, inOptInfo) {
		if (inOptInfo && inOptInfo.block) {
			var position = (inOptInfo.position || {'bottom': (inOptInfo.workingElement || this.mViewInstance.$())});
			blockRenderingDelegate().renderAndInsertBlockAtPosition(inOptInfo.block, position);
		}
		$super.apply(null, Array.prototype.slice.call(arguments, 1));
	}
});

// Block controller shuttling info between a CC.WikiEditor.BlockView instance and
// a CC.WikiEditor.BlockModel model.

CC.WikiEditor.Block = Class.create(CC.WikiEditor.AbstractBlockContainer, {
	mBlockView: 'CC.WikiEditor.BlockView',
	// Is this block currently being edited?
	mCurrentlyEditing: false,
	// Is this block a container block (e.g. a table).
	mIsContainer: false,
	// Returns a boolean if this block is empty. Your subclass should implement this in a way 
	// that is compatible with your custom block structure.
	isEmpty: function() {
		return false;
	},
	// Returns true if this block should be treated as a template/placeholder.
	isPlaceholder: function() {
		return this.getRecordPropertyForPath('extendedAttributes.placeholder');
	},
	// Returns a boolean if this block should be removed with an explosion.
	isExplosive: function() {
		return true;
	},
	isEditable: function() {
		return (globalEditorController().mEditMode || false);
	},
	isLocked: function() {
		return false;
	},
	// Called when this block becomes active.
	handleDidStartEditing: function(inOptInfo) {
		this.mCurrentlyEditing = true;
		this.mViewInstance.mParentElement.addClassName('editing');
		this.mViewInstance.becomeFirstResponder();
	},
	// Called when this block gets reactivated.
	handleDidResumeEditing: function(inOptInfo) {},
	// Called when this block is deactivated.
	handleDidStopEditing: function(inOptInfo) {
		if (!this.mCurrentlyEditing) return true;
		this.mCurrentlyEditing = false;
		this.mViewInstance.mParentElement.removeClassName('editing');
		this.mViewInstance.loseFirstResponder();
	}
});

// Editor toolbar mixin. If your block needs to enable or disable menu options
// depending on settings on your block, or selection within your block, you should
// implement this mixin.

CC.WikiEditor.Mixins.Toolbar = {
	// Returns a hash of properties for a set of toolbar keys for this block.
	// The result is a hash keyed by toolbar key. Each value is expected to have
	// a selected and enabled boolean flag that is determined from the state of
	// your block. When a toolbar key is selected, it is expected that that option
	// is applied to your block, and when it is disabled, it is expected that that
	// toolbar option is no longer applicable to your block.
	toolbarSettingsForKeys: function(inToolbarKeys) {
		var result = new Hash(), toolbarKeysIdx, key;
		for (toolbarKeysIdx = 0; toolbarKeysIdx < inToolbarKeys.length; toolbarKeysIdx++) {
			key = inToolbarKeys[toolbarKeysIdx];
			result.set(key, {
				'enabled': true,
				'selected': false
			});
		}
		return result;
	}
};

// Block navigation delegate mixin. If your block needs to support complex keyboard
// navigation, you should implement this in your view class. Key events captured by
// the editor will be converted into calls to your receiver if it includes this mixin.

CC.WikiEditor.NOTIFICATION_BLOCK_DID_MOVE_TO_START = 'BLOCK_DID_MOVE_TO_START';
CC.WikiEditor.NOTIFICATION_BLOCK_DID_MOVE_TO_END = 'NOTIFICATION_BLOCK_DID_MOVE_TO_END';
CC.WikiEditor.NOTIFICATION_BLOCK_DID_MOVE_RIGHT = 'NOTIFICATION_BLOCK_DID_MOVE_RIGHT';
CC.WikiEditor.NOTIFICATION_BLOCK_DID_MOVE_LEFT = 'NOTIFICATION_BLOCK_DID_MOVE_LEFT';
CC.WikiEditor.NOTIFICATION_BLOCK_DID_MOVE_UP = 'NOTIFICATION_BLOCK_DID_MOVE_UP';
CC.WikiEditor.NOTIFICATION_BLOCK_DID_MOVE_DOWN = 'NOTIFICATION_BLOCK_DID_MOVE_DOWN';

CC.WikiEditor.Mixins.Navigation = {
	// Navigate like a duck.
	mSupportsNavigation: true,
	moveToStart: function() {
		globalNotificationCenter().publish(CC.WikiEditor.NOTIFICATION_BLOCK_DID_MOVE_TO_START, this);
	},
	moveToEnd: function() {
		globalNotificationCenter().publish(CC.WikiEditor.NOTIFICATION_BLOCK_DID_MOVE_TO_END, this);
	},
	moveRight: function() {
		globalNotificationCenter().publish(CC.WikiEditor.NOTIFICATION_BLOCK_DID_MOVE_RIGHT, this);
	},
	moveLeft: function() {
		globalNotificationCenter().publish(CC.WikiEditor.NOTIFICATION_BLOCK_DID_MOVE_LEFT, this);
	},
	moveUp: function() {
		globalNotificationCenter().publish(CC.WikiEditor.NOTIFICATION_BLOCK_DID_MOVE_UP, this);
	},
	moveDown: function() {
		globalNotificationCenter().publish(CC.WikiEditor.NOTIFICATION_BLOCK_DID_MOVE_DOWN, this);
	},
	focusedAtStart: function() {},
	focusedAtEnd: function() {}
};

// Base view class for any block container.

CC.WikiEditor.AbstractBlockContainerView = Class.create(CC.Mvc.View, {
	// TODO
});

// Standard view for a page.

CC.WikiEditor.PageView = Class.create(CC.WikiEditor.AbstractBlockContainerView, {
	mEditing: false,
	registerEventHandlers: function() {
		globalNotificationCenter().subscribe(CC.WikiEditor.NOTIFICATION_PAGE_DID_CHANGE, this.handlePageDidChange.bind(this));
	},
	render: function() {
		var elem = Builder.node('div', {className: 'page blocks selectable wrapchrome'});
		var pageGUID = this.mContent.getRecordPropertyForPath('guid');
		if (pageGUID) elem.setAttribute('data-guid', pageGUID);
		var pageTinyID = this.mContent.getRecordPropertyForPath('tinyID');
		if (pageTinyID) elem.setAttribute('data-tiny-id', pageTinyID);
		var ownerGUID = this.mContent.getRecordPropertyForPath('ownerGUID');
		if (ownerGUID) elem.setAttribute('data-owner-guid', ownerGUID);
		return elem;
	},
	handlePageDidChange: function(inMessage, inObject, inOptExtras) {
		if (inObject) {
			var isMigrated = inObject.getRecordPropertyForPath('extendedAttributes.migrated');
			if (isMigrated) {
				this.$().addClassName('migrated');
			} else {
				this.$().removeClassName('migrated');
			}
		}
	}
});

// Standard view for a block.

CC.WikiEditor.BlockView = Class.create(CC.WikiEditor.AbstractBlockContainerView, CC.WikiEditor.Mixins.Toolbar, CC.Notifications.Mixins.SupportsOptimizedNotifications, {
	isEditable: function() { return this.mContent.isEditable(); },
	isLocked: function() { return this.mContent.isLocked(); },
	// Returns a unique identifer for this block view that can be used for delegate event registration.
	// You can use this identifer as a prefix for sub-elements of your view that use delegate-based
	// events, but you should not normally need to override this implementation.
	mCachedEventDelegateIdentifer: null,
	mCachedBlockGUID: null,
	mCachedBlockType: null,
	getEventDelegateIdentifer: function(inOptForceRecalcuate) {
		if (!inOptForceRecalcuate && this.mCachedEventDelegateIdentifer) return this.mCachedEventDelegateIdentifer;
		if (inOptForceRecalcuate || !this.mCachedBlockGUID) this.mCachedBlockGUID = this.mContent.getRecordPropertyForPath('guid');
		if (inOptForceRecalcuate || !this.mCachedBlockType) this.mCachedBlockType = this.mContent.getRecordPropertyForPath('blockType');
		return (this.mCachedEventDelegateIdentifer = "%@-block-view-%@".fmt(this.mCachedBlockType, this.mCachedBlockGUID));
	},
	// Notifications optimization for this view.
	getNotificationsIdentifer: function() {
		return this.getEventDelegateIdentifer();
	},
	// Internal renderAsHTML function wrapping a block view in required editor chrome.
	// You should not override or call this function directly.
	_renderAsHTML: function() {
		var blockGUID = this.mContent.mRecord.guid, blockType = this.mContent.mRecord.blockType;
		var extraClassNames = this.mContent.getRecordPropertyForPath('extendedAttributes.extraClassNames');
		extraClassNames = (extraClassNames ? (" " + extraClassNames) : "");
		var eventDelegateIdentifer = this.getEventDelegateIdentifer();
		var blockHTML = "<div id=\"%@\" class=\"block wrapchrome %@ %@%@\" data-guid=\"%@\" data-type=\"%@\" contentEditable=\"false\">".fmt(this.getEventDelegateIdentifer(), blockType, blockGUID, extraClassNames, blockGUID, blockType) +
			"<div id=\"" + eventDelegateIdentifer + "-wrapper\" class=\"wrapper wrapchrome\"><div id=\"" + eventDelegateIdentifer + "-inner\" class=\"inner wrapchrome\"><div id=\""+
			eventDelegateIdentifer + "-inner-delete\" class=\"delete clickable chrome\">" + "_Editor.Delete.Block".loc() + "</div><div class=\"lock chrome\"><div class=\"lockedby\"></div></div>" +
			"<a id=\"" + eventDelegateIdentifer + "-inner-debug\" class=\"debug chrome\" title=\"" + blockGUID + "\">" + "_Editor.Block.Debug".loc() + "</a><div class=\"content selectable wrapchrome\">" +
			(this.renderAsHTML() || "") + "</div></div></div></div>";
		return [blockGUID, blockHTML];
	},
	renderAsHTML: function() { /* Interface */ },
	_registerEventHandlers: function() {
		bindEventListeners(this, [
			'handleParentElementClick',
			'handleParentElementMouseDown',
			'handleDeleteButtonClick'
		]);
		var eventDelegateIdentifer = this.getEventDelegateIdentifer();
		globalEventDelegate().bulkRegisterDomResponderForEventByIdentifer([
			['click', eventDelegateIdentifer + "-wrapper", this.handleParentElementClick],
			['mousedown', eventDelegateIdentifer + "-wrapper", this.handleParentElementMouseDown],
			['click', eventDelegateIdentifer + "-inner-delete", this.handleDeleteButtonClick]
		]);
		this.registerEventHandlers();
	},
	handleParentElementClick: function(inEvent) {
		if (!this.isEditable()) return true;
		Event.stop(inEvent);
		globalEditorController().startEditing(this.mContent, {focus: false});
	},
	handleDeleteButtonClick: function(inEvent) {
		Event.stop(inEvent);
		globalEditorController().removeBlock(this.mContent);
	},
	handleParentElementMouseDown: function(inEvent) { /* Interface */ }
});

// Block rendering delegate. Responsible for rendering and placing a block at a specific location
// on the page, either at the top-level or inside a container. Supports Prototype notation for
// element positioning, e.g. {'after': element}, but uses contentEditable insertHTML commands to
// ensure page changes are included in the browser undo/redo stack.

CC.WikiEditor.BlockRenderingDelegate = Class.createWithSharedInstance('blockRenderingDelegate');
CC.WikiEditor.BlockRenderingDelegate.prototype = {
	mTemporaryRenderingMarkerClassName: 'wikieditor-temporary-rendering-marker',
	initialize: function() {},
	// Renders a block to an HTML fragment inserting and replacing the current document selection.
	// Returns the newly added element where the block was successfully added, and false otherwise.
	renderAndInsertBlock: function(inBlock) {
		return this._renderAndInsertBlock(inBlock, undefined, true);
	},
	// Renders a block to an HTML fragment inserting it at a given position.
	renderAndInsertBlockAtPosition: function(inBlock, inPosition) {
		return this._renderAndInsertBlock(inBlock, inPosition, false);
	},
	// Internal block rendering method. Do not call yourself.
	_renderAndInsertBlock: function(inBlock, inOptPosition, inOptUseContentEditableMethods) {
		if (!inBlock || !CC.kindOf(inBlock, CC.WikiEditor.Block) || !inBlock.mViewInstance) {
			logger().error("Cannot append an invalid block or a block with no view instance (%o)", inBlock);
			return undefined;
		}
		if (!inOptPosition && !inOptUseContentEditableMethods) {
			logger().error("Cannot append a block to an unknown position or without an active selection");
			return undefined;
		}
		// Render the fragment.
		var result = inBlock.mViewInstance._renderAsHTML(), identifer, markup, elements, element;
		identifer = result[0], markup = result[1];
		logger().debug("blockRenderingDelegate markup: %@", markup);
		if (inOptUseContentEditableMethods) {
			var range = globalEditorTextSelectionDelegate().getSelectionAsRange();
			if (!range) {
				logger().debug("Could not append rendered block because there is no selection");
				return undefined;
			}
			if (browser().isIE()) {
				var range = globalEditorTextSelectionDelegate().getSelectionAsRange();
				if (!range) {
					logger().debug("Could not append rendered block because there is no selection");
					return undefined;
				}
				range.pasteHTML(markup);
			}
			else {
				if (!document.queryCommandEnabled('inserthtml')) {
					logger().debug("Could not append rendered block because queryCommandEnabled returned false for insertHTML");
					return undefined;
				}
				// Insert the rendered view.
				document.execCommand('inserthtml', false, markup);
			}
		} else {
			var position, positionKey, positionValue, position;
			// Determine the position and the container.
			positionHash = $H(inOptPosition);
			positionKey = positionHash.keys().first();
			if (!positionKey || !positionHash.get(positionKey)) {
				logger().error("Invalid position specified when adding block (%o)", inOptPosition);
				return undefined;
			}
			positionValue = positionHash.get(positionKey);
			// Support passing a block, a view or an anchoring DOM element.
			if (CC.kindOf(positionValue, CC.WikiEditor.Block)) positionValue = positionValue.mViewInstance.$();
			if (CC.kindOf(positionValue, CC.Mvc.View)) positionValue = positionValue.$();
			// Append the rendered block directly to the document using an insertion.
			position = {};
			position[positionKey] = markup;
			element = fragmentSafeElementInsert(positionValue, position)
		}
		// Query and return the newly added DOM node.
		if (!element) {
			elements = document.getElementsByClassName(identifer);
			if (elements && elements.length > 0) element = $(elements.item(0));
			if (!element) return undefined;
		}
		// Enforce contentEditable on the root element.
		element.setAttribute('contentEditable', false);
		// Remove the temporary class name before proceeding.
		element.removeClassName(identifer);
		// Manually fire a rendered notification.
		inBlock.mViewInstance.handleDidRenderView({'element': element});
		// Return the newly added view element.
		return element;
	}
};

// Workaround for 9272663
// An abstract view class for non-text-block views.
 
CC.WikiEditor.NonTextBlockView = Class.create(CC.WikiEditor.BlockView, {
	handleParentElementMouseDown: function(inEvent) {
		if (this.mCachedBlockType == 'text' || this.mCachedBlockType == 'sandbox') return;
		var closestParentBlockElement = this.$().up('.block');
		if (!closestParentBlockElement || (closestParentBlockElement.getAttribute('data-type') != 'text')) return;
		// Did the event originate exactly on a .wrapper element.
		var source = Event.element(inEvent);
		if (!source.hasClassName('.wrapper')) return;
		// 9272663
		// Stop the event since we'll simulate a result.
		Event.stop(inEvent);
		// If this block is a non-text block, and we get a mousedown event on the block wrapper
		// element, we need to simulate a cursor. Divide the receiving .wrapper element into three
		// regions; the whitespace on the left side of the block (minus any bottom padding on the
		// content), the whitespace on the right side of the block (minus any bottom padding on the
		// content) and the strip of padding along the bottom of the block (if it exists). Calculate
		// which region the mouse event originated in.
		var wrapper = this.$('.wrapper');
		var pointerX = inEvent.pointerX();
		var pointerY = inEvent.pointerY();
		var position = Element.cumulativeOffset(wrapper);
		position.top = (position.top - wrapper.up('#main').scrollTop);
		var wrapperLayout = Element.getLayout(wrapper);
		var bounds = {
			xMin: position.left,
			xMax: position.left + wrapperLayout.get('padding-box-width'),
			yMin: position.top,
			yMax: position.top + wrapperLayout.get('padding-box-height')
		};
		// The mid-point is the mid point of the inner block content, or the right bound of
		// block view content (whichever is smaller and leftmost).
		var inner = wrapper.down('.inner');
		var innerLayout = Element.getLayout(inner);
		var midPoint = Math.min((bounds.xMax - bounds.xMin) / 2, (innerLayout.get('left') + (innerLayout.get('width') / 2)));
		var bottom = ((pointerX >= bounds.xMin && pointerX <= bounds.xMax) && (pointerY >= (bounds.yMax - wrapperLayout.get('padding-bottom')) && pointerY <= bounds.yMax));
		var left = ((pointerX >= bounds.xMin && pointerX <= (bounds.xMin + midPoint)) && (pointerY >= bounds.yMin && pointerY <= bounds.yMax));
		var right = ((pointerX >= (bounds.xMin + midPoint) && pointerX <= bounds.xMax) && (pointerY >= bounds.yMin && pointerY <= bounds.yMax));
		// Select the previous block if we detected a click in the content left padding, otherwise
		// select the next block.
		var before, after, moveToStart, moveToEnd;
		before = moveToEnd = (left && !bottom);
		after = moveToStart = !before;
		// Position the cursor before or after this block view.
		var wrapperSpan = Element.wrap(this.$(), 'div');
		wrapperSpan.focus();
		if (before) {
			globalEditorTextSelectionDelegate().moveCursorToStart(wrapperSpan);
		} else {
			globalEditorTextSelectionDelegate().moveCursorToEnd(wrapperSpan);
		}
		logger().debug("handleParentElementMouseDown (before? %o after? %o moveToStart? %o moveToEnd? %o)", before, after, moveToStart, moveToEnd);
		return true;
	}
});

// Editor or contextual toolbar entry for a block.

CC.WikiEditor.EDITOR_TOOLBAR_ITEM_STYLE_POPUP = 'popup';
CC.WikiEditor.EDITOR_TOOLBAR_ITEM_STYLE_SELECT = 'select';
CC.WikiEditor.EDITOR_TOOLBAR_ITEM_STYLE_SEGMENTED = 'segmented';

CC.WikiEditor.EditorToolbarItem = Class.create(CC.Object, {
	// Identifier for this toolbar item.
	mKey: null,
	// Display title and tooltip for this item.
	mDisplayTitle: null,
	mTooltip: null,
	// Is this toolbar item enabled?
	mIsEnabled: true,
	// Is this toolbar action a block-level operation (e.g. alignment)?
	mBlockLevelOperation: false,
	// An array of editor toolbar sub-items.
	mSubMenuItems: [],
	// The style of this toolbar item.
	mToolbarStyle: null,
	// Action to trigger when this menu item is selected, and
	// the target that will handle it.
	mAction: null,
	mTarget: null
});

// Toolbar instance representing contextual toolbar entry for a particular block.
// Each toolbar manages one or more EditorToolbarItem instances.

CC.WikiEditor.BlockToolbar = Class.create(CC.Object, {
	mToolbarItems: []
});

// Editor toolbar delegate. Responsible for marshaling requests between the editor
// toolbar and the global editor instance (mostly adding new blocks).

CC.WikiEditor.EditorToolbarDelegate = Class.createWithSharedInstance('editorToolbarDelegate');
CC.WikiEditor.EditorToolbarDelegate.prototype = {
	initialize: function() {},
	addBlock: function(/* [arguments] */) {
		// If the editor is tracking a selection, remove it
		if (globalEditorController().mSelecting) globalEditorController()._removeExistingSelection();
		// If we're editing a block, stash it away.
		var previouslyActiveBlock = globalEditorController().mActiveBlock;
		// Add a new block of type inBlockType.
		var newBlock = globalEditorController().addBlock.apply(globalEditorController(), arguments);
		// Return the newly added block.
		return newBlock;
	}
};

// Inline toolbar view used for the add block toolbar, and contextual toolbars for
// content block and container blocks. Expects an mContent object before rendering,
// and that mContentObject should have an mToolbarItems array of editor toolbar item
// instances (CC.WikiEditor.EditorToolbarItem).

CC.WikiEditor.EditorInlineToolbarView = Class.create(CC.Mvc.View, {
	// The target for actions of this toolbar. This property is considered
	// to be bound to the currently active block. The editor is responsible
	// for updating this property depending on the currently focused block.
	mBlockTarget: null,
	// Automagically renders a toolbar view.
	render: function() {
		if (!this.mContent || !this.mContent.mToolbarItems || this.mContent.mToolbarItems.length == 0) return Builder.node('span', {className: 'chrome'}, "_Editor.Toolbar.Empty.Placeholder".loc());
		// Transforms an array of menu items into a <ul> tag.
		var $ul = function(inItems, inOptParentItem, inOptBlockIdentifer, inOptIsTopLevel) {
			var classNames = ['items'];
			if (inOptBlockIdentifer) classNames.push('%@block'.fmt(inOptBlockIdentifer));
			if (inOptIsTopLevel) classNames.push('chrome');
			var ul = Builder.node('ul', {className: classNames.join(' ')});
			for (var i = 0; i < inItems.length; i++) {
				ul.appendChild($li(inItems[i], inOptIsTopLevel, inOptParentItem));
			}
			return ul;
		}.bind(this);
		// Transforms an individual menu item into a single <li> tag, or an <li> tag
		// with a nested <ul> tag inside. Recursively builds a menu.
		var $li = function(inItem, inOptIsTopLevel, inOptParent) {
			var attributes = {};
			if (inItem.mTooltip) attributes.title = inItem.mTooltip;
			var classNames = ['item'];
			if (inOptIsTopLevel) classNames.push('toplevel');
			if (inItem.mKey) {
				attributes.name = inItem.mKey;
				classNames.push(inItem.mKey);
			}
			if (inItem.mEnabled !== undefined && !inItem.mEnabled) classNames.push('disabled');
			if (inItem.mToolbarStyle) classNames.push('styled', inItem.mToolbarStyle);
			attributes.className = classNames.join(' ');
			var li = Builder.node('li', attributes, [
				Builder.node('span', inItem.mDisplayTitle)
			]);
			// Configure any event handlers on this menu item.
			var inheritedAction = inOptParent ? inOptParent.mAction : undefined;
			var inheritedTarget = inOptParent ? inOptParent.mTarget : undefined
			$evt(inItem, li, inheritedAction, inheritedTarget);
			// Recurse and expand any children.
			var children = inItem.mSubMenuItems;
			if (children && children.length > 0) li.appendChild($ul(children, inItem));
			return li;
		}.bind(this);
		// Registers events on an individual toolbar <li> tag.
		var $evt = function(inToolbarItem, inElement, inOptInheritedAction, inOptInheritedTarget) {
			if (!inToolbarItem || !inElement) return false;
			var mAction = inToolbarItem.mAction || inOptInheritedAction;
			var mTarget = inToolbarItem.mTarget || inOptInheritedTarget;
			if (inToolbarItem.mSubMenuItems && inToolbarItem.mSubMenuItems.length > 0) {
				Event.observe(inElement, 'mousedown', function(inEvent) {
					Event.stop(inEvent);
					if (inEvent.findElement('.disabled')) return true;
					globalNotificationCenter().publish(CC.WikiEditor.NOTIFICATION_EDITOR_WILL_LOSE_FOCUS);
					setTimeout(function() {
						var toolbars = $$('.editor.toolbar .expanded, .editor.inline.popup.expanded'), toolbarIdx, toolbar;
						for (toolbarIdx = 0; toolbarIdx < toolbars.length; toolbarIdx++) {
							toolbar = toolbars[toolbarIdx];
							toolbar.removeClassName('expanded');
							if (toolbar.hasClassName('inline') && toolbar.hasClassName('popup')) toolbar.hide();
						}
						var parent = inEvent.findElement('.toplevel');
						if (parent) parent.toggleClassName('expanded');
					}, 200);
				});
			}
			else if (mAction) {
				Event.observe(inElement, 'mousedown', function(inEvent) {
					Event.stop(inEvent);
					if (inEvent.findElement('.disabled')) return true;
					globalNotificationCenter().publish(CC.WikiEditor.NOTIFICATION_EDITOR_WILL_LOSE_FOCUS);
					setTimeout(function() {
						var toolbars = $$('.editor.toolbar .expanded, .editor.inline.popup.expanded'), toolbarIdx, toolbar;
						for (toolbarIdx = 0; toolbarIdx < toolbars.length; toolbarIdx++) {
							toolbar = toolbars[toolbarIdx];
							toolbar.removeClassName('expanded');
							if (toolbar.hasClassName('inline') && toolbar.hasClassName('popup')) toolbar.hide();
						}
						// Build a list of arguments.
						var args = inToolbarItem.mActionArguments || [inToolbarItem.mKey, inEvent];
						if (args && CC.typeOf(args) != CC.T_ARRAY) throw("Cannot initialize toolbar item (%@) with unknown argument list (%@)".fmt(inToolbarItem, args));
						// Get the target for this callback (if it exists). Default to the block
						// controller if it exists, otherwise the global editor controller.
						var target = mTarget || this.mBlockTarget || editorToolbarDelegate();
						// Call the action passing along any arguments.
						if (target && target[mAction]) return target[mAction].apply(target, args);
						// Fall back on the global editor controller for a bad or unspecified target.
						var editor = globalEditorController();
						if (editor[mAction]) return editor[mAction].apply(editor, args);
					}.bind(this), 200);
				}.bind(this));
			}
		}.bind(this);
		// Render the menu. Flag the first render as being top-level so we can add any
		// special sauce for hiding/showing the menu and activating/deactivating
		// the menu based on the active block in the editor. The true flag won't get
		// passed on recursive render calls.
		var menu = $ul(this.mContent.mToolbarItems, null, this.mContent.mBlockTypeIdentifer, true);
		return menu;
	},
	registerEventHandlers: function() {
		Event.observe(this.mParentElement, 'mousedown', function(inEvent) {
			inEvent.stopPropagation();
			Event.stop(inEvent);
		});
	},
	// Returns an array of toolbar keys.
	keys: function() {
		var keys = $A([]), elem = this.$();
		if (!elem) return keys;
		keys = elem.select('li.item').collect(function(item) {
			return item ? item.getAttribute('name') : undefined;
		});
		return keys.compact();
	},
	// Updates the state of this toolbar using the supplied properties hash.
	updateToolbarUsingPropertiesForKeys: function(inPropertiesByKey) {
		if (!inPropertiesByKey) return;
		var renderedToolbar = this.$();
		var toolbarItems = this.$().select('li.item');
		var key, attrs, itemIdx, item;
		for (itemIdx = 0; itemIdx < toolbarItems.length; itemIdx++) {
			item = toolbarItems[itemIdx];
			// What toolbar key is this list item representing?
			key = item.getAttribute('name');
			// Look up the properties for this menu key.
			attrs = inPropertiesByKey.get(key);
			if (!attrs || (attrs && !(attrs.enabled || attrs.selected))) continue;
			// Update the enabled and selected state of this toolbar item.
			if (attrs.enabled !== undefined) attrs.enabled ? item.removeClassName('disabled') : item.addClassName('disabled');
			if (attrs.selected !== undefined) attrs.selected ? item.addClassName('selected') : item.removeClassName('selected');
		}
		return true;
	}
});

// Fake editor toolbar item popup menu designed to mimic static toolbar popup menus (e.g. text
// formatting or list styling), but support dynamically generated content. It is your responsibility
// to instantiate and render a popup menu. The suggested way to do so is have a delegate shared
// instance that your editor toolbar item calls, which handles populating/hiding/showing your popup.

CC.WikiEditor.EditorToolbarPopupMenu = Class.create(CC.Mvc.View, {
	mShowing: false,
	mIdentifer: null,
	mTopPosition: 71, // Set top position as static. ref: radar 14099101 - Top half of link tool menu items are not displayed on iPad.
	_render: function() {
		var elem = Builder.node('div', {className: 'editor inline popup chrome', style: 'display: none;'});
		if (this.mIdentifer) elem.setAttribute('id', this.mIdentifer);
		var rendered = this.render();
		if (rendered) elem.appendChild(rendered);
		this.handleDidRenderView({'element': elem});
		return (this.mParentElement = elem);
	},
	registerEventHandlers: function() {
		bindEventListeners(this, [
			'handleParentElementMouseDown',
			'handleWindowMouseDown'
		]);
		Event.observe(this.mParentElement, 'mousedown', this.handleParentElementMouseDown);
	},
	// Show/hide this popup. Accepts an optional anchor element to center this popup
	// over when showing.
	show: function(inOptAnchorElement) {
		// Do we have an anchor?
		this.mAnchorElement = inOptAnchorElement ? $(inOptAnchorElement) : undefined;
		var position = this.mAnchorElement ? this.mAnchorElement.viewportOffset() : {top: 0, left: 0};
		this.$().setStyle({
			'top': this.mTopPosition + 'px',
			'left': position.left + 'px'
		});
		this.$().show();
		this.mShowing = true;
		this.$().addClassName('expanded');
		// Watch for something equivilant to a popup blur.
		Event.observe(window, 'mousedown', this.handleWindowMouseDown);
	},
	hide: function(inEvent, inOptCallback) {
		this.$().hide();
		this.$().removeClassName('expanded');
		this.mShowing = false;
		// Clean up unwanted event handlers.
		Event.stopObserving(window, 'mousedown', this.handleWindowMouseDown);
	},
	toggle: function(inOptAnchorElement) {
		(this.mShowing == false) ? this.show(inOptAnchorElement) : this.hide();
	},
	// If the mouse event came from the popup, stop propagation so we don't
	// unintentially hide it (the editor will interpret it as a toolbar hide).
	handleParentElementMouseDown: function(inEvent) {
		Event.stop(inEvent);
		return true;
	},
	// If the mouse event came from the anchor, and we're showing, hide the
	// popup instead of showing.
	handleWindowMouseDown: function(inEvent) {
		var popup = inEvent.findElement('.editor.popup');
		if (popup && this.mAnchorElement && popup == this.mAnchorElement) {
			this.handleParentElementMouseDown(inEvent);
			this.toggle(this.mAnchorElement);
		} else {
			this.hide();
		}
	},
	// Prepares your popup for display. You can use this method to safely pass
	// page state to your popup instance (e.g. any current selection context). For
	// example, in the link popup, we pass whether or not the current selection
	// has an active hyperlink (so we know whether we need to include unlink), and
	// the current selection so we can pre-populate the link text/url fields in the
	// manual link dialog.
	preparePopup: function() {}
});

// Copy/paste delegate. Works by adding an offscreen editable element to the document
// that can be staged with a focused set of content ready to be placed on the clipboard,
// or ready to recieve a paste event.

CC.WikiEditor.NOTIFICATION_DID_INITIALIZE_COPY_PASTE_DELEGATE = 'DID_INITIALIZE_COPY_PASTE_DELEGATE';
CC.WikiEditor.NOTIFICATION_CLIPBOARD_DID_CHANGE = 'CLIPBOARD_DID_CHANGE'

CC.WikiEditor.CopyPasteDelegate = Class.create({
	initialize: function(inOptMarkup) {
		this.mOffscreenElement = Builder.node('div', {className: 'wikieditor-offscreen chrome'});
		this.mOffscreenElement.innerHTML = (inOptMarkup || "");
		document.body.appendChild(this.mOffscreenElement);
		Event.observe(this.mOffscreenElement, 'blur', this.handleOffscreenElementBlur.bind(this));
		globalNotificationCenter().publish(CC.WikiEditor.NOTIFICATION_DID_INITIALIZE_COPY_PASTE_DELEGATE, this);
	},
	prepareToCopy: function(inMarkup) {
		this.mOffscreenElement.innerHTML = (inMarkup || "");
		this.focusOffscreenElement();
		this.handleOffscreenElementBlur();
	},
	prepareToPaste: function() {
		this.mOffscreenElement.innerHTML = "";
		this.mOffscreenElement.addClassName('selectable');
		this.mOffscreenElement.setAttribute('contentEditable', true);
		this.focusOffscreenElement();
	},
	clipboard: function(inOptTextOnly) {
		// If we're returning a text-only representation of the clipboard (including links and
		// inline styles), clone the offscreen element and tidy the DOM before returning.
		if (inOptTextOnly) {
			var clonedNode = this.mOffscreenElement.cloneNode(true);
			return reduceToTextLinksAndStyles(clonedNode).innerHTML;
		}
		return this.mOffscreenElement.innerHTML;
	},
	focusOffscreenElement: function() {
		this.mOffscreenElement.focus();
		globalEditorTextSelectionDelegate().selectAllChildren(this.mOffscreenElement);
	},
	handleOffscreenElementBlur: function(inEvent) {
		globalNotificationCenter().publish(CC.WikiEditor.NOTIFICATION_CLIPBOARD_DID_CHANGE, this, {
			'content': this.mOffscreenElement.innerHTML
		});
		this.mOffscreenElement.removeClassName('selectable');
		this.mOffscreenElement.setAttribute('contentEditable', false);
	}
});

// Editor selection delegate. Responsible for cleanup tasks before and after we process
// a select-all operation. Since we use a series of nested contentEditable containers for
// text editing, select-all needs to escape an actively focused contentEditable space by
// stashing the current selection, disabling contentEditable everywhere temporarily and
// allowing the select-all to process as expected.

CC.WikiEditor.SelectAllDelegate = Class.create({
	mIsSelectingAll: false,
	mStashedActiveBlock: null,
	mStashedEditables: null,
	initialize: function() {},
	prepareToSelectAll: function() {
		// First cache the window selection if it exists.
		globalEditorTextSelectionDelegate().cacheSelection();;
		// Stash the currently active block.
		this.mStashedActiveBlock = globalEditorController().mActiveBlock;
		if (this.mStashedActiveBlock) globalEditorController().stopEditing(true);
		// Next undo and stash any contentEditable elements.
		var editables = $(document.body).select("*[contentEditable=true]"), editableIdx, editable;
		for (editableIdx = 0; editableIdx < editables.length; editableIdx++) {
			editable = editables[editableIdx];
			editable.setAttribute('contentEditable', false);
		}
		this.mStashedEditables = editables;
	},
	prepareToDeselectAll: function() {
		// Re-enable any contentEditable elements.
		var stashedEditables = this.mStashedEditables, stashedEditablesIdx, stashedEditable;
		for (stashedEditablesIdx = 0; stashedEditablesIdx < stashedEditables.length; stashedEditablesIdx++) {
			stashedEditable = stashedEditables[stashedEditablesIdx];
			stashedEditable.setAttribute('contentEditable', true);
		}
		// Restore the previously active block and selection.
		if (this.mStashedActiveBlock) globalEditorController().startEditing(this.mStashedActiveBlock);
		try { globalEditorTextSelectionDelegate().restoreSelection(); } catch(e) {};
	}
});
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.

// A text selection delegate.

var GlobalEditorTextSelectionDelegate = Class.createWithSharedInstance('globalEditorTextSelectionDelegate');
GlobalEditorTextSelectionDelegate.prototype = {
	mCachedSelection: null,
	initialize: function() {},
	// Caches the current text selection and cursor position.
	cacheSelection: function() {
		if (document.selection && document.selection.createRange) {
			this.mCachedSelection = document.selection.createRange();
		} else if (window.getSelection) {
			var sel = window.getSelection();
			if (sel) this.mCachedSelection = {
				anchorNode: sel.anchorNode,
				anchorOffset: sel.anchorOffset,
				focusNode: sel.focusNode,
				focusOffset: sel.focusOffset
			};
			if (!sel || !this.mCachedSelection.anchorNode) this.mCachedSelection = null;
		}
		else {
			this.mCachedSelection = null;
		}
		logger().debug("cacheSelection: %o", this.mCachedSelection);
	},
	// Returns the currently selected string.
	getSelectedString: function() {
		var result = "";
		if (document.selection && document.selection.createRange) {
			result = document.selection.createRange().text.replace(/^\s+/, '').replace(/\s+$/, '');
		} else if (window.getSelection && window.getSelection().toString) {
			result = window.getSelection().toString() || "";
		}
		return result;
	},
	// Returns a Range (or TextRange) for the current document selection, if it exists.
	getSelectionAsRange: function() {
		var sel, range;
		if (browser().isIE() && document.selection) {
			range = document.selection.createRange();
		} else if (window.getSelection) {
			sel = window.getSelection();
			if (!sel.anchorNode || !sel.focusNode) return;
			// Keep track of the original anchorNode, focusNode, anchorOffset and focusOffset.
			var anchorNode = sel.anchorNode, focusNode = sel.focusNode, anchorOffset = sel.anchorOffset, focusOffset = sel.focusOffset;
			range = document.createRange();
			range.setStart(sel.anchorNode, sel.anchorOffset);
			range.setEnd(sel.focusNode, sel.focusOffset);
			// If the new range appears to be collapsed (where it previously was not collapsed)
			// it was reversed. Flip the range we just created.
			if (range.collapsed && ((anchorNode != focusNode) || ((focusOffset - anchorOffset) != 0))) {
				range.setStart(sel.focusNode, sel.focusOffset);
				range.setEnd(sel.anchorNode, sel.anchorOffset);
			}
		}
		return range;
	},
	// Restores a cached text selection.
	restoreSelection: function() {
		if (!this.mCachedSelection) return;
		if (document.selection && document.selection.createRange) {
			this.mCachedSelection.select();
		} else if (window.getSelection) {
			var sel = window.getSelection();
			if (sel.setBaseAndExtent) {
				sel.setBaseAndExtent(this.mCachedSelection.anchorNode, this.mCachedSelection.anchorOffset, this.mCachedSelection.focusNode, this.mCachedSelection.focusOffset);
			}
			else if (document.createRange) {
				var rng = document.createRange();
				rng.setStart(this.mCachedSelection.anchorNode, this.mCachedSelection.anchorOffset);
				rng.setEnd(this.mCachedSelection.focusNode, this.mCachedSelection.focusOffset);
				sel.removeAllRanges();
				sel.addRange(rng);
				window.focus();
			}
		}
	},
	// Returns true if a selection exists, and it is empty.
	currentSelectionIsEmpty: function() {
		var sel = null;
		if (document.selection && document.selection.type) {
			return document.selection.type == 'None';
		} else if (window.getSelection) {
			sel = window.getSelection();
			return (sel.anchorNode == sel.focusNode && sel.anchorOffset == sel.focusOffset);
		}
		return true;
	},
	// Returns true if a selection exists, and that selection is a child of an
	// element with a given tag name. Useful for detecting whether we're focused
	// inside an ordered/unordered list, for example.
	currentSelectionChildOfNodeName: function(inNodeName) {
		if (!inNodeName) return false;
		var nodeName = inNodeName.toLowerCase();
		var selectionAsRange = this.getSelectionAsRange();
		var startContainer = selectionAsRange.startContainer;
		var nearestExtendedContainer = $((startContainer.nodeType == 3) ? startContainer.parentNode : startContainer);
		return ((nearestExtendedContainer.nodeName.toLowerCase() == nodeName) || (nearestExtendedContainer.up(nodeName) != undefined));
	},
	// Selects all child elements of an element.
	selectAllChildren: function(inContextElement) {
		if (!inContextElement) return false;
		if (document.selection && document.body.createTextRange) { // IE
			var rng = document.body.createTextRange();
			rng.moveToElementText(inContextElement);
			rng.select();
		} else if (window.getSelection) {
			var sel = window.getSelection();
			if (sel.setBaseAndExtent) { // Safari
				sel.setBaseAndExtent(inContextElement, 0, inContextElement, Math.max(inContextElement.innerText.length - 1, 0));
			}
			else if (sel.selectAllChildren) { // Firefox
				sel.selectAllChildren(inContextElement);
			}
		}
	},
	// Moves the text cursor to the start/end of an optional context element
	// if it exists or to the start/end of the active text selection.
	moveCursorToStart: function(inOptContextElement) {
		var sel = window.getSelection();
		if (sel) {
			sel.removeAllRanges();
			if (inOptContextElement && sel.selectAllChildren) sel.selectAllChildren(inOptContextElement);
			sel.collapseToStart();
		}
	},
	moveCursorToEnd: function(inOptContextElement) {
		var sel = window.getSelection();
		if (sel) {
			sel.removeAllRanges();
			if (inOptContextElement && sel.selectAllChildren) sel.selectAllChildren(inOptContextElement);
			sel.collapseToEnd();
		}
	},
	// Returns true if the cursor is focused at the start of a text range.
	// Accepts an optional context element used for calculating the cursor
	// position when we have a series of nested nodes.
	isCursorFocusedAtStart: function(inOptContextElement) {
		var sel = window.getSelection(), result;
		// Are we focused at the start of the active text node?
		var focusedAtStartOfNode = (sel && sel.anchorNode && (sel.anchorOffset == 0));
		if (!inOptContextElement) {
			result = focusedAtStartOfNode;
			logger().debug("isCursorFocusedAtStart: %o", result);
			return result;
		}
		// We're focused at the start if the cursor is at the start
		// of the selection node, and the selection node is leftmost
		// in the editing context.
		var isBoundary = this.isBoundaryNode(sel.anchorNode, inOptContextElement);
		result = (focusedAtStartOfNode && isBoundary);
		logger().debug("isCursorFocusedAtStart: %o", result);
		return result;
	},
	// Returns true if the cursor is focused at the end of a text range.
	isCursorFocusedAtEnd: function(inOptContextElement) {
		var sel = window.getSelection();
		var focusedAtEndOfNode = false;
		if (sel.focusNode) {
			// If we're selecting inside a text node, the focusOffset is calculated relative to the
			// length of the nodeValue string.
			if (sel.focusNode.nodeType == 3) {
				var focusNodeTextValue = Element.textValue(sel.focusNode);
				focusedAtEndOfNode = ((sel.focusOffset == focusNodeTextValue.length) || (sel.focusOffset == focusNodeTextValue.gsub(/\n$/, "").length));
			} else if (sel.focusNode.hasChildNodes()) {
				var focusNodeChildNodes = sel.focusNode.childNodes;
				var focusNodeChildNodesLength = focusNodeChildNodes.length;
				focusedAtEndOfNode = (sel.focusOffset == focusNodeChildNodesLength);
				// Firefox hack (which insists on placing the cursor before a trailing <br> tag).
				if (!focusedAtEndOfNode && browser().isFirefox()) {
					if (isBrTag(focusNodeChildNodes.item(focusNodeChildNodesLength - 1))) {
						focusedAtEndOfNode = (sel.focusOffset == (focusNodeChildNodesLength - 1));
					}
				}
			}
		}
		// We're focused at the end if the cursor is at the end of
		// the selection node, and the selection node is rightmost in
		// the editing context.
		var isBoundary = this.isBoundaryNode(sel.focusNode, inOptContextElement, true);
		var result = (focusedAtEndOfNode && isBoundary);
		logger().debug("isCursorFocusedAtEnd: %o", result);
		return result;
	},
	// Returns true if a given childnode is a boundary node inside a given
	// root node. Walks the DOM and determines if a given child node is the
	// leftmost or rightmost child in a set of (possibly nested) child nodes.
	isBoundaryNode: function(inChildNode, inRootNode, inOptRightBoundary) {
		if (!inChildNode || !inRootNode) return true;
		var isBoundary = false, root = inRootNode, brTagCount = 0, childNodes, childNode;
		while (!isBoundary && root) {
			if (root == inChildNode) {
				isBoundary = true;
				break;
			}
			childNodes = root.childNodes;
			if (!childNodes || childNodes.length == 0) break;
			var idx = (inOptRightBoundary !== undefined) ? childNodes.length - 1 : 0;
			childNode = childNodes.item(idx);
			if (isBrTag(childNode)) {
				brTagCount += 1;
				root = childNodes.item(idx - 1);
				continue;
			}
			if ((childNode == inChildNode) && (!browser().isFirefox() || (browser().isFirefox() && brTagCount <= 1))) {
				isBoundary = true;
				break;
			}
			// Spin again.
			root = childNodes[idx];
		}
		return isBoundary;
	}
};
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.

// Model for a block.

CC.WikiEditor.BlockModel = Class.create(CC.Mvc.Model, CC.Mvc.Mixins.ChangeAware, {
	type: 'com.apple.model.Block',
	blockType: 'unknown',
	mChangesetAttributes: 'blockType extendedAttributes'.w(),
	// Block GUIDs are generated client-side so we don't have to hit the server
	// for every change by the user before saving, and so we don't end up with
	// rogue blocks that have been created and later deleted before saving the page.
	// When we instantiate a new block model, we auto-provision an model GUID.
	initialize: function($super) {
		$super.apply(null, Array.prototype.slice.call(arguments, 1));
		if (!this.guid) {
			var generator = new CC.GuidBuilder();
			this.guid = generator.toString();
		}
	}
});
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.

// Global block type registry responsible for managing registered block
// types, and mapping block identifers (e.g. "text") to block controller
// instances. Strictly one per customer. Each editor instance has a plugin
// registry.

CC.WikiEditor.GlobalBlockPluginRegistry = Class.createWithSharedInstance('globalEditorBlockPluginRegistry');
CC.WikiEditor.GlobalBlockPluginRegistry.prototype = {
	mRegisteredBlocks: new Hash(),
	initialize: function() {},
	registerBlockType: function(inBlockTypeIdentifer, inBlockClass /*, {options} */) {
		if (!(inBlockTypeIdentifer && inBlockClass)) throw("Block registration requires a type identifier and class path");
		if (this._isBlockTypeRegistered(inBlockTypeIdentifer)) throw("Block type (%@) is already registered".fmt(inBlockTypeIdentifer));
		// If we got a property path, convert it to a function pointer.
		var konstructor = (CC.typeOf(inBlockClass) === CC.T_STRING) ? CC.objectForPropertyPath(inBlockClass) : inBlockClass;
		if (!konstructor) throw("Block " +  inBlockTypeIdentifer + " has an invalid constructor path " + inBlockClass);
		// Add the block to our hash of registered blocks, instantiating a contextual
		// block toolbar for this block type where necessary.
		var hash = {'klass': konstructor};
		if (arguments.length > 2) Object.extend(hash, arguments[2]);
		if ('mBlockToolbar' in hash) {
			var blockToolbar = CC.objectInstanceForPropertyPath(hash['mBlockToolbar']);
			// Set the block type for the toolbar, for convenience.
			if (blockToolbar.mBlockTypeIdentifer === undefined) blockToolbar.mBlockTypeIdentifer = inBlockTypeIdentifer;
			hash['mBlockToolbar'] = blockToolbar;
		}
		if ('mEditorToolbarItem' in hash) {
			hash['mEditorToolbarItem'] = CC.objectInstanceForPropertyPath(hash['mEditorToolbarItem']);
		}
		// Update our registered blocks structure.
		this.mRegisteredBlocks.set(inBlockTypeIdentifer, hash);
	},
	// Unregisters block information for a particular block identifer. Does not clean
	// up any instances of a block type on the page.
	unregisterBlockType: function(inBlockTypeIdentifer) {
		if (!this._isBlockTypeRegistered(inBlockTypeIdentifer)) return false;
		this.mRegisteredBlocks.unset(inBlockTypeIdentifer);
	},
	// Returns an array of registered block identifers.
	registeredBlocks: function() {
		return this.mRegisteredBlocks.keys();
	},
	// Returns the block registered for a given type identifer, if it exists.
	registeredBlockForType: function(inBlockTypeIdentifer) {
		if (!inBlockTypeIdentifer || !this._isBlockTypeRegistered(inBlockTypeIdentifer)) return undefined;
		return this.mRegisteredBlocks.get(inBlockTypeIdentifer);
	},
	// Private helper method that returns true if a given block type identifier exists in
	// the block registry, and false otherwise. Assumes that if the identifer is in the
	// CC.Set associated with this class it is correctly registered.
	_isBlockTypeRegistered: function(inBlockTypeIdentifer) {
		if (!inBlockTypeIdentifer) return false;
		return this.mRegisteredBlocks.get(inBlockTypeIdentifer) !== undefined;
	},
	// Returns the registered block controller for a given block type identifer (the block
	// controller registered with the plugin registry for block records in the store of that
	// type).
	blockControllerForType: function(inBlockTypeIdentifer) {
		var block = this.registeredBlockForType(inBlockTypeIdentifer);
		return block ? block['klass'] : undefined;
	},
	blockToolbarForType: function(inBlockTypeIdentifer) {
		var block = this.registeredBlockForType(inBlockTypeIdentifer);
		return block ? block['mBlockToolbar'] : undefined;
	},
	editorToolbarItemForType: function(inBlockTypeIdentifer) {
		var block = this.registeredBlockForType(inBlockTypeIdentifer);
		return block ? block['mEditorToolbarItem'] : undefined;
	},
	// Returns true if blocks registered with a particular identifier allow nesting (they
	// can behave as containers for other blocks).
	blockTypeBehavesAsContainer: function(inBlockTypeIdentifer) {
		var block = this.blockControllerForType(inBlockTypeIdentifer);
		return (block && block.prototype && block.prototype.mIsContainer);
	}
};
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.

// An editor block plugin.

CC.WikiEditor.BlockPlugin = Class.create({
	// A unique string identifier for your plugin.
	mBlockIdentifier: null,
	// A string property path for your block controller.
	mBlockController: null,
	// An optional string property path for a block toolbar.
	mBlockToolbar: null,
	// An optional editor toolbar item instance for your block.
	mEditorToolbarItem: null
});

// Global editor plugin manager. Responsible for registering/unregistering block plugins.

CC.WikiEditor.GlobalEditorPluginManager = Class.createWithSharedInstance('globalEditorPluginManager');
CC.WikiEditor.GlobalEditorPluginManager.prototype = {
	initialize: function() {},
	// Proxies to the block plugin registry for quick block registration.
	registerBlockType: function(inBlockTypeIdentifer, inBlockClass /*, {options} */) {
		globalEditorBlockPluginRegistry().registerBlockType.apply(globalEditorBlockPluginRegistry(), arguments);
	},
	// Register a new block plugin.
	registerBlockPlugin: function(inBlockPlugin) {
		if (!inBlockPlugin || !CC.kindOf(inBlockPlugin, CC.WikiEditor.BlockPlugin)) return logger().error("Invalid block plugin (plugins should be an instance of CC.WikiEditor.BlockPlugin or one of its subclasses).");
		globalEditorBlockPluginRegistry().registerBlockType(inBlockPlugin.mBlockIdentifier, inBlockPlugin.mBlockController, {
			'mBlockToolbar': inBlockPlugin.mBlockToolbar,
			'mEditorToolbarItem': inBlockPlugin.mEditorToolbarItem
		});
	},
	// Unregister an already registered block plugin by identifer (if it exists).
	unregisterBlockPluginByIdentifer: function(inBlockPluginIdentifer) {
		if (!inBlockPluginIdentifer) return logger().error("Cannot unregister unknown block plugin (%@)".fmt(inBlockPluginIdentifer));
		globalEditorBlockPluginRegistry().unregisterBlockType(inBlockPluginIdentifer);
	}
};
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.

// Editing service responsible for marshalling requests to and from the
// server, basic conflict resolution and handling concurrent editing.

CC.WikiEditor.EditingService = Class.create(CC.Object, {
	saveChanges: function(inPayload, inOptForceSavePage, inOptCallback, inOptErrback) {
		if (!inPayload) return inOptErrback ? inOptErrback() : false;
		var entity = globalEditorController().mPage.mRecord;
		var pageGUID = entity.guid;
		var gotCurrentUser = function(currentUser) {
			this.latestRevisionForPageGUID(pageGUID, function(serverRevision) {
				var cs = new CC.EntityTypes.EntityChangeSet({
					'changeAction': "UPDATE",
					'entityGUID': pageGUID,
					'entityRevision': serverRevision,
					'entityType': "com.apple.entity.Page",
					'changes': inPayload,
					'force': (inOptForceSavePage || false)
				});
				var href = window.location.protocol + "//" + window.location.host;
				var entityURL = href + CC.entityURLForTypeAndGUID(entity.type, entity.guid);
				var ownerURL = href + CC.entityURLForTypeAndGUID(entity.ownerType, entity.ownerGUID);
				var clientURL = "#entity_url:%@#owner_url:%@".fmt(entityURL, ownerURL);
				var batched = [
					['ContentService', 'updateEntity:', cs],
					['ContentService', 'markEntityAsRead:', pageGUID]
				];
				// 10750097
				// If the currently editing user is authenticated and hidden unhide.
				if (currentUser && currentUser.isHidden && currentUser.isAuthenticated) {
					batched.push(['ContentService', 'unhideUserWithGUID:', currentUser.guid, {'hints': {'activity.ignore': true}}]);
				}
				return service_client().batchExecuteAsynchronously(batched, {
					'expandReferencedObjects': false,
					'subpropertyPaths': server_proxy().mDefaultSubpropertyPaths,
					'clientURL': clientURL
				}, inOptCallback, inOptErrback);
			}, inOptErrback);
		}.bind(this);
		return sessions().currentUserAsynchronously(gotCurrentUser, inOptErrback);
	},
	checkServerForEdits: function(inOptChangesCallback, inOptNoChangesCallback, inOptErrback) {
		var pageGUID = globalEditorController().mPage.getRecordPropertyForPath('guid');
		var pageRevision = parseInt(globalEditorController().mPage.getRecordPropertyForPath('revision'), 10);
		this.latestRevisionForPageGUID(pageGUID, function(serverRevision) {
			if (serverRevision > pageRevision) {
				logger().debug("Server revision is newer than local revision (%@ > %@)", serverRevision, pageRevision);
				if (inOptChangesCallback) inOptChangesCallback();
			} else {
				if (inOptNoChangesCallback) inOptNoChangesCallback();
			}
		}, Prototype.emptyFunction);
	},
	latestRevisionForPageGUID: function(inPageGUID, inOptCallback, inOptErrback) {
		return server_proxy().revisionForEntityGUID(inPageGUID, inOptCallback, inOptErrback);
	},
	triggerPreviewForPageGUID: function(inPageGUID) {
		service_client().executeAsynchronously('PagePreviewService', 'kickPreviewQueue', null, Prototype.emptyFunction, Prototype.emptyFunction);
	}
});
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.

// Migration namespace.

CC.WikiEditor.Migration = CC.WikiEditor.Migration || new CC.Object();

// Tag constants.

CC.WikiEditor.Migration.SAFE_TEXT_TAGS = [
	'#text',
	'a',
	'abbr',
	'acronym',
	'address',
	'b',
	'bdo',
	'big',
	'blockquote',
	'br',
	'center',
	'code',
	'cite',
	'dd',
	'del',
	'dfn',
	'dir',
	'div',
	'dl',
	'dt',
	'em',
	'font',
	'h1',
	'h2',
	'h3',
	'h4',
	'h5',
	'h6',
	'i',
	'ins',
	'kdb',
	'li',
	'link',
	'ol',
	'p',
	'pre',
	'q',
	's',
	'samp',
	'small',
	'span',
	'strike',
	'strong',
	'sub',
	'sup',
	'tt',
	'u',
	'ul',
	'var'
];
CC.WikiEditor.Migration.SAFE_TEXT_TAGS_COMMA_SEPERATED = CC.WikiEditor.Migration.SAFE_TEXT_TAGS.join(', ');
CC.WikiEditor.Migration.INLINE_TAGS = [
	'#text',
	'#comment',
	'a',
	'abbr',
	'acronym',
	'b',
	'bdo',
	'big',
	'code',
	'cite',
	'del',
	'dfn',
	'dt',
	'em',
	'i',
	'ins',
	'kdb',
	'link',
	'q',
	's',
	'samp',
	'small',
	'span',
	'strike',
	'strong',
	'sub',
	'sup',
	'tt',
	'u',
	'var'
];
CC.WikiEditor.Migration.COLLAPSABLE_TEXT_TAGS = ['code', 'div', 'pre'];

// Returns true if a node can be considered an inline node.

var isInlineNode = function(inNode) {
	return (inNode && CC.WikiEditor.Migration.INLINE_TAGS.indexOf(inNode.nodeName.toLowerCase()) >= 0);
};

// Returns true if a node is a <br> tag.

var isBrTag = function(inNode) {
	return (inNode && inNode.nodeName.toLowerCase() == 'br');
};

// A block migration transformer. Each registered transformer is responsible for migrating
// a single HTML tag (or nested set of tags).

CC.WikiEditor.Migration.Transformer = Class.create(CC.Object, {
	// Node names to match.
	mNodeNames: null,
	initialize: function(/* [options] */) {
		if (arguments.length > 0 && arguments[0]) Object.extend(this, arguments[0]);
	},
	// Transforms a DOM node. Since transformers will be invoked in order (and complex transformers
	// e.g. tables handle their own sub-tags), it is expected that a transformer return a single JSON
	// representation of a block can later be added to the page. If your result is a container block,
	// it is assumed that any child blocks are part of that JSON representation (in the same format)
	// in a _childBlocks array. If your container block does complex layout (e.g. a table block) it is
	// also expected that any layout-tracking properties of the parent block are initialized when the
	// result is returned. Alternative return values are false if your transformer failed to handle
	// the node (where it will be sandboxed instead) or true if the your transformer handled the node
	// with no output.
	transformNode: function(inNode) { /* Interface */ }
});

// Migration transformer registry, handling all registered block transformers.

var MigrationTransformerRegistry = Class.createWithSharedInstance('globalEditorMigrationTransformerRegistry');
MigrationTransformerRegistry.prototype = {
	mRegisteredTransformers: new Hash(),
	// Lookup tables for transformers. Keeps things fast. The node name map is just a set of keys/values
	// where the key is a string node name, and the value a pointer to the transformer instance.
	mTransformerForNodeNameMap: new Hash(),
	initialize: function() {},
	// Register a new transformer. Expects a unique transformer identifier and either a string
	// referencing the constructor for your transformer, a pointer to your transformer constructor
	// or an actual instance of your transformer. If a string or pointer is passed, we will just
	// instantiate a transformer.
	registerTransformer: function(inTransformerIdentfier, inTransformerClass) {
		if (this._isTransformerRegistered(inTransformerIdentfier)) logger().warn("Migration transformer (%@) is already registered and will be overridden", inTransformerIdentfier);
		var konstructor = (CC.typeOf(inTransformerClass) === CC.T_STRING) ? CC.objectForPropertyPath(inTransformerClass) : inTransformerClass;
		var instance = (CC.typeOf(konstructor, CC.T_OBJECT) ? konstructor : new konstructor());
		this.mRegisteredTransformers.set(inTransformerIdentfier, instance);
		// Set this transformer for matching node names.
		var nodeNames = (instance.mNodeNames || new Array()), nodeNameIdx, nodeName;
		for (nodeNameIdx = 0; nodeNameIdx < nodeNames.length; nodeNameIdx++) {
			nodeName = nodeNames[nodeNameIdx];
			this.mTransformerForNodeNameMap.set(nodeName, instance);
		}
	},
	// Removes a registered transformer for a given identifier, if it exists.
	unregisterTransformer: function(inTransformerIdentifer) {
		if (!this._isTransformerRegistered(inTransformerIdentifer)) return false;
		this.mRegisteredTransformers.unset(inTransformerIdentifer);
	},
	// Returns an array of identifiers for all registered transformers.
	registeredTransformers: function() {
		return this.mRegisteredTransformers.keys();
	},
	// Returns the registered transformers for a given node name.
	transformerForNodeName: function(inNodeName) {
		return this.mTransformerForNodeNameMap.get(inNodeName);
	},
	_isTransformerRegistered: function(inTransformerIdentifer) {
		if (!inTransformerIdentifer) return false;
		return this.mRegisteredTransformers.get(inTransformerIdentifer) !== undefined;
	}
};

// Helper functions for migration.

CC.WikiEditor.MigrationHelpers = {
	// Returns an object representing a new block.
	$block: function(inBlockType, inOptExtendedAttributes /*, inOptOptions */) {
		if (!inBlockType) return undefined;
		var block = {
			'guid': (new CC.GuidBuilder()).toString(),
			'blockType': inBlockType,
			'extendedAttributes': (inOptExtendedAttributes || {})
		};
		if (arguments && arguments.length > 2) Object.extend(block, arguments[2]);
		return block;
	},
	// Returns a placeholder string for a block with given GUID and block type.
	$placeholder: function(inBlockGUID, inBlockType) {
		if (!inBlockGUID || !inBlockType) return undefined;
		return "<div class=\"block-placeholder\" data-guid=\"%@\" data-type=\"%@\">%@</div>".fmt(inBlockGUID, inBlockType, inBlockGUID);
	}
};

// Individual transformers.

CC.WikiEditor.Migration.TextTransformer = Class.create(CC.WikiEditor.Migration.Transformer, {
	mNodeNames: CC.WikiEditor.Migration.SAFE_TEXT_TAGS,
	// Transforms a block of text into a text block with optional child blocks.
	transformNode: function(inNode, inOptDoNotSandboxUnsafeNodes) {
		if (!inNode) return true;
		// If there are no child nodes, or job is easy.
		if (inNode.nodeType == 3 && !inNode.nodeValue.isWhitespace()) {
			return CC.WikiEditor.MigrationHelpers.$block('text', {'content': inNode.nodeValue});
		}
		// Initialize some properties for the new text block.
		var blockGUIDs = [];
		var _childBlocks = [];
		// Text blocks are freeform content blocks that contain content-driven child nodes, and optionally
		// contain other non-text child blocks. Child blocks are positioned using block placeholder elements.
		// Start migrating this text block by iterating through each of the child nodes pushing into a buffer
		// array until we have no child nodes left, or hit a unrecognized node. Unrecognized nodes may either
		// be transformed into blocks themselves (depending on whether we have a matching transformer or not)
		// or sandboxed in place inside a sandbox block.
		var childNodes = $A(inNode.childNodes);
		var childNodesLength = childNodes.length, childNodeIdx, childNode, childNodeName, allChildren, safeChildren;
		var buffer = [], bufferedChildNode, bufferedChildNodeType, didBufferChildNode, shouldMigrateOrSandboxChildNode;
		var migratedChildNodeResult, migratedChildNodeGUID, migratedChildNodeBlockType, migratedChildNodeExtendedAttributes;
		var contentHTMLConcatenation = [], contentHTML;
		for (childNodeIdx = 0; childNodeIdx < childNodesLength; childNodeIdx++) {
			childNode = childNodes[childNodeIdx];
			if (childNode == undefined) continue;
			childNodeName = childNode.nodeName.toLowerCase();
			didBufferChildNode = shouldMigrateOrSandboxChildNode = false;
			// Sandbox if this child node is considered unsafe. A node is unsafe if the node itself is unsafe
			// or a parent of an unsafe child node.
			if (!inOptDoNotSandboxUnsafeNodes && childNode.nodeType != 3) {
				if (!CC.WikiEditor.Migration.SAFE_TEXT_TAGS.include(childNodeName)) shouldMigrateOrSandboxChildNode = true;
				if (!shouldMigrateOrSandboxChildNode) {
					if (childNode.querySelectorAll) {
						allChildren = childNode.querySelectorAll('*');
						safeChildren = childNode.querySelectorAll(CC.WikiEditor.Migration.SAFE_TEXT_TAGS_COMMA_SEPERATED);
						if (allChildren.length != safeChildren.length) shouldMigrateOrSandboxChildNode = true;
					}
				}
				if (shouldMigrateOrSandboxChildNode) logger().debug("Sandboxing because node is unsafe or contains an unsafe child node %o", childNode);
			}
			// If the child node is a safe text tag, a <br> tag or a non line-breaking text node, push it onto the buffer.
			if (!shouldMigrateOrSandboxChildNode && (isBrTag(childNode) || (CC.WikiEditor.Migration.SAFE_TEXT_TAGS.indexOf(childNodeName) > -1) || (childNode.nodeType == 3 && !(childNode.nodeValue || "").match(/^[\r\n]+$/)))) {
				buffer.push(childNode);
				didBufferChildNode = true;
				if (childNodeIdx < (childNodes.length - 1)) continue;
			}
			// If we didn't push the childNode onto the buffer, we just hit an unrecognized node. Attempt to migrate
			// the node with another registered transformer, otherwise sandbox the node.
			if (!didBufferChildNode || shouldMigrateOrSandboxChildNode) {
				migratedChildNodeResult = globalEditorMigrationController().migrateNode(childNode);
				// If we successfully migrated to another block, push a placeholder onto the buffer and update the
				// blockGUIDs and _childBlocks properties we're computing.
				if (migratedChildNodeResult && (migratedChildNodeResult != true)) {
					migratedChildNodeGUID = migratedChildNodeResult['guid'];
					migratedChildNodeBlockType = migratedChildNodeResult['blockType'];
					// Did we just migrate into a nested text block?
					if (migratedChildNodeBlockType == 'text') {
						migratedChildNodeExtendedAttributes = (migratedChildNodeResult.extendedAttributes || {});
						buffer.push(migratedChildNodeExtendedAttributes.content || "");
						if (migratedChildNodeExtendedAttributes.blockGUIDs) blockGUIDs = blockGUIDs.concat(migratedChildNodeExtendedAttributes.blockGUIDs);
						if (migratedChildNodeResult._childBlocks) _childBlocks = _childBlocks.concat(migratedChildNodeResult._childBlocks);
					} else {
						buffer.push(CC.WikiEditor.MigrationHelpers.$placeholder(migratedChildNodeGUID, migratedChildNodeBlockType));
						blockGUIDs.push(migratedChildNodeGUID);
						_childBlocks.push(migratedChildNodeResult);
					}
				}
			}
			// If we have exhausted the list of child nodes, flush the buffer and build a concatenated content string
			// for the text block we'll return.
			if (childNodeIdx == (childNodesLength - 1) && (buffer.length > 0)) {
				for (var jdx = 0; jdx < buffer.length; jdx++) {
					bufferedChildNode = buffer[jdx];
					if (Object.isString(bufferedChildNode)) {
						contentHTMLConcatenation.push(bufferedChildNode);
					} else if (bufferedChildNode.nodeType == 3) {
						contentHTMLConcatenation.push(bufferedChildNode.nodeValue.escapeHTML());
					} else if (bufferedChildNode.nodeType == 1) {
						contentHTMLConcatenation.push(Element.outerHtmlValue(bufferedChildNode));
					} else {
						logger().debug("Unrecognized child node encountered when building text block contents %o", bufferedChildNode);
					}
				}
				contentHTML = contentHTMLConcatenation.join('');
			}
		}
		return CC.WikiEditor.MigrationHelpers.$block('text', {'content': (contentHTML || ""), 'blockGUIDs': blockGUIDs}, {'_childBlocks': _childBlocks});
	}
});

// Migrates tables.

CC.WikiEditor.Migration.TableTransformer = Class.create(CC.WikiEditor.Migration.Transformer, {
	mNodeNames: ['table'],
	transformNode: function(inNode) {
		// If the user has been prompted to use the wiki table editor before, and they
		// declined for this table, migrate the table into a sandbox. Otherwise, migrate
		// the table and its contents to blocks.
		if (inNode.className && inNode.className.match(/__doNotUseTableEditor/)) {
			var transformer = globalEditorMigrationTransformerRegistry().transformerForNodeName('#sandbox');
			if (transformer) return transformer.transformNode(inNode);
		}
		// If this is a thumbnail masquerading as a table, migrate the child image to
		// a sandbox and ignore any wrapper chrome.
		else if (inNode.className && inNode.className.match(/thumbnail/)) {
			var img = $(inNode).down('img');
			if (img) {
				var transformer = globalEditorMigrationTransformerRegistry().transformerForNodeName('#sandbox');
				if (transformer) return transformer.transformNode(img);
			}
			return true;
		}
		else {
			var table = Element.extend(inNode);
			// Get the number of table rows.
			var rows = table.select('tr');
			if (!rows || !rows.length > 0) return true;
			var rowCount = rows.length;
			// Compensate for any rows where a rowspan is defined.
			var row, rowspan;
			for (var rowIdx = 0; rowIdx < rowCount; rowIdx++) {
				row = rows[rowIdx];
				rowspan = parseInt(row.getAttribute('rowspan'));
				if (!isNaN(rowspan)) rowCount += Math.max(rowspan - 1, 0);
			}
			// Get the number of table columns.
			var firstRow = table.down('tr');
			if (!firstRow) return true;
			var firstRowCells = firstRow.select('th, td');
			var firstRowCellsLength = firstRowCells.length;
			var columnCount = firstRowCellsLength;
			// Compensate for any table cells where a colspan value is defined.
			var cell, colspan;
			for (var cellIdx = 0; cellIdx < firstRowCellsLength; cellIdx++) {
				cell = firstRowCells[cellIdx];
				colspan = parseInt(cell.getAttribute('colspan'));
				if (!isNaN(colspan)) columnCount += Math.max(colspan - 1, 0);
			}
			var size = {'width': columnCount, 'height': rowCount};
			logger().debug("Migrating table with %o columns and %o rows", columnCount, rowCount);
			// Determine if the table has a heading row/column enabled.
			var hasHeadingRow = (table.down('thead') != undefined || table.down('tbody tr th') != undefined);
			var firstRow = table.down('tr');
			var secondRow = (firstRow && firstRow.next('tr'));
			var hasHeadingColumn = (secondRow && secondRow.down('th') != undefined);
			var headerPreferences = [hasHeadingRow, hasHeadingColumn];
			// Initialize a reverse layout and blockGUIDs property for the new table block.
			var reverseLayout = {}, blockGUIDs = [], _childBlocks = [];
			var tableCellTransformer = globalEditorMigrationTransformerRegistry().transformerForNodeName('td');
			// Track the skip cells for a row. A skip cell is a cell that is missing
			// from the original table node (because of a colspan/rowspan attribute).
			// Skip cells are migrated to empty cells in the new table block.
			var skipCells = new Array(size.width * size.height);
			// Now, iterate over every table cell migrating any cell content into child
			// blocks of this container.
			var rowIndex = 0, columnIndex = 0;
			var cells = table.select('th, td');
			for (var cellIdx = 0; cellIdx < cells.length; cellIdx++) {
				cell = cells[cellIdx];
				colspan = parseInt(cell.getAttribute('colspan'));
				rowspan = parseInt(cell.getAttribute('rowspan'));
				colspan = isNaN(colspan) ? 1 : Math.max(colspan, 1);
				rowspan = isNaN(rowspan) ? 1 : Math.max(rowspan, 1);
				// Update the skip cells for this index.
				var arrayStartIdx = (columnIndex + (rowIndex * size.width));
				if (colspan > 1) {
					for (var arrayIdx = arrayStartIdx + 1; arrayIdx <= (arrayStartIdx + Math.min(size.width - columnIndex, colspan - 1)); arrayIdx++) {
						if (arrayIdx >= skipCells.length) break;
						skipCells[arrayIdx] = true;
					}
				}
				if (rowspan > 1) {
					for (var arrayIdx = (arrayStartIdx + size.width); arrayIdx <= (arrayStartIdx + (size.width * (rowspan - 1))); arrayIdx += size.width) {
						if (arrayIdx >= skipCells.length) break;
						skipCells[arrayIdx] = true;
					}
				}
				// If we're about to write into a skip cell, find the next non-skip cell.
				var skipCellIdx = columnIndex + (size.width * rowIndex);
				if (skipCells[skipCellIdx]) {
					while (skipCellIdx < skipCells.length && skipCells[skipCellIdx]) {
						skipCellIdx += 1;
					}
					rowIndex = Math.floor(skipCellIdx / size.width);
					columnIndex = skipCellIdx % size.width;
				}
				// Migrate the table cell, updating the reverse layout of the table.
				var migratedTableCell = tableCellTransformer.transformNode(cell), migratedTableCellBlockGUID;
				if (migratedTableCell) {
					migratedTableCellBlockGUID = migratedTableCell['guid'];
					if (migratedTableCellBlockGUID) {
						reverseLayout[migratedTableCellBlockGUID] = [rowIndex, columnIndex];
						blockGUIDs.push(migratedTableCellBlockGUID);
						_childBlocks.push(migratedTableCell);
					}
				}
				// Update the row and column index, wrapping to the next row if needed.
				columnIndex += 1;
				if (columnIndex == size.width) {
					columnIndex = 0;
					rowIndex += 1;
				}	
			}
			return CC.WikiEditor.MigrationHelpers.$block('table',
				{'size': size, 'headerPreferences': headerPreferences, 'reverseLayout': reverseLayout, 'blockGUIDs': blockGUIDs},
				{'_childBlocks': _childBlocks});
		}
	}
});

// Transforms an individual table cell. Basically, a mini-migration inside an
// optional block container. Called for individual table cells on migrated
// content, and incomplete copy/paste snippets where the browser fails to copy
// the containing table with its content.

CC.WikiEditor.Migration.TableCellTransformer = Class.create(CC.WikiEditor.Migration.Transformer, {
	mNodeNames: ['th', 'td'],
	transformNode: function(inNode) {
		var transformer = globalEditorMigrationTransformerRegistry().transformerForNodeName("#text");
		return transformer.transformNode(inNode, true);
	}
});

// Migrates images, media and attachments.

CC.WikiEditor.Migration.MediaTransformer = Class.create(CC.WikiEditor.Migration.Transformer, {
	mNodeNames: ['img'],
	transformNode: function(inNode) {
		if (!inNode) return true;
		var img = Element.extend(inNode);
		if (!img.src) return true;
		// 10817763
		if (img.src.match(/^file:/i) || img.src.match(/^webkit-fake-url:/i)) return true;
		// Catch unwanted /collaboration/images/blank.gif images.
		if (img.src == "/collaboration/images/blank.gif") return true;
		var longdesc = (img.getAttribute('longdesc') || "");
		var src = (img.getAttribute('src') || "");
		var pattern = /\/([\w-]+)#filename:(.*)(?:(?:#attachment:)|(?:#image:))([\w-]+)/;
		// The migrated file guids are stashed in the longdesc attribute.
		var matches = longdesc.match(pattern);
		// If the longdesc attribute is missing the file info, it might be in the src attrinute.
		if (!matches || matches.length != 4) {
			matches = src.match(pattern);
			if (!matches || matches.length != 4) return undefined;
		}
		// 8761062
		// Filenames are url-encoded and spaces replaced with "+" by CGI.encode.
		var fileName = decodeURIComponent(matches[2] || "").gsub(/\+/, " ");
		var extendedAttributes = {
			'fileName': fileName,
			'fileGUID': matches[3],
			'fileDataGUID': matches[1]
		}
		// Any thumbnail/posterimg info is stashed in the src attribute.
		matches = src.match(pattern);
		if (matches && matches.length != 4) {
			extendedAttributes['thumbnailFileName'] = matches[2],
			extendedAttributes['thumbnailFileGUID'] = matches[3],
			extendedAttributes['thumbnailFileDataGUID'] = matches[1];
		}
		// Stash any legacy metadata away for safe keeping in case we need to recover later.
		extendedAttributes['legacyMetadata'] = {
			'src': img.getAttribute('src'),
			'longdesc': img.getAttribute('longdesc'),
			'name': img.getAttribute('name'),
			'title': img.getAttribute('title'),
			'alt': img.getAttribute('alt'),
			'role': img.getAttribute('role'),
			'className': img.getAttribute('className')
		};
		// Finally, add the block.
		var isAttachment = (img.className && img.className.match(/attachment_handle_img/));
		var isMovie = (img.className && img.className.match(/posterimg/));
		return CC.WikiEditor.MigrationHelpers.$block((isAttachment ? 'attachment' : (isMovie ? 'media' : 'image')), extendedAttributes);
	}
});

// Internal transformer ignoring unwanted node types in a migration.

CC.WikiEditor.Migration.EmptyTransformer = Class.create(CC.WikiEditor.Migration.Transformer, {
	mNodeNames: ['#comment', 'link', 'meta', 'noscript', 'style', 'script', 'title'],
	transformNode: function(inNode) {
		// Deliberately do nothing.
		logger().debug("Node will be ignored in migration (%o)", inNode);
		return true;
	}
});

// Internal transformer for migrating to a sandbox.

CC.WikiEditor.Migration.SandboxTransformer = Class.create(CC.WikiEditor.Migration.Transformer, {
	mNodeNames: ['#sandbox'],
	transformNode: function(inNode) {
		var outerHTML = Element.outerHtmlValue(inNode), sandboxBlock;
		if (outerHTML) {
			sandboxBlock = CC.WikiEditor.MigrationHelpers.$block('sandbox', {'markup': outerHTML});
		}
		return sandboxBlock;
	}
});

// Register a bunch of transformers.

globalEditorMigrationTransformerRegistry().registerTransformer('text', new CC.WikiEditor.Migration.TextTransformer());
globalEditorMigrationTransformerRegistry().registerTransformer('table', new CC.WikiEditor.Migration.TableTransformer());
globalEditorMigrationTransformerRegistry().registerTransformer('table-cell', new CC.WikiEditor.Migration.TableCellTransformer());
globalEditorMigrationTransformerRegistry().registerTransformer('media', new CC.WikiEditor.Migration.MediaTransformer());
globalEditorMigrationTransformerRegistry().registerTransformer('empty', new CC.WikiEditor.Migration.EmptyTransformer());
globalEditorMigrationTransformerRegistry().registerTransformer('sandbox', new CC.WikiEditor.Migration.SandboxTransformer());

// Migrator, doing the heavy lifting of migrating a page (or pasted markup) to a set of blocks.
// It is expected that an editor instance is already initialized (since we require an editor
// store into which the blocks can be inserted and from which they can be persisted).

CC.WikiEditor.Migration.GlobalMigrationInstance = Class.createWithSharedInstance('globalEditorMigrationController');
CC.WikiEditor.Migration.GlobalMigrationInstance.prototype = {
	initialize: function() {},
	// Do our very best to split a supplied string of markup into a tree of blocks, by appending
	// it to the document, walking through the DOM node structure and running block transformers
	// where possible. Used when migrating both migrated page sandboxes and pasted content. Expects
	// a markup argument.
	migrate: function(inMarkup, inOptRestoreSelection) {
		if (!inMarkup || CC.typeOf(inMarkup, CC.T_STRING) && inMarkup.isWhitespace()) {
			logger().debug("Nothing to migrate (%@)".fmt(inMarkup));
			return undefined;
		}
		// First render the original content offscreen.
		if (this.mOffscreenElement) Element.remove(this.mOffscreenElement);
		this.mOffscreenElement = Builder.node('div', {id: 'wikieditor_migration', style: 'display: none;'});
		this.mOffscreenElement.innerHTML = inMarkup;
		document.body.appendChild(this.mOffscreenElement);
		// Clean the markup before we start running transformers.
		this.prepareForMigration(this.mOffscreenElement);
		// Migrate starting with a root text block and return.
		var textTransformer = globalEditorMigrationTransformerRegistry().transformerForNodeName("#text", true);
		return textTransformer.transformNode(this.mOffscreenElement);
	},
	// Migrates a child node by running it through an applicable transformer. Falls back to
	// sandboxing a node, where the node type is unknown (e.g. script tags).
	migrateNode: function(inRootNode) {
		var rootNodeName = inRootNode.nodeName.toLowerCase();
		// Do we have a transformer we can apply to this node?
		var transformer = globalEditorMigrationTransformerRegistry().transformerForNodeName(rootNodeName);
		var successful; 
		if (transformer) {
			logger().debug("Applying node transformer %o %o %o", transformer, rootNodeName, inRootNode);
			successful = transformer.transformNode(inRootNode);
		}
		if (!transformer || !successful) {
			logger().debug("Sandboxing node (%o) in migration", inRootNode);
			var transformer = globalEditorMigrationTransformerRegistry().transformerForNodeName('#sandbox');
			if (transformer) return transformer.transformNode(inRootNode);
		}
		return successful;
	},
	// Normalizes an element for migration.
	prepareForMigration: function(inElement) {
		var nodes, node, nodeIdx;
		// Remove any unnecessary div#wiki_entry tags, promoting children. The div#wiki_entry
		// element was supposed to completely wrap editable content, but a big sample of pages
		// are split inside and outside this tag. So, remove it.
		nodes = $$('#wikieditor_migration .wiki_entry');
		for (nodeIdx = 0; nodeIdx < nodes.length; nodeIdx++) {
			promoteElementChildren(nodes[nodeIdx]);
		}
		// Promote any table wrapper divs.
		nodes = inElement.select('.__tableContainer');
		for (nodeIdx = 0; nodeIdx < nodes.length; nodeIdx++) {
			promoteElementChildren(nodes[nodeIdx]);
		}
		// Remove any table drag handles.
		nodes = inElement.select('.__tableEditorDragHandle');
		for (nodeIdx = 0; nodeIdx < nodes.length; nodeIdx++) {
			Element.remove(nodes[nodeIdx]);
		}
		// Remove any meaningless tags.
		removeMeaninglessMarkup(inElement);
		// Fix up successive <pre> tags, promoting and merging child nodes together.
		nodes = inElement.select('pre');
		for (nodeIdx = 0; nodeIdx < nodes.length; nodeIdx++) {
			node = nodes[nodeIdx];
			// Is the previous sibling a <pre>?
			var previousNode = node.previousSibling;
			// Nuke any extra whitespace between <pre> tags.
			var cleanupStack = [];
			while (previousNode && isWhitespaceNode(previousNode)) {
				cleanupStack.push(previousNode);
				previousNode = previousNode.previousSibling;
			}
			if (previousNode && previousNode.nodeName.toLowerCase() == 'pre') {
				// Add a line break to maintain appearance.
				previousNode.insertBefore(document.createTextNode('\n'), null);
				// Migrate any children accross.
				while (node.childNodes.length > 0) {
					var currentChild = node.firstChild;
					node.removeChild(currentChild);
					previousNode.insertBefore(currentChild, null);
				}
				node.parentNode.removeChild(node);
				// Cleanup any extra whitespace we found.
				for (var idx = 0; idx < cleanupStack.length; idx++) {
					cleanupStack[idx].parentNode.removeChild(cleanupStack[idx]);
				}
			}
		}
		// 8321979
		// Combine successive <div> tags that only contain text/br nodes.
		nodes = inElement.getElementsByTagName('div');
		var workingNode, workingNodeMinusOne;
		if (nodes.length > 1) {
			for (nodeIdx = (nodes.length - 1); nodeIdx > 0; nodeIdx--) {
				workingNode = nodes.item(nodeIdx);
				workingNodeMinusOne = nodes.item(nodeIdx - 1);
				if (workingNode.previousSibling != workingNodeMinusOne) continue;
				if (!workingNode.hasChildNodes()) continue;
				if (onlyTextOrLineBreaks(workingNode) && onlyTextOrLineBreaks(workingNodeMinusOne)) {
					if (workingNodeMinusOne.hasChildNodes()) {
						workingNodeMinusOne.appendChild(document.createElement('br'));
					}
					while (workingNode.hasChildNodes()) {
						var child = workingNode.firstChild;
						workingNode.removeChild(child);
						workingNodeMinusOne.insertBefore(child, null);
					}
					workingNode.parentNode.removeChild(workingNode);
				}
			}
		}
		// 8589118
		// Promote any images unnecessarily wrapped in formatting tags.
		nodes = inElement.select(CC.FORMATTING_TAGS.join(', '));
		var promotable = true, childNodes, childNode, childNodeName, buffer;
		for (nodeIdx = (nodes.length - 1); nodeIdx >= 0; nodeIdx--) {
			node = nodes[nodeIdx];
			if (node.className || node.id) continue;
			// Does the node only contain whitespace, <img> and <br> tags?
			buffer = new Array();
			childNodes = node.childNodes;
			for (childIdx = 0; childIdx < childNodes.length; childIdx++) {
				childNode = childNodes.item(childIdx);
				childNodeName = childNode.nodeName.toLowerCase();
				if (!isWhitespaceNode(childNode) && childNodeName != 'br' && childNodeName != 'img') {
					promotable = false;
					break;
				}
				// Buffer all disposable nodes.
				if (childNodeName != 'img') buffer.push(childNode);
			}
			if (promotable) {
				var bufferIdx, buffered;
				for (bufferIdx = (buffer.length - 1); bufferIdx >= 0; bufferIdx--) {
					buffered = buffer[bufferIdx];
					if (buffered.parentNode) buffered.parentNode.removeChild(buffered);
				}
				promoteElementChildren(node);
			}
		}
		// Fix inline text styles.
		var classNames = ['custom_backcolor_highlight', 'custom_forecolor_important', 'custom_forecolor_emphasis'], classNameIdx, className;
		for (classNameIdx = 0; classNameIdx < classNames.length; classNameIdx++) {
			className = classNames[classNameIdx];
			nodes = inElement.select('.' + className);
			for (nodeIdx = 0; nodeIdx < nodes.length; nodeIdx++) {
				node = nodes[nodeIdx];
				node.addClassName(className.match(/(custom_backcolor_|custom_forecolor_)([\w]+)/)[2]);
				node.removeClassName(className);
			}
		}
		// Remove any non-span inline style attributes.
		nodes = inElement.select('*[style]');
		for (nodeIdx = (nodes.length - 1); nodeIdx >= 0; nodeIdx--) {
			node = nodes[nodeIdx];
			if (node && (node.nodeType == 1) && (node.nodeName.toLowerCase() != 'span')) node.removeAttribute('style');
		}
		// Remove any font tags.
		nodes = inElement.select('font');
		for (nodeIdx = (nodes.length - 1); nodeIdx >= 0; nodeIdx--) {
			node = nodes[nodeIdx];
			promoteElementChildren(node);
		}
		// Strip any editor-specific chrome (8829823 && 8450720 && 8927746).
		nodes = $(inElement).select('.chrome, .block-placeholder, .block-spacer');
		for (nodeIdx = (nodes.length - 1); nodeIdx >= 0; nodeIdx--) {
			node = nodes[nodeIdx];
			if (node && node.parentNode) node.parentNode.removeChild(node);
		}
		nodes = inElement.getElementsByClassName('wrapchrome');
		for (nodeIdx = (nodes.length - 1); nodeIdx >= 0; nodeIdx--) {
			node = nodes.item(nodeIdx);
			if (node) promoteElementChildren(node);
		}
	}
};
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.

var CopyrightNoticeHeightObserver = Class.create(Abstract.TimedObserver, {
	getValue: function() {
		return Element.getHeight(this.element);
	}
});

// Vanishing copyright text support. Dissapears after first edit.

var GlobalEditorVanishingCopyrightManager = Class.createWithSharedInstance('globalEditorVanishingCopyrightManager', true);
GlobalEditorVanishingCopyrightManager.prototype = {
	mParentElement: null,
	initialize: function() {
		// Are we on the server homepage?
		if (!(document.body.hasClassName('sources') && document.body.hasClassName('index'))) return invalidate;
		// Has the homepage been edited?
		if (CC.meta('x-apple-entity-revision') != "1") return invalidate;
		globalNotificationCenter().subscribe(CC.WikiEditor.NOTIFICATION_EDITOR_READY, this._initialize.bind(this));
	},
	_initialize: function() {
		this.mParentElement = this.render();
		this.showCopyright();
		globalNotificationCenter().subscribe(CC.WikiEditor.NOTIFICATION_DID_START_EDITING, this.hideCopyright.bind(this));
		globalNotificationCenter().subscribe(CC.WikiEditor.NOTIFICATION_DID_CANCEL_EDITING, this.showCopyright.bind(this));
		// 9540592
		var heightChangedCallback = function(inElement, inHeight) {
			this.mParentElement.style.minHeight = (inHeight + 44 + 'px'); // 16px +  21px + 7px
		};
		this.mObserver = new CopyrightNoticeHeightObserver($('content'), 1, heightChangedCallback.bind(this));
	},
	render: function() {
		var element = Builder.node('div', {className: 'wikieditor-vanishing-copyright hidden'}, [
			Builder.node('p')
		]);
		element.down('p').innerHTML = "_Editor.Apple.Copyright.Notice".loc();
		$('main').appendChild(element);
		return element;
	},
	hideCopyright: function() {
		document.body.removeClassName('showing-copyright');
		this.mParentElement.addClassName('hidden');
	},
	showCopyright: function() {
		document.body.addClassName('showing-copyright');
		this.mParentElement.removeClassName('hidden');
	}
};
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.

// Smart link popup menu.

CC.WikiEditor.SmartLinkPopup = Class.create(CC.WikiEditor.EditorToolbarPopupMenu, {
	mDefaultLimit: 10,
	render: function() {
		var elem = Builder.node('ul', {className: 'items'}, [
			Builder.node('li', {className: 'item newpage'}, [
				Builder.node('span', {title: "_Editor.Links.Toolbar.Popup.New.Tooltip".loc()}, "_Editor.Links.Toolbar.Popup.New.Title".loc())
			]),
			Builder.node('li', {className: 'item search'}, [
				Builder.node('span', {title: "_Editor.Links.Toolbar.Popup.Search.Tooltip".loc()}, "_Editor.Links.Toolbar.Popup.Search.Title".loc())
			]),
			Builder.node('li', {className: 'item manual'}, [
				Builder.node('span', {title: "_Editor.Links.Toolbar.Popup.Manual.Tooltip".loc()}, "_Editor.Links.Toolbar.Popup.Manual.Title".loc())
			]),
			Builder.node('li', {className: 'item unlink'}, [
				Builder.node('span', {title: "_Editor.Links.Toolbar.Popup.Unlink.Tooltip".loc()}, "_Editor.Links.Toolbar.Popup.Unlink.Title".loc())
			]),
			Builder.node('li', {className: 'recents'}, [
				Builder.node('span', {className: 'header'}, "_Editor.Links.Toolbar.Popup.Recents".loc()),
				Builder.node('ul', {className: 'items empty loading'}, [
					Builder.node('li', {className: 'item placeholder'}, [
						Builder.node('span', "_Editor.Links.Toolbar.Popup.Recents.None.Placeholder".loc())
					])
				])
			])
		]);
		this.drawDialogs();
		return elem;
	},
	registerEventHandlers: function($super) {
		$super.apply(null, Array.prototype.slice.call(arguments, 1));
		bindEventListeners(this, [
			'handleCreateNewPageClicked',
			'handleSearchLinkClicked',
			'handleEnterManualLinkClicked',
			'handleUnlinkClicked'
		]);
		var elem = this.mParentElement;
		Event.observe(elem.down('.item.newpage'), 'click', this.handleCreateNewPageClicked);
		Event.observe(elem.down('.item.search'), 'click', this.handleSearchLinkClicked);
		Event.observe(elem.down('.item.manual'), 'click', this.handleEnterManualLinkClicked);
		Event.observe(elem.down('.item.unlink'), 'click', this.handleUnlinkClicked);
	},
	drawDialogs: function() {
		if ($('add_link_dialog')) Element.remove('add_link_dialog');
		// Draw the manual link dialog.
		dialogManager().drawDialog('add_link_dialog', [
			{label:'_Editor.Links.Dialog.Manual.Label.URL'.loc(), contents: '<input type="text" id="add_link_dialog_url"/>'},
			{label:'_Editor.Links.Dialog.Manual.Label.LinkText'.loc(), contents: '<input type="text" id="add_link_dialog_linktext"/>'}
		], "_Editor.Links.Dialog.Add".loc(), undefined, "_Editor.Links.Dialog.Manual.Title".loc(), "_Editor.Links.Dialog.Cancel".loc());
		var descriptionRow = Builder.node('tr', [
			Builder.node('td', {colSpan: 2, className: 'description'}, "_Editor.Links.Dialog.Manual.Description".loc())
		]);
		Element.insert($('add_link_dialog').down('tbody'), {top: descriptionRow});
		// Draw the link search dialog. Exclude the current page from any results.
		var currentPage = CC.meta('x-apple-entity-guid');
		this.mLinkSearchDialog = new LinkSearchDialog({
			mExcludedGUIDs: [currentPage]
		});
	},
	showNewPageDialog: function(inOptAnchor, inOptPageName, inOptCallback, inOptCancelCallback) {
		var tinyID = globalEditorController().mPage.getRecordPropertyForPath('tinyID');
		var ownerGUID = globalEditorController().mPage.getRecordPropertyForPath('ownerGUID');
		globalPagesController().showNewPageDialog(inOptAnchor, inOptPageName, (tinyID != "serverhome" ? ownerGUID : null), null, inOptCallback, inOptCancelCallback);
	},
	showLinkSearchDialog: function(inOptAnchor, inOptLinkText, inOptCallback, inOptCancelCallback) {
		this.mLinkSearchDialog.show(inOptAnchor, inOptCancelCallback, inOptCallback, inOptLinkText);
	},
	showLinkDialog: function(inOptAnchor, inOptURL, inOptLinkText, inOptCallback, inOptCancelCallback) {
		// On save, fire an optional callback with the url and link text.
		var callback = function() {
			if (!inOptCallback) return;
			var url = $('add_link_dialog_url').value;
			var linkText = $('add_link_dialog_linktext').value;
			if (inOptCallback) inOptCallback(url, linkText);
		}.bind(this);
		// Prepare the dialog.
		$('add_link_dialog_url').value = (inOptURL || '');
		$('add_link_dialog_linktext').value = (inOptLinkText || '');
		// Show the dialog.
		dialogManager().show('add_link_dialog', inOptCancelCallback, callback, inOptAnchor, false, 'add_link_dialog_url', false);
	},
	preparePopup: function(inOptAnchor, inOptURL, inOptLinkText, inOptCallback, inOptCancelCallback) {
		this.mAnchor = inOptAnchor;
		this.mURL = inOptURL;
		this.mLinkText = inOptLinkText;
		this.mCallback = inOptCallback;
		this.mCancelCallback = inOptCancelCallback;
		this.populateRecentItems();
	},
	populateRecentItems: function() {
		var recentsElement = this.$().down('.recents > .items');
		recentsElement.addClassName('loading');
		return server_proxy().recentEntitiesForUserWithLimitAndOptions(this.mDefaultLimit, {}, function(response) {
			var recents = $A(response);
			recentsElement.removeClassName('loading');
			(recents && recents.length > 0) ? recentsElement.removeClassName('empty') : recentsElement.addClassName('empty');
			// Remove any existing recents.
			var recentsItems = recentsElement.select('.item'), recentsItemIdx, recentsItem;
			for (recentsItemIdx = 0; recentsItemIdx < recentsItems.length; recentsItemIdx++) {
				recentsItem = recentsItems[recentsItemIdx];
				if (!recentsItem.hasClassName('placeholder')) Element.remove(recentsItem);
			}
			// Build a recent item per result. Overload the name and title attributes to
			// store link information that we can pass to a callback on click.
			var recentIdx, recent;
			for (recentIdx = 0; recentIdx < recents.length; recentIdx++) {
				recent = recents[recentIdx];
				var elem = Builder.node('li', {className: 'item'}, [
					Builder.node('span', {name: CC.entityURL(recent, true), title: (recent.longName || recent.shortName)}, (recent.longName || recent.shortName))
				]);
				Event.observe(elem, 'click', function(inEvent) {
					this.hide();
					var elem = inEvent.findElement('span');
					if (this.mCallback) this.mCallback(elem.getAttribute('name'), elem.getAttribute('title'));
				}.bind(this));
				Element.insert(recentsElement, {bottom: elem});
			}
		}.bind(this), Prototype.emptyFunction);
	},
	handleCreateNewPageClicked: function(inEvent) {
		this.hide();
		this.showNewPageDialog(this.mAnchor, this.mLinkText, this.mCallback, this.mCancelCallback);
	},
	handleSearchLinkClicked: function(inEvent) {
		this.hide();
		this.showLinkSearchDialog(this.mAnchor, this.mLinkText, this.mCallback, this.mCancelCallback);
	},
	handleEnterManualLinkClicked: function(inEvent) {
		this.hide();
		this.showLinkDialog(this.mAnchor, this.mURL, this.mLinkText, this.mCallback, this.mCancelCallback);
	},
	handleUnlinkClicked: function(inEvent) {
		this.hide();
		// Fire our link callback with empty arguments to remove it.
		if (this.mCallback) this.mCallback();
	}
});
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.











CC.WikiEditor.EDITOR_VERSION = 1.0;
CC.WikiEditor.MINIMUM_SUPPORTED_EDITOR_VERSION = 1.0;
CC.WikiEditor.LOCAL_STORAGE_INDEX_KEY = 'x-apple-wiki-autosaved-index';
CC.WikiEditor.LOCAL_STORAGE_KEY = 'x-apple-wiki-autosaved';

// Fake a global shared instance (so other shared instances can reference the current editor). If you
// want to set globalEditorController, you should set _globalEditorController instead.

var _globalEditorController;
var globalEditorController = function() {
	if (!_globalEditorController) return invalidate;
	return _globalEditorController;
};

// Editor controller responsible for tracking state of the page and its
// editable content and the editing session.

CC.WikiEditor.EditorController = Class.create(CC.Keyboard.Mixins.Responder, {
	mIdentifer: null,
	mDebugMode: false,
	mEditMode: false,
	mEditorViewClass: 'CC.WikiEditor.EditorView',
	mEditorView: null,
	mParentElement: null,
	mToolbarParentElement: null,
	mPageGUID: null,
	mPreviousPageGUID: null, 
	mPage: null,
	mActiveBlock: null,
	mPreviouslyActiveBlock: null,
	mActiveActionToolbar: null,
	mBlockContextualToolbarCache: new Hash(),
	mStore: new CC.Store.BackingStore(),
	mEditingService: new CC.WikiEditor.EditingService(),
	mDoubleReturnTimeout: 200,
	mDoNotFocusScrollTolerance: 150, // px
	mSelecting: false,
	mSelectingAll: false,
	mSelectedBlocks: null,
	mCopyPasteDelegate: null,
	mSelectAllDelegate: null,
	mAutosaveDrafts: true,
	mAutosaveDelay: 60000, // 60 seconds
	mDebugModeAutosaveDelay: 2000, // 2 seconds
	mAutosaveTimer: null,
	mPageSaveRetryCount: 5,
	initialize: function(/* {options} */) {
		return this._initialize.apply(this, arguments);
	},
	// Initializes the editor controller, instantiating any necessary views and registering
	// any event handlers.
	_initialize: function(/* {options} */) {
		// First set an identifer for this editor.
		this.mIdentifer = (new CC.GuidBuilder()).toString();
		if (arguments && arguments.length > 0) Object.extend(this, arguments[0]);
		if (!this.mParentElement) return false;
		// Otherwise render and register any event handlers.
		if (!this.mEditorView) {
			var konstructor = this.mEditorViewClass;
			this.mEditorView = CC.objectInstanceForPropertyPath(konstructor);
			if (!this.mEditorView) throw("Could not initialize main view for editor");
		}
		this.mParentElement.appendChild(this.mEditorView._render());
		// Reposition the editor toolbar at the document root.
		(this.mToolbarParentElement || document.body).appendChild(Element.remove(this.mEditorView.mToolbarView.$()));
		this.toggleDebugMode(this.mDebugMode || false);
		// Configure the editor toolbar.
		this._configureEditorToolbar();
		this._registerEventHandlers();
		// Configure a copy/paste and select-all delegate.
		this.mCopyPasteDelegate = new CC.WikiEditor.CopyPasteDelegate();
		this.mSelectAllDelegate = new CC.WikiEditor.SelectAllDelegate(this);
		// Send the ready notification before we initialize the page.
		globalNotificationCenter().publish(CC.WikiEditor.NOTIFICATION_EDITOR_READY, this);
		// Initialize any content.
		this._initializeInlineContent();
	},
	// Preloads page and block data.
	_initializeInlineContent: function(inOptEntity) {
		// Flush the editor store and any old state.
		this.mStore.purgeStore();
		this.mPage = this.mActiveBlock = this.mPreviouslyActiveBlock = this.mActiveActionToolbar = this.mSelecting = this.mSelectedBlocks = this.mPageSaveRetryCountSoFar = null;
		// Get the page GUID.
		var pageGUID = ((inOptEntity ? inOptEntity.guid : undefined) || this.mPageGUID);
		if (!pageGUID) {
			logger().error("Could not find page GUID to initialize editor. Editor will be temporarily disabled.");
			return false;
		}
		this.mPageGUID = pageGUID;
		var gotPage = function(inPage) {
			this.mEditorView.$().removeClassName('loading');
			// Cache so we can quickly restore later on edit cancel.
			this.mStashedContent = CC.deepClone(inPage);
			// Push the page into the editor store too.
			var pageRecord = inPage;
			pageRecord = this.mStore.pushObject(pageRecord);
			if (!pageRecord) throw("Could not initialize editor for page");
			this.mPage = new CC.WikiEditor.Page({
				'mStore': this.mStore,
				'mRecord': pageRecord
			});
			// Initialize the page title and page views.
			var titleView = this.mEditorView.mTitleView = new CC.EntityTitle.EntityTitleView({'mContent': this.mPage});
			titleView._render();
			var existingTitleView = this.mEditorView.$().down('.cc-entity-title');
			if (existingTitleView) Element.remove(existingTitleView);
			this.mEditorView.$().appendChild(titleView.$());
			var pageView = new CC.WikiEditor.PageView({
				'mContent': this.mPage
			});
			this.mPage.mViewInstance = this.mEditorView.mPageView = pageView;
			pageRecord.mControllerInstance = this.mPage;
			var existingPageView = this.mEditorView.$().down('.page.blocks');
			pageView._render();
			var renderedPageView = pageView.$();
			// Inflated any child blocks for the page first (so we can guarantee ordering).
			var inflatedJSON = this._inflateBlocksForPage(pageRecord);
			// Create any blocks, expanding nested child blocks where needed.
			if (inflatedJSON._childBlocks != undefined) {
				var childBlockIdx, childBlock;
				for (childBlockIdx = 0; childBlockIdx < pageRecord._childBlocks.length; childBlockIdx++) {
					childBlock = pageRecord._childBlocks[childBlockIdx];
					this.bulkAddBlock(childBlock, {'bottom': renderedPageView}, undefined, true, false);
				}
				// 10473966
				// Append the new page view and remove the previous one.
				this.mEditorView.$().appendChild(renderedPageView);
				if (existingPageView) Element.remove(existingPageView);
			}
			// Trigger a page changed notification.
			globalNotificationCenter().publish(CC.WikiEditor.NOTIFICATION_PAGE_DID_CHANGE, this.mPage);
			globalNotificationCenter().publish(CC.EntityTitle.NOTIFICATION_TITLE_SHOULD_UPDATE, this.mPage);
			// Trigger a routes change now we've rendered the page.
			globalNotificationCenter().publish(CC.Routes.NOTIFICATION_ROUTES_SHOULD_UPDATE, undefined, {'rootElement': this.mEditorView.mPageView.$()});
			// Migrate the page if we need to.
			var needToMigrate = this.mPage.getRecordPropertyForPath('extendedAttributes.migrated');
			if (needToMigrate) this.migratePage();
			// Update pre-seed pages if we need to.
			var version = this.mPage.getRecordPropertyForPath("extendedAttributes.editorVersion");
			if ((version == undefined) || (version < CC.WikiEditor.MINIMUM_SUPPORTED_EDITOR_VERSION)) this._updatePreSeedPageSchema();
			// Do we have unsaved changes?
			if (this.mAutosaveDrafts) this.restoreAutosavedEdits();
			// Should we start in edit mode?
			if (globalCookieManager().getCookie('cc.toggleEditModeOnLoad')) {
				globalCookieManager().destroyCookie('cc.toggleEditModeOnLoad');
				setTimeout(function() {
					this.toggleEditMode(true, true);
				}.bind(this), 500);
			}
			this.becomeFirstResponder();
			globalNotificationCenter().publish(CC.WikiEditor.NOTIFICATION_PAGE_WAS_INITIALIZED, this);
			return true;
		}.bind(this);
		// Do we have the page already?
		var existingPageEntity = server_proxy().objectFromStoreWithGUID(pageGUID);
		if (existingPageEntity) {
			gotPage(existingPageEntity);
			return true;
		}
		// Otherwise fetch it.
		server_proxy().entityForGUIDWithOptions(pageGUID, {'subpropertyPaths': server_proxy().mDefaultSubpropertyPaths}, gotPage, function() {
			logger().error("Could not fetch page for GUID %@ to initialize editor. Editor will be temporarily disabled.".fmt(pageGUID));
			return false;
		});
		// Trigger a service_client flush so we wait for as little time as possible on a page.
		service_client().flushQueuedServiceRequests();
		this.mEditorView.$().addClassName('loading');
	},
	// Given a page from the server, returns a tree-representation with child blocks positioned under
	// their container block. Ensures parent blocks are added before child blocks on the page, and also
	// allows us to know exactly when every child of a container has been added to that container.
	_inflateBlocksForPage: function(inPage) {
		if (!inPage) return;
		var pageExtendedAttributes = (inPage['extendedAttributes'] || {});
		var pageBlocks = $H(pageExtendedAttributes['_blocks'] || {});
		// Blocks are grouped by blockType for each page. Remove that grouping.
		var _pageBlocks = new Object();
		var _pageBlocksValues = pageBlocks.values(), _pageBlocksValuesIdx, _pageBlocksValue;
		for (_pageBlocksValuesIdx = 0; _pageBlocksValuesIdx < _pageBlocksValues.length; _pageBlocksValuesIdx++) {
			_pageBlocksValue = _pageBlocksValues[_pageBlocksValuesIdx];
			Object.extend(_pageBlocks, _pageBlocksValue);
		}
		var __inflateBlocksForParent = function(parent, recursiveParent) {
			var currentParent = (recursiveParent || parent);
			var parentExtendedAttributes = (currentParent['extendedAttributes'] || {});
			var parentBlockGUIDs = (parentExtendedAttributes['blockGUIDs'] || []), parentBlockGUID, parentInflatedChildren;
			if (!currentParent._childBlocks) currentParent._childBlocks = [];
			for (var parentBlockGUIDIdx = 0; parentBlockGUIDIdx < parentBlockGUIDs.length; parentBlockGUIDIdx++) {
				parentBlockGUID = parentBlockGUIDs[parentBlockGUIDIdx];
				if (_pageBlocks[parentBlockGUID]) {
					parentInflatedChildren = __inflateBlocksForParent(parent, _pageBlocks[parentBlockGUID]);
					currentParent._childBlocks.push(parentInflatedChildren);
				}
			}
			return currentParent;
		}
		var inflated = __inflateBlocksForParent(inPage);
		delete _pageBlocks;
		return inflated;
	},
	// Starts editing. Verifies the current revision of the page before editing offering to reload first.
	// Toggles the current editing state of the editor. Accepts an optional
	// boolean argument as the target editing state for the editor.
	toggleEditMode: function(inOptEditModeEnabled, inOptDoNotCheckForNewerVersion, inOptPageSaveErrorCondition) {
		if (!this.mParentElement) return false;
		// Are we entering or exiting edit mode?
		var editMode = (inOptEditModeEnabled != undefined) ? (inOptEditModeEnabled || false) : !this.mEditMode;
		var root = document.body.up('html') || document.body;
		// If we're already in edit mode, stop editing and leave edit mode.
		if (!editMode) {
			root.removeClassName('editing');
			globalRouteHandler().setRoutePrefireCallback(this.mStashedRoutePrefireCallback);
			this.mEditMode = this.mEditorView.mTitleView.mEditable = false;
			this.stopEditing(true);
			if (this.mAutosaveTimer) {
				clearInterval(this.mAutosaveTimer);
				this.mAutosaveTimer = null;
				this.flushAutosavedChanges(this.mPage.getRecordPropertyForPath('guid'));
			}
			globalNotificationCenter().publish(CC.WikiEditor.NOTIFICATION_DID_FINISH_EDITING, this.mPage);
			return this.mEditMode;
		}
		// 9246551
		// Edit the page immediately. Unless inOptDoNotCheckForNewerVersion has been passed, also check that
		// the page has not been edited and saved since the editor was a initialized. If the page is deemed
		// to be out-of-date, warn the user and offer to reload the page (automatically toggling edit mode on
		// refresh).
		dialogManager().hide();
		root.addClassName('editing');
		// If we're using routes, register a prefire callback.
		this.mStashedRoutePrefireCallback = globalRouteHandler().mRoutePrefireCallback;
		globalRouteHandler().setRoutePrefireCallback(function() {
			// Disable routes in edit mode.
			if (this.mEditMode) return false;
			// 11469918
			if (browser().isiOS5Plus()) return confirm("_Editor.Unload.Full.Warning".loc());
			return true;
		}.bind(this));
		// Make sure there is always at least one block on the page.
		if (this.mPage.mBlocks.size() == 0) {
			var prediction = this.predictNextBlock();
			this.addBlock(prediction.blockType, {'extendedAttributes': prediction.attributes}, false);
		}
		// Publish a notification.
		globalNotificationCenter().publish(CC.WikiEditor.NOTIFICATION_DID_START_EDITING, this.mPage);
		// We're now in edit mode.
		this.mEditMode = this.mEditorView.mTitleView.mEditable = true;
		// Start editing the first block.
		this.startEditing(this.mPage.firstBlock(), {moveToStart: true});
		// Start autosaving.
		if (this.mAutosaveDrafts && browserSupportsLocalStorage()) {
			this.mAutosaveTimer = setTimeout(this.autosavePage.bind(this), (this.mDebugMode ? this.mDebugModeAutosaveDelay : this.mAutosaveDelay));
		}
		// 8533718
		if (browser().isFirefox()) {
			document.execCommand("enableInlineTableEditing", false, false);
			document.execCommand("enableObjectResizing", false, false);
		}
		// Check that the user is logged in in the background (<rdar://problem/14179604>)
		var oldStatus = CC.meta('x-apple-user-can-write');
		server_proxy().refreshMetaTags(function() {
			if (CC.meta('x-apple-user-can-write') !== 'true' && oldStatus === 'true') {
				// suppress the polite login prompt, we're in edit mode
				setTimeout(function(){
					(sharedHeaderView && sharedHeaderView.mPoliteLoginPrompt && sharedHeaderView.mPoliteLoginPrompt.hidePoliteLoginPrompt(true));
				}, 0);
				
				if ( browser().isiPhone() ) {
					var currentURL = window.location;
					window.location = "/auth?send_token=no&redirect="+currentURL;
					return;
				}

				// ask the user to relogin
				authenticator().displayFramedLoginPrompt(function() {
					if (inOptPageSaveErrorCondition) {
						// try a re-save now
						this.savePage();
					}
				}.bind(this), function() {
					if (!inOptPageSaveErrorCondition) {
						this.toggleEditMode(false, true);
						(sharedHeaderView && sharedHeaderView.mPoliteLoginPrompt && sharedHeaderView.mPoliteLoginPrompt.updateDisplayState());
					}
				}.bind(this), (inOptPageSaveErrorCondition) ? "_Editor.Notifications.Page.Saved.LoginError".loc() : "_Editor.Notifications.Page.Edit.LoginError".loc());
				return;
			} else if (inOptPageSaveErrorCondition) {
				notifier().printErrorMessage("_Editor.Notifications.Page.Saved.Error".loc());
			}
			
			if (!inOptDoNotCheckForNewerVersion) {
				var gotStalePage = function() {
					if (confirm("_Editor.Conflict.Edit.Outdated".loc())) {
						globalCookieManager().setCookie('cc.toggleEditModeOnLoad', true);
						window.onbeforeunload = Prototype.emptyFunction;
						window.location.reload();
					}
				};
				this.mEditingService.checkServerForEdits(gotStalePage, Prototype.emptyFunction);
			}
		}.bind(this), Prototype.emptyFunction);
	},
	toggleDebugMode: function(inDebugModeEnabled) {
		this.mDebugMode = (inDebugModeEnabled != undefined) ? (inDebugModeEnabled || false) : !this.mDebugMode;
		var root = document.body.up('html') || document.body;
		this.mDebugMode ? root.addClassName('wikieditor-debugmode') : root.removeClassName('wikieditor-debugmode');
		if (inDebugModeEnabled) logger().setLogLevel(CC.Logger.LOG_LEVEL_DEBUG);
		globalNotificationCenter().publish(CC.WikiEditor.NOTIFICATION_EDITOR_DID_TOGGLE_DEBUG_MODE, this);
	},
	// Migrates a pre-Lion wiki page to the new editor architecture.
	migratePage: function() {
		dialogManager().showProgressMessage("_Editor.Migration.Progress.Migrating".loc());
		// Get the first child block on the page.
		var firstSandboxBlockView = this.mEditorView.$('.block.sandbox');
		var firstSandboxBlockGUID = firstSandboxBlockView.getAttribute('data-guid');
		if (!firstSandboxBlockGUID) return (inOptCallback ? inOptCallback() : undefined);
		var firstSandboxBlock = this.mPage.mBlocks.get(firstSandboxBlockGUID);
		if (!firstSandboxBlock) return (inOptCallback ? inOptCallback() : undefined);
		var markup = firstSandboxBlock.getRecordPropertyForPath('extendedAttributes.markup');
		var migrated = globalEditorMigrationController().migrate(markup);
		if (migrated) {
			// Update the page chrome before adding any migrated blocks.
			this.mEditorView.$('.page.blocks').removeClassName('migrated');
			// Add a text block before the sandbox we just migrated.
			var newTextBlock = this.addBlock('text', undefined, false, {'before': firstSandboxBlockView}, this.mPage);
			var fragment = textBlockDelegate().buildFragmentForBulkAddMigratedResultToBlock(migrated, newTextBlock, this);
			newTextBlock.mViewInstance._editable.appendChild(fragment);
			// Hide the original sandbox block view.
			firstSandboxBlockView.hide();
			// Remove the unwanted sandbox.
			this.removeBlock(firstSandboxBlock, true);
			// Update the page model.
			this.mPage.setRecordPropertyForPath('extendedAttributes.migrated', false);
			this.mPage.setRecordPropertyForPath('extendedAttributes.editorVersion', CC.WikiEditor.EDITOR_VERSION);
			globalNotificationCenter().publish(CC.WikiEditor.NOTIFICATION_PAGE_DID_MIGRATE, this.mPage);
		}
		// Hide the migration progress message.
		dialogManager().hideProgressMessage();
		return true;
	},
	// 9261334
	_updatePreSeedPageSchema: function() {
		logger().debug("_updatePreSeedPageSchema: %o (editorVersion: %o)", this.mPage, this.mPage.getRecordPropertyForPath('extendedAttributes.editorVersion'));
		// Text blocks become block containers by recursively expanding page into a root-level
		// text block, and any table cells into nested text blocks. As we expand into a container
		// block, text blocks at that level are collapsed together as their markup is concatenated.
		var promoteBlocksInsideElementIntoTextBlock = function(element, rootTextBlock) {
			var rootTextBlockGUID = rootTextBlock.getRecordPropertyForPath('guid');
			var rootTextBlockElement = rootTextBlock.mViewInstance.$('.editable');
			var blockViews = element.select('.block'), nestedBlockViews = element.select('.block .block');
			var topLevelBlockGUIDs = stringArrayDifference(blockViews.invoke('getAttribute', 'data-guid'), nestedBlockViews.invoke('getAttribute', 'data-guid'));
			// Don't promote the new root text block inside itself.
			topLevelBlockGUIDs = topLevelBlockGUIDs.without(rootTextBlockGUID);
			var topLevelBlockGUIDIdx, topLevelBlockGUID, topLevelBlock, topLevelBlockViewElement, topLevelBlockAttrs;
			var targetElement, newTargetElement, tagname, alignment, _editable;
			for (topLevelBlockGUIDIdx = 0; topLevelBlockGUIDIdx < topLevelBlockGUIDs.length; topLevelBlockGUIDIdx++) {
				topLevelBlockGUID = topLevelBlockGUIDs[topLevelBlockGUIDIdx];
				topLevelBlock = this.blockForBlock(topLevelBlockGUID);
				topLevelBlockViewElement = topLevelBlock.mViewInstance.mParentElement;
				topLevelBlockAttrs = topLevelBlock.getRecordPropertyForPath('extendedAttributes');
				// Is the child a text block?
				if (CC.kindOf(topLevelBlock, CC.WikiEditor.TextBlock)) {
					targetElement = rootTextBlockElement.appendChild(document.createElement('div')), newTargetElement = null;
					tagName = (topLevelBlockAttrs.tagName || 'p'), alignment = topLevelBlockAttrs.alignment;
					// Preserve block-level formatting and alignment settings.
					if (tagName == 'blockquote') {
						newTargetElement = targetElement.appendChild(Builder.node('blockquote', {className: 'quote'}));
					} else {
						if (!tagName && rootTextBlock.getRecordPropertyForPath('blockType') != 'table') tagName = 'p';
						if (tagName) newTargetElement = targetElement.appendChild(document.createElement(tagName));
					}
					if (alignment && alignment != 'left') {
						targetElement = targetElement.appendChild(Builder.node('span', {className: "align-%@".fmt(alignment)}));
						if (newTargetElement) targetElement = targetElement.appendChild(Element.remove(newTargetElement));
					} else {
						if (newTargetElement) targetElement = newTargetElement;
					}
					// Push the block content into the new root text block. We relocate DOM nodes
					// here to preserve text-node whitespace.
					_editable = topLevelBlockViewElement.down('.editable');
					while (_editable.hasChildNodes()) {
						targetElement.appendChild(_editable.removeChild(_editable.firstChild));
					}
					// Remove the original text block since we no longer need it.
					this.removeBlock(topLevelBlock, true);
					continue;
				}
				// Otherwise, relocate the block view to its new home and update the block instance.
				rootTextBlockElement.appendChild(Element.remove(topLevelBlockViewElement));
				topLevelBlock.mParentContainer = rootTextBlock;
				topLevelBlock.setRecordPropertyForPath('extendedAttributes.containerGUID', rootTextBlockGUID);
				rootTextBlock.mBlocks.set(topLevelBlockGUID, topLevelBlock);
				rootTextBlock.handleBlocksDidChange();
			}
		}.bind(this);
		// Start bottom-up, promoting blocks inside every table cell.
		var blocksView = this.mEditorView.$('.page.blocks');
		var _block, tableBlocks = blocksView.select('.block.table'), tableBlockIdx, table;
		var tableBlockGUID, tableBlock, tableBlockCells, tableBlockCellIdx, tableBlockCell;
		for (tableBlockIdx = 0; tableBlockIdx < tableBlocks.length; tableBlockIdx++) {
			table = tableBlocks[tableBlockIdx];
			tableBlockGUID = table.getAttribute('data-guid');
			tableBlock = this.blockForBlock(tableBlockGUID);
			tableBlockCells = table.select('td.cell');
			for (tableBlockCellIdx = 0; tableBlockCellIdx < tableBlockCells.length; tableBlockCellIdx++) {
				tableBlockCell = tableBlockCells[tableBlockCellIdx];
				// Does this cell have anything inside we need to migrate?
				if (tableBlockCell.select('.block')) {
					_block = this.addBlock('text', {}, false, {'bottom': tableBlockCell}, tableBlock, false, false);
					promoteBlocksInsideElementIntoTextBlock(tableBlockCell, _block);
				}
			}
		}
		// Move all top-level blocks inside a new root text block.
		_block = this.addBlock('text', {}, false, undefined, this.mPage, false, false);
		promoteBlocksInsideElementIntoTextBlock(blocksView, _block);
		// Update the editor version for the page.
		this.mPage.setRecordPropertyForPath('extendedAttributes.editorVersion', CC.WikiEditor.EDITOR_VERSION);
		return true;
	},
	// Restores any autosaved edits.
	restoreAutosavedEdits: function() {
		var pageGUID = this.mPage.mRecord.guid;
		if (!pageGUID) return false;
		// Read any cached changes from local storage.
		var autosaved;
		if (browserSupportsLocalStorage()) {
			autosaved = window.localStorage.getItem("%@-%@".fmt(CC.WikiEditor.LOCAL_STORAGE_KEY, pageGUID)) || '{}';
		}
		// Do we have autosaved changes?
		if (!autosaved) return false;
		autosaved = autosaved.evalJSON(true);
		// If we have autosaved changes for a conflicting page revision, discard them.
		var pageRevision = this.mPage.mRecord.revision;
		if (autosaved['revision'] != pageRevision) {
			logger().debug("Autosaved changes will be discarded (page revision conflict).");
			this.flushAutosavedChanges(pageGUID);
			return false;
		}
		if (!this.mAutosaveDialog) {
			this.mAutosaveDialog = dialogManager().drawDialog('restore_autosaved_edits_dialog', [
				"_Editor.Autosave.Restore.Unsaved.Changes.Dialog.Description".loc()
			], "_Editor.Autosave.Restore.Unsaved.Changes.Dialog.OK".loc(), false, "_Editor.Autosave.Restore.Unsaved.Changes.Dialog.Title".loc());
		}
		var discardCallback = function() {
			this.flushAutosavedChanges(pageGUID);
			dialogManager().hide();
		};
		var restoreCallback = function() {
			this._restoreAutosavedEdits(autosaved['payload']);
			this.toggleEditMode(true, true);
			dialogManager().hide();
		};
		dialogManager().show(this.mAutosaveDialog, discardCallback.bind(this), restoreCallback.bind(this));
	},
	// Restores a set of autosaved edits for a given presave payload.
	_restoreAutosavedEdits: function(inPayload) {
		var payload = (inPayload || []);
		// Start with the stashed content for the page we just rendered. Iterate over each of the changesets in the save
		// payload and merge to the stashed page structure.
		var stashedContent = this.mStashedContent, payloadEntry, payloadHash;
		for (var pdx = 0; pdx < payload.length; pdx++) {
			payloadEntry = payload[pdx];
			payloadHash = {};
			payloadHash[payloadEntry[0]] = payloadEntry[1];
			Object.extend(stashedContent, payloadHash);
		}
		// Reinitialize the page.
		this._initializeInlineContent(stashedContent);
	},
	// Adds a new block to the editor. Accepts a block identifier and an optional set of properties to be applied
	// to the block model. Can optionally be activated after creation, and added at an optional position. If inOptAddQuietly
	// is unspecified or false, the block will be created on the server on first save, otherwise, it is assumed the block
	// already exists on the server (we will generate changesets from now on). Also accepts an inOptWorkingElement
	// argument where this block is being rendered in an offscreen tree or fragment.
	addBlock: function(inBlockIdentifer, inOptBlockProperties, inOptActivateAfterCreating, inOptPosition, inOptContainer, inOptAddQuietly, inOptDoNotTriggerContainerChanges, inOptWorkingElement) {
		if (!inBlockIdentifer) return false;
		// Ensure we're adding a block type we know about.
		if (!globalEditorBlockPluginRegistry()._isBlockTypeRegistered(inBlockIdentifer)) {
			logger().error("Tried to add unknown block (%@) to editor".fmt(inBlockIdentifer));
			return false;
		}
		// Create and add the block record to the editor store.
		var blockProperties = {'blockType': inBlockIdentifer};
		if (inOptBlockProperties) Object.extend(blockProperties, inOptBlockProperties);
		// If we didn't get an explicit container, find the nearest container.
		var container = inOptContainer;
		if (!container && (this.mActiveBlock && this.mActiveBlock.mIsContainer)) container = this.mActiveBlock;
		if (!container) {
			// Try and insert the block in neareset parent text block to the active block.
			if (this.mActiveBlock) {
				var nearestTextBlock = this.mActiveBlock.mViewInstance.$().up('.block');
				if (nearestTextBlock.hasClassName('text')) {
					container = this.blockForBlock(nearestTextBlock);
					if (container) inOptPosition = {'after': this.mActiveBlock.mViewInstance.$()};
				}
			}
		}
		if (!container) container = this.mPage
		// Track the container dependency for this block.
		extendedAttributes = blockProperties['extendedAttributes'] || {};
		extendedAttributes['containerGUID'] = container.getRecordPropertyForPath('guid');
		blockProperties['extendedAttributes'] = extendedAttributes;
		// Create the new block.
		var block = new CC.WikiEditor.BlockModel(blockProperties);
		block = this.mStore.pushObject(block);
		// Push a bulk changeset for a new block.
		if (!inOptAddQuietly) {
			var changesetAttributes = block.changesetAttributes(), changesetAttributeIdx, attr;
			for (changesetAttributeIdx = 0; changesetAttributeIdx < changesetAttributes.length; changesetAttributeIdx++) {
				attr = changesetAttributes[changesetAttributeIdx];
				this.mStore.pushChangeForObject(block, attr, block[attr]);
			}
		}
		// Look up the correct controller in the block plugin registry and wrap the block.
		var konstructor = globalEditorBlockPluginRegistry().blockControllerForType(inBlockIdentifer);
		if (!konstructor) throw("Could not find constructor for known block type (%@)".fmt(inBlockIdentifer));
		var controller = new konstructor({
			'mStore': this.mStore,
			'mRecord': block,
			'mParentContainer': container
		});
		// Instantiate a view for the block.
		konstructor = CC.objectForPropertyPath(controller.mBlockView) || CC.WikiEditor.BlockView;
		var view = new konstructor({
			'mContent': controller
		});
		if (!view) throw("Could not initialize view (%@) for block (%@)".fmt(view, controller));
		// Prime the view and glue the view and the controller.
		controller.mViewInstance = view;
		// Glue the record and the controller.
		block.mControllerInstance = controller
		// Stash away the currently active block.
		var previouslyActiveBlock = this.mActiveBlock;
		// Add the block.
		if (!container && !inOptPosition && previouslyActiveBlock) {
			var blockView = previouslyActiveBlock.mViewInstance;
			container = previouslyActiveBlock.mParentContainer;
			inOptPosition = {'after': blockView};
			// If we don't have a position, and we have an active text block, split the text
			// block and place the file between the result of the split.
			if (previouslyActiveBlock.mSupportsNavigation) {
				if (previouslyActiveBlock.focusedAtStart()) {
					inOptPosition = {'before': blockView};
				} else if (previouslyActiveBlock.focusedAtEnd()) {
					inOptPosition = {'after': blockView};
				}
			}
		}
		var newBlock = container.addBlock(controller, inOptPosition, inOptAddQuietly, inOptDoNotTriggerContainerChanges, inOptWorkingElement);
		// Optionally start editing.
		if (inOptActivateAfterCreating) this.startEditing(newBlock, {moveToStart: true});
		return newBlock;
	},
	// Bulk support for adding a block tree to the page. Here, blocks are represented in JSON
	// format with any sub-blocks of a parent container block provided in an ordered array of
	// a _childBlocks JSON hash parameter. Called when batch-adding a page representation from
	// the server, after a page migration or a copy/paste migration.
	bulkAddBlock: function(inBlockToExpand, inOptPosition, inOptContainer, inOptAddQuietly, inOptWorkingElement) {
		var result = [], fragment, fragmentChild, stashedPosition;
		// If we're bulk-appending at a DOM position, use a fragment for performance.
		if (inOptPosition) {
			fragment = document.createDocumentFragment();
			stashedPosition = inOptPosition;
			inOptPosition = {'bottom': fragment};
		}
		this._bulkAddBlock(result, inBlockToExpand, inOptPosition, inOptContainer, inOptAddQuietly, inOptWorkingElement);
		// Append the fragment to the DOM.
		if (stashedPosition) {
			for (var key in stashedPosition) {
				var value = stashedPosition[key];
				var position = {};
				position[key] = fragment;
				fragmentSafeElementInsert(value, position);
				break;
			}
		}
		if (!inOptAddQuietly) {
			var parent = (inOptContainer || this.mPage);
			if (parent) parent.handleBlocksDidChange();
		}
		return result;
	},
	_bulkAddBlock: function(inWorkingArray, inBlockToExpand, inOptPosition, inOptContainer, inOptAddQuietly, inOptWorkingElement) {
		if (!inBlockToExpand) return false;
		var _childBlocks, parentBlock, childBlockIdx, childBlock;
		_childBlocks = inBlockToExpand._childBlocks;
		parentBlock = this.addBlock(inBlockToExpand.blockType, inBlockToExpand, false, inOptPosition, inOptContainer, inOptAddQuietly, true, inOptWorkingElement);
		inWorkingArray.push(parentBlock);
		// Do we have anything to expand?
		if (_childBlocks && _childBlocks.length > 0) {
			for (childBlockIdx = 0; childBlockIdx < _childBlocks.length; childBlockIdx++) {
				childBlock = _childBlocks[childBlockIdx];
				this._bulkAddBlock(inWorkingArray, childBlock, undefined, parentBlock, inOptAddQuietly, false, parentBlock.mViewInstance.$());
			}
			parentBlock.handleBlocksDidChange({'quietly': inOptAddQuietly});
		}
	},
	// Removes an existing block from the editor. Mostly delegates the remove
	// behavior to the page or parent container for a given block to be removed.
	removeBlock: function(inBlock, inOptControlledExplosion) {
		if (!CC.kindOf(inBlock, CC.WikiEditor.Block)) return false;
		if (inBlock == this.mActiveBlock) this.stopEditing(true);
		var previousBlock = this.findPreviousBlock(inBlock);
		var parent = inBlock.mParentContainer ? inBlock.mParentContainer : this.mPage;
		parent.removeBlock(inBlock, inOptControlledExplosion);
		// Purge the block from the store.
		this.mStore.purgeGUID(inBlock.getRecordPropertyForPath('guid'));
		// Delete the block.
		delete inBlock;
		// Always enforce at least one text block on a page.
		if (this.mPage.mBlocks.size() == 0) {
			var prediction = this.predictNextBlock();
			previousBlock = this.addBlock(prediction.blockType, {'extendedAttributes': prediction.attributes});
		}
		// If we have a previous block, activate it.
		if (previousBlock) this.startEditing(previousBlock, {'moveToEnd': true});
	},
	// Batch remove an array of blocks from the editor.
	removeBlocks: function(inBlocks, inOptControlledExplosion) {
		if (!inBlocks) return false;
		var blocks = $A(inBlocks), blockIdx, block;
		for (blockIdx = (blocks.length - 1); blockIdx >= 0; blockIdx--) {
			block - blocks[blockIdx];
			if (!CC.kindOf(block, CC.WikiEditor.Block)) return;
			this.removeBlock(block, inOptControlledExplosion);
		}
	},
	// Batch removes all blocks from the editor (faster than iterating over all blocks
	// and calling removeBlock individually). Bypasses previous block activation and
	// notification propagation.
	fastRemoveAllBlocks: function() {
		// If we have an active block (we should) stop editing.
		this.stopEditing(true);
		// Collect all the blocks on the page and purge them from the store.
		var allBlocks = this.mPage.mBlocks.values(), block;
		for (var allBlocksIdx = 0; allBlocksIdx < allBlocks.length; allBlocksIdx++) {
			block = allBlocks[allBlocksIdx];
			this.mStore.purgeGUID(block.getRecordPropertyForPath('guid'));
		}
		// Fast-update the page view.
		this.mEditorView.mPageView.$().innerHTML = "";
		this.mPage.mBlocks = new Hash();
		// Enforce at least one block on the page.
		var prediction = this.predictNextBlock();
		var newBlock = this.addBlock(prediction.blockType, {'extendedAttributes': prediction.attributes});
		this.startEditing(newBlock, {'moveToStart': true}, true);
	},
	// Returns the block controller for a given DOM element or block GUID, if it exists.
	// Returns undefined otherwise.
	blockForBlock: function(inOptBlockElement) {
		if (!inOptBlockElement) return undefined;
		var blockGUID, workingCopy, element;
		if (CC.typeOf(inOptBlockElement) == CC.T_STRING) {
			blockGUID = inOptBlockElement;
		} else {
			element = $(inOptBlockElement);
			if (element) blockGUID = element.getAttribute('data-guid');
		}
		workingCopy = this.mStore.workingCopyForGUID(blockGUID);
		return (workingCopy && workingCopy.mControllerInstance);
	},
	// Starts editing a given block. Accepts an arbitary hash of activation information.
	// If startEditing is called on the currently active block, we resume editing that
	// block (which may or not have any effect).
	startEditing: function(inBlock, inOptActivationInfo, inOptForceActivate) {
		if (!this.mEditMode) return false;
		if (!inBlock || !CC.kindOf(inBlock, CC.WikiEditor.Block)) return false;
		// Bail if the block is locked or if the block is refusing to be editable.
		if (!inBlock.isEditable() || inBlock.isLocked()) return false;
		// Do we have an existing active block or is inBlock already the active block?
		var currentlyActiveBlock = this.mActiveBlock;
		if (inBlock != currentlyActiveBlock || inOptForceActivate) {
			// Stop editing the previous active block.
			this.stopEditing(true);
			// Mark the new block as being active.
			this.mActiveBlock = inBlock;
			// 10473966
			// Only focus the new block if we're not scrolled.
			var main = $('main');
			if (main) {
				var scrollTop = main.scrollTop;
				if (scrollTop > this.mDoNotFocusScrollTolerance) {
					inOptActivationInfo['focus'] = false;
				}
			}
			this.mActiveBlock.handleDidStartEditing(inOptActivationInfo);
			this._propagateCallbackForContainers(this.mActiveBlock, 'handleDidStartEditing');
		} else {
			// Resume editing the already active block.
			this.mActiveBlock.handleDidResumeEditing(inOptActivationInfo);
			this._propagateCallbackForContainers(this.mActiveBlock, 'handleDidResumeEditing');
		}
		// Reconfigure the editor toolbar.
		this.reconfigureEditorToolbar(this.mActiveBlock);
		return true;
	},
	// Resumes editing a given block. Called after this block has lost focus.
	resumeEditing: function(inBlock, inOptActivationInfo) {
		if (!this.mEditMode || !this.mActiveBlock || !inBlock || !CC.kindOf(inBlock, CC.WikiEditor.Block)) return false;
		if (this.mActiveBlock != inBlock) return false;
		this.reconfigureEditorToolbar();
		this.mActiveBlock.handleDidResumeEditing(inOptActivationInfo);
		this._propagateCallbackForContainers(this.mActiveBlock, 'handleDidResumeEditing');
		return true;
	},
	// Stops editing the active block (if it exists).
	stopEditing: function(inOptStayInEditMode, inOptDeactivationInfo) {
		if (!this.mActiveBlock) return false;
		// Stash the active block in case we change our mind.
		var activeBlock = this.mActiveBlock;
		this.mPreviouslyActiveBlock = activeBlock;
		this.mActiveBlock.handleDidStopEditing(inOptDeactivationInfo);
		this._propagateCallbackForContainers(this.mActiveBlock, 'handleDidStopEditing');
		this.mActiveBlock = null;
		if (!inOptStayInEditMode) this.toggleEditMode(false);
		this.reconfigureEditorToolbar();
		return true;
	},
	// Helper method that propagates callback functions to the parents of a container.
	_propagateCallbackForContainers: function(inBlock, inCallbackName) {
		if (!inBlock || !CC.kindOf(inBlock, CC.WikiEditor.Block)) return false;
		var container = inBlock.mParentContainer, callback;
		while (container && CC.kindOf(container, CC.WikiEditor.Block)) {
			callback = container[inCallbackName];
			if (callback) callback.apply(container, [{'propagated': true}]);
			container = container.mParentContainer;
		}
	},
	// Finds the next/previous block to a reference block determined by the closed block view
	// element in the DOM.
	findNextBlock: function(inOptBlock, inSearchBackwards) {
		if (!inOptBlock || !CC.kindOf(inOptBlock, CC.WikiEditor.Block)) return undefined;
		if (!inOptBlock.mViewInstance) return inOptBlock;
		var nextBlockElement = inOptBlock.mViewInstance.mParentElement[inSearchBackwards ? 'previous' : 'next']('.block');
		if (!nextBlockElement) return undefined;
		var nextBlockGUID = nextBlockElement.getAttribute('data-guid');
		var workingCopy = this.mStore._workingCopies.get(nextBlockGUID);
		return (workingCopy && workingCopy.mControllerInstance);
	},
	// Finds the previous page-level block controller.
	findPreviousBlock: function(inOptBlock) {
		return this.findNextBlock(inOptBlock, true);
	},
	// Prepares a page for saving.
	prepareToSavePage: function() {
		// Detect and fix any missing blocks.
		this.detectAndFixMissingBlocks();
		// Publish a page will save notification so any blocks can flush any state before saving.
		globalNotificationCenter().publish(CC.WikiEditor.NOTIFICATION_WILL_SAVE_PAGE, this.mPage);
		// Update any extended attributes of the page.
		var store = this.mStore;
		var locale = globalLocalizationManager().getLprojLocale();
		var blockDependencyGUIDs = this._getBlockDependencyGUIDs(true);
		var renderedPageProperties = this._getRenderedPageProperties();
		store.pushChangeForObject(this.mPage.mRecord, 'extendedAttributes.renderedPage', renderedPageProperties[0]);
		store.pushChangeForObject(this.mPage.mRecord, 'extendedAttributes.pageTextValue', renderedPageProperties[1]);
		store.pushChangeForObject(this.mPage.mRecord, 'extendedAttributes.blockDependencyGUIDs', blockDependencyGUIDs);
		store.pushChangeForObject(this.mPage.mRecord, 'extendedAttributes.locale', locale);
		// Flush any deferred store changes (in reverse block dependency order) into the store before saving.
		var blockDependencyIdx, blockDependencyGUID;
		for (blockDependencyIdx = (blockDependencyGUIDs.length - 1); blockDependencyIdx >= 0; blockDependencyIdx--) {
			blockDependencyGUID = blockDependencyGUIDs[blockDependencyIdx];
			store.calculateDeferredChangesForGUID(blockDependencyGUID);
		}
	},
	// Creates a page save payload used by savePage.
	presavePage: function() {
		this.prepareToSavePage();
		// Create a payload with the new block object graph. Blocks are saved in a hash first keyed
		// by block type, then keyed by block GUID.
		var store = this.mStore;
		var pageGUID = this.mPage.getRecordPropertyForPath('guid');
		var payload = store.buildChangesetForObjectWithGUID(pageGUID);
		var _blocks = {};
		var registeredBlockTypes = globalEditorBlockPluginRegistry().registeredBlocks(), registeredBlockType;
		for (var registeredBlockTypesIdx = 0; registeredBlockTypesIdx < registeredBlockTypes.length; registeredBlockTypesIdx++) {
			registeredBlockType = registeredBlockTypes[registeredBlockTypesIdx];
			_blocks[registeredBlockType] = {};
		}
		var blockDependencyGUIDs = this._getBlockDependencyGUIDs(), blockDependencyIdx, blockGUID, blockType;
		for (blockDependencyIdx = 0; blockDependencyIdx < blockDependencyGUIDs.length; blockDependencyIdx++) {
			blockGUID = blockDependencyGUIDs[blockDependencyIdx];
			block = store.workingCopyForGUID(blockGUID);
			blockType = (block.blockType || "unknown");
			_blocks[blockType][blockGUID] = store.workingCopyForGUID(blockGUID).serialize();
		}
		// Find the extendedAttributes changeset entry for the page, manually include block information
		// for child blocks on the page. By manually updating the changeset, we avoid having to push an
		// unnecessary change into the store.
		var payloadIdx, payloadItem, payloadKey, payloadValue;
		for (payloadIdx = 0; payloadIdx < payload.length; payloadIdx++) {
			payloadItem = payload[payloadIdx];
			if (!payloadItem) continue;
			payloadKey = payloadItem[0], payloadValue = payloadItem[1];
			if (payloadKey != 'extendedAttributes') continue;
			payloadValue['_blocks'] = _blocks;
			break;
		}
		return payload;
	},
	// Saves any changes tracked by the editor to the server. Updates to the page model are submitted
	// as an array of changesets for that object. The object graph of the page is submitted as
	// serialized copies of the current working copy of any child objects in the store. Accepts an
	// inOptForceSavePage parameter, triggering a force-override any server-version of the page where
	// an editing conflict exists. For performance reasons, the object graph of a page (its direct-descendant
	// blocks and any nested child blocks) are serialized and saved in an extendedAttribute of the page.
	savePage: function(inOptForceSavePage) {
		// Create the save payload before exiting edit mode.
		var payload = this.presavePage();
		this.toggleEditMode(false);
		// Save the page.
		var pageGUID = this.mPage.getRecordPropertyForPath('guid');
		logger().debug("savePage: %o %o", pageGUID, payload);
		dialogManager().showProgressMessage("_Editor.Notifications.Page.Saving".loc());
		this.mEditingService.saveChanges(payload, inOptForceSavePage, this.didSavePage.bind(this), this.pageSaveDidFail.bind(this));
	},
	// Auto-saves any changes to the current page in local storage as JSON.
	autosavePage: function() {
		// Get any pending changesets from the editor store, bail if we have no new changesets.
		if (this.mStore.hasUnsavedChanges() && browserSupportsLocalStorage()) {
			// Build a page payload.
			var payload = this.presavePage();
			// Stash our edits.
			var localStorageKey = "%@-%@".fmt(CC.WikiEditor.LOCAL_STORAGE_KEY, this.mPage.mRecord.guid);
			try {
				var revision = this.mPage.mRecord.revision;
				window.localStorage.setItem(localStorageKey, Object.toJSON({'payload': payload, 'revision': revision, 'authenticated': (CC.meta('x-apple-user-logged-in') == 'true')}));
				var keysIndex = this.getAutosavedKeysIndex();
				keysIndex.push(localStorageKey);
				window.localStorage.setItem(CC.WikiEditor.LOCAL_STORAGE_INDEX_KEY, keysIndex.uniq().join(","));
			} catch (e) {
				logger().error("Could not autosave page because an error occurred or the local storage quota has been exceeded.");
				window.localStorage.removeItem(localStorageKey);
			}
		}
		if (this.mAutosaveDrafts && browserSupportsLocalStorage()) {
			this.mAutosaveTimer = setTimeout(this.autosavePage.bind(this), (this.mDebugMode ? this.mDebugModeAutosaveDelay : this.mAutosaveDelay));
		}
	},
	// Flushes any autosaved edits from local storage. Accepts an optional page GUID for which
	// changes should be flushed, but by default flushes changes for all pages.
	flushAutosavedChanges: function(inOptPageGUID) {
		if (!browserSupportsLocalStorage()) return false;
		logger().debug("Flusing autosaved changes from local storage");
		var keysIndex = this.getAutosavedKeysIndex();
		if (!inOptPageGUID) {
			for (var keyIdx = 0; keyIdx < keysIndex.length; keyIdx++) {
				window.localStorage.removeItem(keysIndex[keyIdx]);
			}
			window.localStorage.removeItem(CC.WikiEditor.LOCAL_STORAGE_INDEX_KEY);
		} else {
			var localStorageKey = "%@-%@".fmt(CC.WikiEditor.LOCAL_STORAGE_KEY, inOptPageGUID);
			window.localStorage.removeItem(localStorageKey);
			window.localStorage.setItem(CC.WikiEditor.LOCAL_STORAGE_INDEX_KEY, keysIndex.without(localStorageKey).join(","));
		}
		// Stop autosaving since we will start any time we go back into edit mode.
		if (this.mAutosaveTimer) clearTimeout(this.mAutosaveTimer);
	},
	getAutosavedKeysIndex: function() {
		if (browserSupportsLocalStorage()) {
			var allKeys = window.localStorage.getItem(CC.WikiEditor.LOCAL_STORAGE_INDEX_KEY);
			if (allKeys) return $A(allKeys.split(','));
		}
		return new Array();
	},
	// Validate the structure of the page before saving, detecting any blocks that have been
	// removed by the browser without notifying the editor, and updates their parent abstract
	// block container model to no longer reference the deleted block.
	detectAndFixMissingBlocks: function() {
		// Get the current block dependency value for the page from the store.
		var previousDependencies = this.mPage.getRecordPropertyForPath('extendedAttributes.blockDependencyGUIDs', new Array());
		// Get an array of block dependencies for the current state of the page.
		var currentDependencies = this._getBlockDependencyGUIDs(true);
		// Calculate an intersection of GUIDs to determine blocks that have been removed in this
		// editing session (either deliberately or unexpectedly). For each missing GUID, we walk
		// the parentGUIDs tree and determine the nearest still-existant block and update it to
		// reflect the change.
		
		var missingBlockGUIDs = [];
		for (var i = 0; i < previousDependencies.length; i++) {
			var dependency = previousDependencies[i];
			if (currentDependencies.indexOf(dependency) == -1) {
				missingBlockGUIDs.push(dependency);
			}
		}
		
		var missingBlockGUID, missingBlock;
		var parentGUIDs, missingParentGUIDs, missingParentGUIDIdx, missingParentGUID;
		var firstParent = null;
		var firstMissingParentGUID, firstMissingParent, firstParentBlockGUIDs;
		for (mdx = (missingBlockGUIDs.length - 1); mdx >= 0; mdx--) {
			missingBlockGUID = missingBlockGUIDs.shift();
			missingBlock = this.mStore.workingCopyForGUID(missingBlockGUID);
			if (!missingBlock || !missingBlock.mControllerInstance) continue;
			missingBlock = missingBlock.mControllerInstance;
			parentGUIDs = $A(missingBlock.getRecordPropertyForPath('parentGUIDs'));
			// Detect the first missing parent in the dependency graph for this missing block.
			missingParentGUIDs = new Array();
			for (var pdx = 0; pdx < parentGUIDs.length; pdx++) {
				if (missingBlockGUIDs.indexOf(parentGUIDs[pdx]) != -1) {
					missingParentGUIDs.push(parentGUIDs[pdx]);
					firstMissingParentGUID = parentGUIDs[pdx];
					continue;
				}
				firstParent = this.mStore.workingCopyForGUID(parentGUIDs[pdx]);
				break;
			}
			// If we didn't find a parent, try the page itself
			if (!firstParent) {
				firstParent = this.mStore.workingCopyForGUID(this.mPage.getRecordPropertyForPath('guid'));
			}
			// Update the blockGUIDs property of the closest existing parent container.
			if (firstParent && firstParent.mControllerInstance) {
				firstParent = firstParent.mControllerInstance;
				firstParentBlockGUIDs = firstParent.getRecordPropertyForPath('extendedAttributes.blockGUIDs');
				// If we have a missing parent of this block, we remove the missing parent
				// GUID which will also remove all children of that parent (including this
				// misssing block). Otherwise, just remove the GUID for this missing block.
				if (firstParentBlockGUIDs.include(firstMissingParentGUID || missingBlockGUID)) {
					firstParent.setRecordPropertyForPath('extendedAttributes.blockGUIDs', firstParentBlockGUIDs.without(firstMissingParentGUID || missingBlockGUID));
				}
			}
			// We no longer need to keep track of this missing block, or any of its missing parents.
			for (missingParentGUIDIdx = 0; missingParentGUIDIdx < missingParentGUIDs.length; missingParentGUIDIdx++) {
				missingParentGUID = missingParentGUIDs[missingParentGUIDIdx];
				missingBlockGUIDs = missingBlockGUIDs.without(missingParentGUID)
			}
		}
	},
	// Returns an array of all the block dependencies for this page. You should not call this
	// method yourself (performance optimization for the server).
	mCachedBlockDependencyGUIDs: null,
	_getBlockDependencyGUIDs: function(inOptForceRecalculate) {
		if (!inOptForceRecalculate && this.mCachedBlockDependencyGUIDs) return this.mCachedBlockDependencyGUIDs;
		var blocks = this.mEditorView.mPageView.$().select('.block, .block-placeholder');
		var blockDependencyGUIDs = [], block;
		var store = this.mStore;
		for (var blockIdx = 0; blockIdx < blocks.length; blockIdx++) {
			if (blocks[blockIdx]) {
				block = blocks[blockIdx];
				if (block) {
					var blockGUID = block.getAttribute('data-guid');
					if (store && store.workingCopyForGUID(blockGUID)) blockDependencyGUIDs.push(blockGUID);
				}
			}
		}
		return (this.mCachedBlockDependencyGUIDs = blockDependencyGUIDs);
	},
	// Update the blockDependencyGUIDs property on the page.
	_updateBlockDependencyGUIDs: function() {
		this.mPage.setRecordPropertyForPath('extendedAttributes.blockDependencyGUIDs', this._getBlockDependencyGUIDs(true));
	},
	// Returns a plaintext representation for the string contents of an element. Iterates
	// over all the text nodes and joins them with a single whitespace.
	_buildPlaintextStringForElement: function(element) {
		var collectTextNodesRecursively = function(_element, _workingArray) {
			if (_element && (_element.nodeType == 3)) {
				_workingArray.push(_element.data);
			}
			else if (_element && _element.hasChildNodes()) {
				for (var i = 0; i < _element.childNodes.length; i++) {
					collectTextNodesRecursively(_element.childNodes[i], _workingArray);
				}
			}
		}
		var workingArray = [];
		collectTextNodesRecursively(element, workingArray);
		return workingArray.join(" ");
	},
	// Returns a tuple of rendered HTML and text content representation of the page.
	// Clones offscreen and removes any non-content elements (8274877).
	_getRenderedPageProperties: function() {
		// Clone the page content off-screen.
		var innerHTML = this.mEditorView.mPageView.$().innerHTML;
		var offscreenElement = Builder.node('div', {className: 'wikieditor-offscreen'});
		document.body.appendChild(offscreenElement);
		offscreenElement.innerHTML = innerHTML;
		var chromeElements = offscreenElement.select(".chrome");
		for (var chromeElementIdx = (chromeElements.length - 1); chromeElementIdx >= 0; chromeElementIdx--) {
			Element.remove(chromeElements[chromeElementIdx]);
		}
		// Ensure there are no editable elements.
		offscreenElement.select('*[contentEditable="true"]').invoke('removeAttribute', 'contentEditable');
		offscreenElement.select('.editing').invoke('removeClassName', 'editing');
		// Return the markup/text value.
		var htmlValue = offscreenElement.innerHTML;
		var textValue = this._buildPlaintextStringForElement(offscreenElement);
		Element.remove(offscreenElement);
		return [htmlValue, textValue];
	},
	didSavePage: function(inResponse) {
		logger().debug("didSavePage: %o", inResponse);
		var responses = (inResponse && inResponse.responses);
		var firstResponse = (responses && responses[0]);
		if (firstResponse && firstResponse.succeeded) {
			var entity = firstResponse.response;
			dialogManager().hide();
			// Push the response into the server_proxy store.
			server_proxy()._parseAndStoreEntity(entity);
			// Flush any autosaved changes we have pending.
			this.flushAutosavedChanges(entity.guid);
			// Trigger an asynchronous preview.
			this.mEditingService.triggerPreviewForPageGUID(entity.guid);
			// Re-initialize the page (using the new entity in server_proxy).
			this._initializeInlineContent();
			globalNotificationCenter().publish(CC.WikiEditor.NOTIFICATION_DID_SAVE_PAGE, this.mPage);
			globalNotificationCenter().publish(CC.WikiEditor.NOTIFICATION_DID_SAVE_PAGE_WITH_GUID, undefined, {'entity': entity, 'guid': entity.guid});
		}
		else {
			this.pageSaveDidFail(inResponse);
		}
	},
	// Handles a failed save by retrying to save mPageSaveRetryCount times. Eventually gives up.
	pageSaveDidFail: function(inResponse) {
		logger().debug("pageSaveDidFail: %o", inResponse);
		if (this.mPageSaveRetryCountSoFar == undefined) this.mPageSaveRetryCountSoFar = 0;
		if (this.mPageSaveRetryCountSoFar < this.mPageSaveRetryCount) {
			logger().debug("Retrying page save");
			this.mPageSaveRetryCountSoFar += 1;
			this.savePage();
		} else {
			logger().error("Tried to save page %@ times and failed, bailing".fmt(this.mPageSaveRetryCount));
			delete this.mPageSaveRetryCountSoFar;
			dialogManager().hide();
			this.toggleEditMode(true, true, true);
			globalNotificationCenter().publish(CC.WikiEditor.NOTIFICATION_ERROR_SAVING_PAGE, this.mPage);
		}
	},
	// Restores unaltered versions of the page and any dependant blocks from the editor
	// store. Invoked when editing is cancelled.
	restoreStashedContent: function() {
		this._initializeInlineContent(this.mStashedContent);
	},
	// Predicts the next block in the editor. Just passes off to the top-level abstract
	// container, the page.
	predictNextBlock: function(inOptPreviousBlock, inOptIsPlaceholder) {
		return this.mPage.predictNextBlock(inOptPreviousBlock, inOptIsPlaceholder);
	},
	predictAndAddNextBlock: function(inOptPreviousBlock, inOptIsPlaceholder, inOptActivateAfterCreating, inOptPosition) {
		var block = (this.mSelecting && this.mSelectedBlocks) ? this.mSelectedBlocks.values().first() : this.mActiveBlock;
		var prediction = this.predictNextBlock(inOptPreviousBlock, inOptIsPlaceholder);
		var position = (inOptPosition ? inOptPosition : (inOptPreviousBlock ? {after: inOptPreviousBlock.mViewInstance.mParentElement} : undefined));
		var container = (this.mActiveBlock && this.mActiveBlock.mParentContainer) ? this.mActiveBlock.mParentContainer : undefined;
		if (container == this.mPage) container = undefined;
		this.addBlock(prediction.blockType, {'extendedAttributes': prediction.attributes}, inOptActivateAfterCreating, position, container);
	},
	// Handles a select/deselect all.
	handleSelectAll: function() {
		this.mSelectAllDelegate.prepareToSelectAll();
		this.selectAllBlocks();
	},
	handleDeselectAll: function() {
		this.mSelectAllDelegate.prepareToDeselectAll();
		this.deselectAllBlocks();
	},
	// Iterates through every block registered with the block plugin registry,
	// and configures the editor toolbar. The editor toolbar is split into
	// three sections; blocks, actions and containers. If a registered block
	// nominates an editor toolbar item, we add it to the first well. If a
	// registered block elects a contextual toolbar, we add it to the second well
	// if it is a content block and the third well if it is a container block.
	// Block toolbar items are shared among block instances of the same type.
	_configureEditorToolbar: function() {
		var registry = globalEditorBlockPluginRegistry();
		var toolbar = this.mEditorView.mToolbarView;
		var blocks = toolbar.mBlockSectionParentElement;
		var actions = toolbar.mActionSectionParentElement;
		var containers = toolbar.mContainerSectionParentElement;
		var blockToolbar, blockToolbarView;
		// First initialize any contextual toolbars for all registered blocks.
		var registeredBlockKeys = $A(registry.registeredBlocks()), registeredBlockKeyIdx, registeredBlockKey;
		for (registeredBlockKeyIdx = 0; registeredBlockKeyIdx < registeredBlockKeys.length; registeredBlockKeyIdx++) {
			registeredBlockKey = registeredBlockKeys[registeredBlockKeyIdx];
			// Get the block toolbar for this registeredBlockKey from the registry.
			blockToolbar = registry.blockToolbarForType(registeredBlockKey);
			// Bail if this block doesn't have a toolbar.
			if (!blockToolbar) continue;
			// Otherwise, instantiate and render the toolbar.
			blockToolbarView = new CC.WikiEditor.EditorInlineToolbarView({
				mContent: blockToolbar
			});
			renderedView = blockToolbarView._render();
			// Aggressively cache the toolbar by registeredBlockKey.
			this.mBlockContextualToolbarCache.set(registeredBlockKey, {'renderedView': renderedView, 'view': blockToolbarView});
			if (!renderedView) continue;
			registry.blockTypeBehavesAsContainer(registeredBlockKey) ? containers.appendChild(renderedView) : actions.appendChild(renderedView);
		}
		// Next, initialize a single toolbar with any "add block" buttons for each
		// individual block type registered with the editor. This single toolbar is
		// always visible in the leftmost well in the editor toolbar.
		var editorToolbarItem;
		blockToolbar = new CC.WikiEditor.BlockToolbar();
		for (registeredBlockKeyIdx = 0; registeredBlockKeyIdx < registeredBlockKeys.length; registeredBlockKeyIdx++) {
			registeredBlockKey = registeredBlockKeys[registeredBlockKeyIdx];
			// Grab the eidtor toolbar item for this registeredBlockKey.
			editorToolbarItem = registry.editorToolbarItemForType(registeredBlockKey);
			if (!editorToolbarItem) continue;
			// Push the toolbar item onto our one-time toolbar.
			blockToolbar.mToolbarItems.push(editorToolbarItem);
		}
		// Render the toolbar and append.
		var blocksToolbar = new CC.WikiEditor.EditorInlineToolbarView({
			mContent: blockToolbar
		});
		var renderedToolbar = blocksToolbar._render();
		if (renderedToolbar) blocks.appendChild(renderedToolbar);
		// Append a divider for each section.
		$([blocks, actions, containers]).each(function(section) {
			section.appendChild(Builder.node('div', {className: 'divider'}, [
				Builder.node('div', {className: 'divider-left'}),
				Builder.node('div', {className: 'divider-right'})
			]));
		});
	},
	// Reconfigures the editor toolbar after a change in editing context. As
	// the active block changes, the currently shown action and/or container
	// toolbars will update to reflect the current context. Once displayed,
	// individual options on those toolbars will be enabled/disabled depending
	// on the currently focused block.
	reconfigureEditorToolbar: function(inOptBlock) {
		var activeBlock = (inOptBlock || this.mActiveBlock || undefined);
		// Walk up the container tree from the active block, finding any containers.
		var blocks = $A([activeBlock]), nextContainer = (activeBlock ? activeBlock.mParentContainer : undefined);
		while ((nextContainer != undefined) && (nextContainer != this.mPage)) {
			blocks.push(nextContainer);
			nextContainer = nextContainer.mParentContainer;
		}
		// Compute an array of the identifers of the toolbars required for the stack.
		// That way, we don't hide a toolbar that we'll later need to show.
		var blockTypes = new Array(), blockIdx, block;
		for (blockIdx = 0; blockIdx < blocks.length; blockIdx++) {
			block = blocks[blockIdx];
			if (block && block.mRecord && block.mRecord.blockType) blockTypes.push(block.mRecord.blockType);
		}
		// Hide any unwanted toolbars first.
		var toolbars = this.mBlockContextualToolbarCache;
		var toolbarKeys = toolbars.keys(), toolbarKey, toolbarValue, toolbarIdx;
		for (toolbarIdx = 0; toolbarIdx < toolbarKeys.length; toolbarIdx++) {
			toolbarKey = toolbarKeys[toolbarIdx];
			toolbarValue = toolbars.get(toolbarKey);
			if (!this.mSelecting && blockTypes.include(toolbarKey)) continue;
			if (!(toolbarValue && toolbarValue.renderedView && toolbarValue.view)) continue;
			toolbarValue.renderedView.addClassName('hidden');
			toolbarValue.renderedView.up('.section').addClassName('hidden');
			toolbarValue.view.mBlockTarget = null;
			globalNotificationCenter().publish(CC.WikiEditor.NOTIFICATION_DID_HIDE_BLOCK_TOOLBAR, toolbarValue);
		}
		// Bail if we're in selection mode.
		if (this.mSelecting) return;
		// Iterate over the list of containers we just derived and configure the new set.
		var blockType;
		for (blockIdx = 0; blockIdx < blocks.length; blockIdx++) {
			block = blocks[blockIdx];
			if (!CC.kindOf(block, CC.WikiEditor.Block)) continue;
			blockType = ((block && block.mRecord) ? block.mRecord.blockType : undefined);
			toolbar = this.mBlockContextualToolbarCache.get(blockType);
			if (toolbar && toolbar.view && toolbar.renderedView) {
				toolbarView = toolbar.view;
				toolbarKeys = toolbarView.keys();
				toolbarSettingsForKeys = block.mViewInstance.toolbarSettingsForKeys(toolbarKeys);
				toolbarView.updateToolbarUsingPropertiesForKeys(toolbarSettingsForKeys);
				toolbar.renderedView.removeClassName('hidden');
				toolbar.renderedView.up('.section').removeClassName('hidden');
				toolbarView.mBlockTarget = block;
				globalNotificationCenter().publish(CC.WikiEditor.NOTIFICATION_DID_SHOW_BLOCK_TOOLBAR, toolbar);
			}
		}
	},
	// Handles key events in the main editor view. Supports keyboard navigation between
	// existing blocks and deleting blocks.
	_registerEventHandlers: function() {
		bindEventListeners(this, [
			'handleWindowMouseDown',
			'handleEditorBufferViewClick'
		]);
		Event.observe(window, 'mousedown', this.handleWindowMouseDown);
		globalEventDelegate().bulkRegisterDomResponderForEventByIdentifer([
			['click', 'wikieditor_top', this.handleEditorBufferViewClick],
			['click', 'wikieditor_bottom', this.handleEditorBufferViewClick]
		]);
		globalNotificationCenter().subscribe(CC.EntityTitle.NOTIFICATION_TITLE_DID_CHANGE, this.handlePageTitleDidChange.bind(this));
		globalNotificationCenter().subscribe('DID_RESTORE_ENTITY_REVISION', this.handlePageRestored.bind(this));
		var boundReconfigureEditorToolbar = this.handleToolbarShouldUpdateNotification.bind(this);
		globalNotificationCenter().subscribe(CC.WikiEditor.NOTIFICATION_DID_SELECT_ALL, boundReconfigureEditorToolbar);
		globalNotificationCenter().subscribe(CC.WikiEditor.NOTIFICATION_DID_DESELECT_ALL, boundReconfigureEditorToolbar);
		globalNotificationCenter().subscribe(CC.WikiEditor.NOTIFICATION_EDITOR_SHOULD_UPDATE_TOOLBAR, boundReconfigureEditorToolbar);
		globalNotificationCenter().subscribe(CC.WikiEditor.NOTIFICATION_EDITOR_WILL_LOSE_FOCUS, this.handleEditorWillLoseFocus.bind(this));
		globalNotificationCenter().subscribe(CC.WikiEditor.NOTIFICATION_BLOCK_CONTENTEDITABLE_DID_FOCUS, this.handleBlockFocusDidChange.bind(this));
		globalNotificationCenter().subscribe(CC.WikiEditor.NOTIFICATION_BLOCK_CONTENTEDITABLE_DID_BLUR, this.handleBlockFocusDidChange.bind(this));
		globalNotificationCenter().subscribe('AUTHENTICATION_LOGGED_OUT', this.flushAutosavedChanges.bind(this));
		window.onbeforeunload = this.handleWindowShouldUnload.bind(this);
	},
	// Unload handler for the editor if we're in edit mode.
	handleWindowShouldUnload: function() {
		if (this.mEditMode) return "_Editor.Unload.Warning".loc();
	},
	// Handles lost focus (e.g. when a toolbar is activated).
	handleEditorWillLoseFocus: function(inMessage, inObject, inOptExtras) {
		if (this.mActiveBlock) globalEditorTextSelectionDelegate().cacheSelection();
	},
	handleToolbarShouldUpdateNotification: function(inMessage, inObject, inOptExtras) {
		this.reconfigureEditorToolbar();
	},
	// Handles mouse down events on the window object. Responsible for block selection,
	// cancelling editing on any active blocks and hiding any active toolbar menus.
	handleWindowMouseDown: function(inEvent) {
		// If we're selecting, deselect everything first.
		if (this.mSelecting) this.handleDeselectAll();
		// If we're not in edit mode, bail.
		if (!this.mEditMode) return;
		// Otherwise handle toolbar/block activation.
		var toolbarElem = (this.mEditorView && this.mEditorView.mToolbarView) ? this.mEditorView.mToolbarView.$() : undefined;
		var activeToolbar = $$('.editor.toolbar .expanded, .editor.inline.popup.expanded').length > 0;
		var toolbarSource = toolbarElem ? Position.within(toolbarElem, inEvent.pointerX(), inEvent.pointerY()) : false;
		// If the event fired outside an active toolbar, collapse and resume editing.
		// We deliberately delay this so any mouse events on individual menu options
		// have enough time to fire.
		if (!toolbarSource && toolbarElem && activeToolbar) {
			setTimeout(function() {
				toolbarElem.select('.expanded').invoke('removeClassName', 'expanded');
				if (this.mActiveBlock) this.resumeEditing(this.mActiveBlock);
			}.bind(this), 200);
			return true;
		}
	},
	// Handles click events on the page buffer view (the view that wraps all top-level blocks).
	// We explicitly watch for events in this space so we can implicitly relocate the cursor to
	// the nearest top-level text block.
	handleEditorBufferViewClick: function(inEvent) {
		if (!this.mEditMode) return;
		Event.stop(inEvent);
		var top = inEvent.findElement('.buffer .top');
		var bottom = inEvent.findElement('.buffer .bottom');
		if (top || bottom) {
			block = top ? this.mPage.firstBlock() : this.mPage.lastBlock();
			before = top;
			after = bottom;
			moveToStart = top;
			moveToEnd = bottom;
		}
		return this.startEditing(block, {'moveToStart': moveToStart, 'moveToEnd': moveToEnd}, true);
	},
	// Handle a change in page title from the page title view.
	handlePageTitleDidChange: function(inMessage, inObject, inOptExtras) {
		var title = inOptExtras ? inOptExtras.title : undefined;
		this.mPage.setRecordPropertyForPath('longName', title);
		globalNotificationCenter().publish(CC.WikiEditor.NOTIFICATION_PAGE_DID_CHANGE, this.mPage);
	},
	// Handles a restored page.
	handlePageRestored: function(inMessage, inObject, inOptExtras) {
		this.toggleEditMode(false);
		var entity = (inOptExtras && inOptExtras.entityObject);
		this._initializeInlineContent(entity);
	},
	// Handles a block focus change behind our back.
	handleBlockFocusDidChange: function(inMessage, inObject, inOptExtras) {
		logger().debug("handleBlockFocusDidChange: %o", inObject);
		if (inMessage == CC.WikiEditor.NOTIFICATION_BLOCK_CONTENTEDITABLE_DID_FOCUS) {
			return this.startEditing(inObject);
		}
	}
});

// A read-only instance of the editor. Supports multiple instances on a page.

CC.WikiEditor.ReadOnlyEditorController = Class.create(CC.WikiEditor.EditorController, {
	mEditorViewClass: 'CC.WikiEditor.ReadOnlyEditorView',
	mEditingService: null,
	// Override the read-write editor controller to limit behavior.
	_initialize: function(/* {options} */) {
		this.mIdentifer = (new CC.GuidBuilder()).toString();
		if (arguments && arguments.length > 0) Object.extend(this, arguments[0]);
		if (!this.mParentElement) return false;
		if (!this.mEditorView) {
			var konstructor = this.mEditorViewClass;
			this.mEditorView = CC.objectInstanceForPropertyPath(konstructor);
			if (!this.mEditorView) throw("Could not initialize main view for editor");
		}
		this.mParentElement.appendChild(this.mEditorView._render());
		this.mParentElement.select('.cc-entity-favorite-toggle').each(function(toggle) { new CC.EntityFavoriteToggle(toggle); });
		globalNotificationCenter().publish(CC.WikiEditor.NOTIFICATION_EDITOR_READY, this);
		this._initializeInlineContent();
	},
	toggleEditMode: function() {
		return false;
	},
	restoreAutosavedEdits: function() {
		return false;
	},
	startEditing: function() {
		return false;
	},
	resumeEditing: function() {
		return false;
	},
	stopEditing: function() {
		return false;
	},
	savePage: function() {
		return false;
	},
	autosavePage: function() {
		return false;
	},
	handleSelectAll: function() {
		return false;
	},
	handleDeselectAll: function() {
		return false;
	},
	reconfigureEditorToolbar: function() {
		return false;
	},
	_registerEventHandlers: function() {
		return false;
	}
});

// Core editor view.

CC.WikiEditor.EditorView = Class.create(CC.Mvc.View, {
	mContent: null,
	render: function() {
		this.mBufferView = new CC.WikiEditor.EditorBufferView();
		this.mToolbarView = new CC.WikiEditor.EditorToolbarView();
		var childViews = [this.mBufferView, this.mToolbarView].invoke('_render');
		return Builder.node('div', {className: 'editor container wrapchrome'}, childViews);
	}
});

// Read only editor view.

CC.WikiEditor.ReadOnlyEditorView = Class.create(CC.WikiEditor.EditorView, {
	render: function() {
		return Builder.node('div', {className: 'editor read-only container wrapchrome'});
	}
});

// Editor mask view.

CC.WikiEditor.EditorBufferView = Class.create(CC.Mvc.View, {
	render: function() {
		return Builder.node('div', {id: 'wikieditor_buffer', className: 'page buffer chrome'}, [
			Builder.node('div', {id: 'wikieditor_top', className: 'top'}),
			Builder.node('div', {id: 'wikieditor_bottom', className: 'bottom'})
		]);
	}
});

// Editor toolbar view.

CC.WikiEditor.EditorToolbarView = Class.create(CC.Mvc.View, {
	render: function() {
		// Build out a container element with save/cancel buttons and our three contextual
		// toolbars (one for blocks, one for actions and one for containers). The editor
		// will populate this later.
		var toolbar = Builder.node('div', {className: 'editor toolbar chrome'}, [
			Builder.node('div', {className: 'contents'}, [
				Builder.node('div', {className: 'tools'}, [
					Builder.node('div', {className: 'section blocks'}),
					Builder.node('div', {className: 'section actions'}),
					Builder.node('div', {className: 'section containers'})
				]),
				// XXX buttons are temporarily disabled from tabindexing (rdar: 14841070 - Make the editor accessible)
				Builder.node('div', {className: 'buttons'}, [
					Builder.node('input', {type: 'button', className: 'undo', value: "_Editor.Undo.Title".loc(), title: "_Editor.Undo.Tooltip".loc(), tabindex: "-1"}),
					Builder.node('input', {type: 'button', className: 'cancel', value: "_Editor.Cancel.Title".loc(), title: "_Editor.Cancel.Tooltip".loc(), tabindex: "-1"}),
					Builder.node('input', {type: 'button', className: 'save', value: "_Editor.Save.Title".loc(), title: "_Editor.Save.Tooltip".loc(), tabindex: "-1"})
				])
			])
		]);
		// Cache each of the toolbar sections for easy reference.
		this.mBlockSectionParentElement = toolbar.down('.section.blocks');
		this.mActionSectionParentElement = toolbar.down('.section.actions');
		this.mContainerSectionParentElement = toolbar.down('.section.containers');
		// Hook up the undo button.
		Event.observe(toolbar.down('input.undo'), 'click', this.handleEditorToolbarUndo.bind(this));
		// Hook up the save and cancel buttons.
		Event.observe(toolbar.down('input.cancel'), 'click', this.handleEditorToolbarCancel.bind(this));
		Event.observe(toolbar.down('input.save'), 'click', this.handleEditorToolbarSave.bind(this));
		return toolbar;
	},
	handleEditorToolbarUndo: function(inEvent) {
		Event.stop(inEvent);
		textBlockDelegate().attemptUndo();
	},
	handleEditorToolbarCancel: function(inEvent) {
		Event.stop(inEvent);
		globalEditorController().flushAutosavedChanges();
		globalEditorController().restoreStashedContent();
		globalEditorController().toggleEditMode(false);
		globalNotificationCenter().publish(CC.WikiEditor.NOTIFICATION_DID_CANCEL_EDITING, this.mPage);
	},
	handleEditorToolbarSave: function(inEvent) {
		dialogManager().showProgressMessage("_Editor.Notifications.Page.Checking.Status".loc());
		Event.stop(inEvent);
		var changesCallback = function() {
			dialogManager().hide();
			if (confirm("_Editor.Conflict.Save.Override".loc())) {
				globalEditorController().savePage(true);
			}
		};
		var noChangesCallback = function() {
			globalEditorController().savePage();
		};
		var errback = function(response) {
			dialogManager().hide();
			notifier().printErrorMessage("_Editor.Notifications.Page.Checking.Status.Error".loc());
		};
		globalEditorController().mEditingService.checkServerForEdits(changesCallback.bind(this), noChangesCallback.bind(this), errback.bind(this));
	},
	handleDidStartEditing: function() {
		if (browser().isMobileSafari()) {
			this.$().addClassName('displaying');
		} else {
			setTimeout(function() {
				this.$().addClassName('displaying');
			}.bind(this), 500);
		}
	}.observes(CC.WikiEditor.NOTIFICATION_DID_START_EDITING, true),
	handleDidFinishEditing: function() {
		this.$().removeClassName('displaying');
	}.observes(CC.WikiEditor.NOTIFICATION_DID_FINISH_EDITING, true)
});
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.

// File block delegate for the editor. Because we want to upload an attachment/image
// before adding a block to the page, the default toolbar plugin action calls this
// handler before invoking the default editor add block behavior by hand.

var FileBlockDelegate = Class.createWithSharedInstance('fileBlockDelegate');
FileBlockDelegate.prototype = {
	_cachedBlockType: null,
	initialize: function() {},
	addBlock: function() {
		// Get the page guid.
		var pageGUID = CC.meta('x-apple-entity-guid');
		// Show the upload file panel and register our callbacks, setting the owner of the
		// file to be the page.
		fileUploadManager().createUploadPanel(0, pageGUID, {
			'complete': {callback: 'didCompleteUpload', target: this},
			'error': {callback: 'didFailUpload', target: this}
		}, true);
	},
	didCompleteUpload: function(inFileData) {
		logger().debug("didCompleteUpload: %o", inFileData);
		if (!(inFileData && inFileData.fileGUID && inFileData.fileName && inFileData.fileEntity)) return false;
		// Add a file-backed block depending on the mediaType returned by the server.
		var mediaType = (inFileData && inFileData.fileEntity && inFileData.fileEntity.mediaType);
		var blockType;
		if (mediaType == "image") {
			blockType = "image";
		} else if (mediaType == 'movie' || mediaType == 'audio') {
			blockType = "media";
		} else {
			blockType = "attachment";
		}
		// Add a new block to the page, passing the file data along to the block model.
		var fileBlock = editorToolbarDelegate().addBlock(blockType, {
			'extendedAttributes': {
				'fileGUID': inFileData.fileGUID,
				'fileDataGUID': inFileData.fileEntity.dataGUID,
				'fileName': inFileData.fileName,
				'width': inFileData.fileEntity.extendedAttributes.width,
				'height': inFileData.fileEntity.extendedAttributes.height
			}
		}, true);
	},
	didFailUpload: function(inError) {
		logger().error("didFailUpload: %o", inError);
		notifier().printErrorMessage("_Editor.Block.File.Uploaded.Error".loc());
	}
};

// A file-backed block.

CC.WikiEditor.FileBlock = Class.create(CC.WikiEditor.Block, {
	mBlockView: 'CC.WikiEditor.FileBlockView',
	restore: function($super, inChangesets) {
		var changesetKey, changesetValue, changesetIdx, changes;
		for (changesetIdx = 0; changesetIdx < inChangesets.length; changesetIdx++) {
			changes = inChangesets[changesetIdx];
			if (changes.length < 2) continue;
			changesetKey = changes[0];
			changesetValue = changes[1];
			if (changesetKey != 'extendedAttributes') continue;
			if (changesetValue.fileGUID == undefined || changesetValue.fileDataGUID == undefined) continue;
			this.mViewInstance.didReplaceFile(undefined, changesetValue.fileGUID, changesetValue.fileDataGUID, changesetValue.fileName);
		}
		$super(inChangesets);
	}
});

CC.WikiEditor.FileBlockView = Class.create(CC.WikiEditor.NonTextBlockView, CC.WikiEditor.Mixins.AskBeforeDeleting, {
	// Overload _registerEventHandlers so we can add file-specific requirements.
	_registerEventHandlers: function($super) {
		this.$().addClassName('file');
		var fileGUID = this.mContent.getRecordPropertyForPath('extendedAttributes.fileGUID');
		if (fileGUID) this.$().setAttribute('data-file-guid', fileGUID);
		var fileDataGUID = this.mContent.getRecordPropertyForPath('extendedAttributes.fileDataGUID');
		if (fileDataGUID) this.$().setAttribute('data-file-data-guid', fileDataGUID);
		$super.apply(null, Array.prototype.slice.call(arguments, 1));
	},
	buildFileURL: function() {
		return '%@/files/download/%@'.fmt(env().root_path, this.mContent.getRecordPropertyForPath('extendedAttributes.fileDataGUID'));
	},
	buildForceDownloadFileURL: function() {
		return '%@/files/download/%@'.fmt(env().root_path, this.mContent.getRecordPropertyForPath('extendedAttributes.fileDataGUID'));
	},
	downloadFile: function() {
		window.location.href = this.buildForceDownloadFileURL();
	},
	showMoreInfo: function() {
		window.location.href = '%@/files/%@'.fmt(env().root_path, this.mContent.getRecordPropertyForPath('extendedAttributes.fileGUID'));
	},
	handleKeyboardNotification: function(inMessage, inObject, inOptExtras) {
		switch (inMessage) {
			// 8685082
			case CC.Keyboard.NOTIFICATION_DID_KEYBOARD_BACKSPACE:
			case CC.Keyboard.NOTIFICATION_DID_KEYBOARD_DELETE:
				Event.stop(inOptExtras.event);
				return true;
		}
	}
});

globalEditorPluginManager().registerBlockType('file', 'CC.WikiEditor.FileBlock', {
	mEditorToolbarItem: new CC.WikiEditor.EditorToolbarItem({
		mDisplayTitle: "_Editor.Toolbar.Block.File.Title".loc(),
		mTooltip: "_Editor.Toolbar.Block.File.Tooltip".loc(),
		mIsEnabled: true,
		mKey: 'file',
		mAction: 'addBlock',
		mTarget: fileBlockDelegate()
	})
});
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.



CC.WikiEditor.AttachmentBlock = Class.create(CC.WikiEditor.FileBlock, {
	mBlockView: 'CC.WikiEditor.AttachmentBlockView'
	// TOOD
});

CC.WikiEditor.AttachmentBlockView = Class.create(CC.WikiEditor.FileBlockView, {
	mDeleteDialogTitle: "_Editor.Block.Attachment.Dialog.Delete.Title".loc(),
	mDeleteDialogDescription: "_Editor.Block.Attachment.Dialog.Delete.Description".loc(),
	mDefaultQuickLookableExtensions: "ada adb ads asm bash bmp c cc class cp cpp csh cxx c++ doc docx f for f77 f95 gif hh hp hpp hxx h++ html i ii icns ics jav java jpeg jpg jp2 js key ksh l lm lmm lpp lxx m mi mm mii mov mpeg mpg mp3 mp4 m4a m4p m4v 3gp nasm numbers pages pas pdf plist png ppt pptx psd rb rtf s sh strings tcsh tif tiff txt xhtml xml xls xlsx y ym ymm ypp yxx zsh".w(),
	renderAsHTML: function() {
		var filename = this.mContent.getRecordPropertyForPath('extendedAttributes.fileName');
		var fileGUID = this.mContent.getRecordPropertyForPath('extendedAttributes.fileGUID');
		var quicklookableExtensions = this.mDefaultQuickLookableExtensions;
		quicklookableExtensions.concat(CC.meta('x-apple-quicklookable-extensions').split(','));
		var extension = (filename.match(/([\w]+)$/)[1] || "").toLowerCase();
		// If the attachment is a zip archive and filename includes a clue to the bundle extension, try again.
		if (extension == 'zip') {
			var extensions = filename.match(/\.([\w]+)\.zip$/);
			if (extensions && extensions.size() > 1) {
				extension = extensions[1];
			}
		}
		// Is this attachment quicklookble or do we think it will be quicklookable?
		var isQuickLookable = (quicklookableExtensions.indexOf(extension) != -1);
		// Build out the HTML for this block.
		var eventDelegateIdentifer = this.getEventDelegateIdentifer();
		var html = "<div class=\"attachment%@\">".fmt((isQuickLookable ? " quicklookable" : "")) +
			"<div id=\"%@\" class=\"right-cap\"%@></div>".fmt(eventDelegateIdentifer + "-right-cap", (isQuickLookable ? " title=\"%@\"".fmt("_Editor.Block.Attachment.QuickLook.Label".loc()) : "")) +
			"<div id=\"%@\" class=\"left-container\"><div id=\"%@\" class=\"delete clickable chrome\">%@</div>".fmt(eventDelegateIdentifer + "-left-container", eventDelegateIdentifer + "-left-container-delete", "_Editor.Block.Attachment.Remove.Label".loc()) +
			"<div class=\"left-cap\"></div><div class=\"mid\">" +
			"<div class=\"filename default\" title=\"%@\">%@</div>".fmt(filename, filename) +
			"</div></div></div>";
		return html;
	},
	registerEventHandlers: function() {
		bindEventListeners(this, [
			'handleDownloadFileClicked',
			'handleQuickLookFileClicked',
			'handleDeleteButtonClick'
		]);
		var eventDelegateIdentifer = this.getEventDelegateIdentifer();
		var clickEvent = browser().isMobileSafari() ? 'touchstart' : 'click';
		globalEventDelegate().bulkRegisterDomResponderForEventByIdentifer([
			[clickEvent, "%@-left-container".fmt(eventDelegateIdentifer), this.handleDownloadFileClicked],
			[clickEvent, "%@-left-container-delete".fmt(eventDelegateIdentifer), this.handleDeleteButtonClick]
		]);
		var elem = this.mParentElement;
		if (elem.down('.attachment').hasClassName('quicklookable')) globalEventDelegate().registerDomResponderForEventByIdentifer(clickEvent, eventDelegateIdentifer + "-right-cap", this.handleQuickLookFileClicked);
	},
	handleDownloadFileClicked: function(inEvent) {
		if (globalEditorController().mEditMode) return true;
		return this.downloadFile();
	},
	handleQuickLookFileClicked: function(inEvent) {
		if (globalEditorController().mEditMode) return true;
		// Preload the file entity so we can animate at the correct size.
		var fileDataGUID = this.mContent.getRecordPropertyForPath('extendedAttributes.fileDataGUID');
		dialogManager().showProgressMessage("_QuickLook.Status.Preview.Loading".loc());
		var callback = function(response) {
			dialogManager().hideProgressMessage();
			quicklook().mPreviewInfo = response;
			quicklook().showPreviewPanelForAttachment(this.$().down('.left-container'), fileDataGUID);
		}.bind(this);
		quicklook().mService.pollForPreviewInformation(fileDataGUID, callback);
	}
});

globalEditorPluginManager().registerBlockType('attachment', 'CC.WikiEditor.AttachmentBlock', {});
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.

// Properties we allow to be styled inline.

CC.WikiEditor.TEXT_BLOCK_ALLOWED_INLINE_STYLES = 'background-color color font-style font-weight text-decoration'.w();
CC.WikiEditor.CAMELIZED_TEXT_BLOCK_ALLOWED_INLINE_STYLES = CC.WikiEditor.TEXT_BLOCK_ALLOWED_INLINE_STYLES.invoke('camelize');

// Text block helpers.

CC.WikiEditor.TextBlockHelpers = {
	// Cleans up the last trailing empty list item in a text block.
	cleanLastTrailingListItem: function(inElement) {
		if (!inElement) return;
		var elem = $(inElement);
		// If we're working inside a list, clean up the last list item if it exists and is empty.
		var items = elem.select('li');
		if (items.length > 0) {
			var lastItem = items[items.length - 1];
			if (lastItem.empty()) Element.remove(lastItem);
			if (lastItem.hasChildNodes()) {
				var clonedItem = lastItem.cloneNode(true);
				if (!cleanTrailingWhitespace(clonedItem).hasChildNodes()) Element.remove(lastItem);
			}
			return;
		}
	},
	// Cleans up the last trailing line break node.
	cleanLastTrailingLineBreak: function(inElement) {
		if (!inElement) return;
		var childNodes = inElement.childNodes;
		var childNodesLength = childNodes.length, childNode;
		// Walk through the childNodes in reverse, looking for the outermost <br> tag in the
		// rightmost childNode tree.
		childNode = childNodes.item(childNodesLength - 1);
		while (childNode != undefined) {
			if (isBrTag(childNode)) {
				childNode.parentNode.removeChild(childNode);
				break;
			}
			if (childNode.hasChildNodes()) {
				childNode = childNode.lastChild;
				continue;
			}
			break;
		}
	},
	buildSpacerNode: function() {
		return Builder.node('img', {src: '/__collabd/coreclientbase/static/spacer.gif', className: 'chrome block-spacer', width: '1px', height: '1px'});
	},
	// Helper function mapping a CSS style name/value into a class name, stripping anything non-alphanumeric.
	styleValueToClassName: function(inStyleName, inValue) {
		var styleName = inStyleName.toLowerCase();
		var val = ('' + inValue).toLowerCase().replace(/,/g, '-').replace(/[^a-z0-9-_]/g, '');
		if (inStyleName == 'font-weight') val = CC.WikiEditor.TextBlockHelpers.normalizeBoldStyleValue(val);
		return styleName + '-' + val;
	},
	// Normalizes potentially integral boldness style values to a string (bold or normal).
	normalizeBoldStyleValue: function(inStyleValue) {
		var styleValue = inStyleValue;
		var boldnessNumberMatch = (styleValue || "").match(/(\d{3})/);
		if (boldnessNumberMatch) styleValue = (parseInt(boldnessNumberMatch[1], 10) >= 600 ? 'bold' : 'normal');
		return styleValue;
	},
	// Fixes any rogue inline styles.
	fixInlineStyles: function(inElement) {
		if (!inElement) return true;
		inElement = $(inElement);
		var elements, elmIdx, elm;
		// 8553023
		elements = inElement.select('strong, em');
		for (elmIdx = 0; elmIdx < elements.length; elmIdx++) {
			elm = elements[elmIdx];
			if (elm.nodeName.toLowerCase() == 'strong') changeNodeName(elm, 'b');
			if (elm.nodeName.toLowerCase() == 'em') changeNodeName(elm, 'i');
		}
		// 5682257
		elements = inElement.select('.wiki_unbold');
		for (elmIdx = 0; elmIdx < elements.length; elmIdx++) {
			elm = elements[elmIdx];
			Element.unwrap(elm, 'b', function() { return Builder.node('b') });
		}
		elements = inElement.select('.wiki_unitalic');
		for (elmIdx = 0; elmIdx < elements.length; elmIdx++) {
			elm = elements[elmIdx];
			Element.unwrap(elm, 'i', function() { return Builder.node('i') });
		}
		elements = inElement.select('.wiki_ununderline');
		for (elmIdx = 0; elmIdx < elements.length; elmIdx++) {
			elm = elements[elmIdx];
			Element.unwrap(elm, 'u', function() { return Builder.node('u') });
		}
	}
};

// Text block delegate. Really only handles the link popup.

var TextBlockDelegate = Class.createWithSharedInstance('textBlockDelegate');
TextBlockDelegate.prototype = {
	mTextBlockDebugDialog: null,
	mDelimeterClassName: 'wikieditor-textblock-delimeter',
	initialize: function() {
		if (document && document.body) return this._initialize();
	},
	_initialize: function() {
		this.mSmartLinkPopup = new CC.WikiEditor.SmartLinkPopup();
		this.mSmartLinkPopup._render();
		document.body.appendChild(this.mSmartLinkPopup.$());
		this.renderTextBlockDebugDialog();
		this.renderCopyPasteDebugConsole();
		var boundEditModeDidChange = this.handleEditModeDidChange.bind(this);
		globalNotificationCenter().subscribe(CC.WikiEditor.NOTIFICATION_DID_START_EDITING, boundEditModeDidChange);
		globalNotificationCenter().subscribe(CC.WikiEditor.NOTIFICATION_DID_FINISH_EDITING, boundEditModeDidChange);
	},
	addBlock: function() {
		editorToolbarDelegate().addBlock('text', {}, true);
	},
	showSmartLinkPopup: function(inOptAnchor, inOptURL, inOptLinkText, inOptCallback, inOptCancelCallback) {
		this.mSmartLinkPopup.preparePopup(inOptAnchor, inOptURL, inOptLinkText, inOptCallback, inOptCancelCallback);
		this.mSmartLinkPopup.show(inOptAnchor);
	},
	// Hash of allowed inline text styles.
	mRegisteredStyles: new Hash(),
	// A reverse hash of normalized inline styles we allow. Note that because this is calculated
	// in runtime depending on the reported style value returned by Element.getStyle, this is not
	// guaranteed to be the same across clients.
	mAllowedNormalizedStyles: new Hash(),
	// Registers a new inline style for the text block. Expects some kind of identifier
	// and accepts an optional description, class name and style hash. Text styling works by
	// converting inline styles to a class name on save, and vice versa on load. Doing so
	// allows us to safely save and serve markup maintaining appearance (inline styles can
	// contain malicious code/scripts in IE). Each registered style is stored as a tuple of
	// description, class name and style.
	registerInlineTextStyle: function(inTextStyleIdentifer, inOptTextStyleDescription, inOptClassName, inOptStyleHash) {
		if (!inTextStyleIdentifer) return logger().warn("Cannot register an inline text style without an identifer (%@)".fmt(inTextStyleIdentifer));
		if (this.mRegisteredStyles.get(inTextStyleIdentifer)) logger().warn("Inline text style (%@) is already registered and will be overwritten".fmt(inTextStyleIdentifer));
		var identifier = inTextStyleIdentifer;
		var displayName = (inOptTextStyleDescription || "%@ style".fmt(identifer));
		var className = (inOptClassName || identifier);
		var styles = $H(inOptStyleHash || {});
		var styleKeys = styles.keys(), styleKeyIdx, styleKey;
		this.mRegisteredStyles.set(identifier, [displayName, className, styles]);
		// Cache any allowed inline styles.
		for (styleKeyIdx = 0; styleKeyIdx < styleKeys.length; styleKeyIdx++) {
			styleKey = styleKeys[styleKeyIdx];
			this.mAllowedNormalizedStyles.set(CC.WikiEditor.TextBlockHelpers.styleValueToClassName(styleKey, styles.get(styleKey)), true);
		}
		logger().debug("Registered new inline text style (%@, %@)".fmt(className, styles));
		return true;
	},
	// Unregisters an inline text style if it exists.
	unregisterInlineTextStyle: function(inTextStyleIdentifer) {
		if (!inTextStyleIdentifer) return false;
		return this.mRegisteredStyles.unset(inTextStyleIdentifer);
	},
	// Renders a debug-friendly dialog capable of setting raw HTML and formatting options for
	// a text block by hand. Can be triggered on any text block.
	renderTextBlockDebugDialog: function() {
		this.mTextBlockDebugDialog = dialogManager().drawDialog('text_block_debug_dialog', [
			{label:'_Editor.Block.Text.Debug.Dialog.HTML.Label'.loc(), contents: '<textarea id="text_block_debug_dialog_html"/>'},
			{label:'_Editor.Block.Text.Debug.Dialog.Properties.Label'.loc(), contents: '<p id="text_block_debug_dialog_properties"></p>'},
		], "_Editor.Block.Text.Debug.Dialog.Update".loc(), undefined, "_Editor.Block.Text.Debug.Dialog.Title".loc(), "_Editor.Block.Text.Debug.Dialog.Cancel".loc());
	},
	// Initializes and shows a text block debug dialog for a given block. Returns false
	// where undefined or an invalid block is passed.
	showTextBlockDebugDialogForBlock: function(inEvent) {
		var element = inEvent.findElement('.block.text');
		if (!element) return false;
		var block = globalEditorController().blockForBlock(element);
		if (!block || !CC.kindOf(block, CC.WikiEditor.TextBlock)) return false;
		// Flush any pending changes before reading the state of the text block.
		block.handleDidStopEditing();
		var guid = block.getRecordPropertyForPath('guid');
		var extendedAttributes = block.getRecordPropertyForPath('extendedAttributes');
		var content = block.mViewInstance.$('.editable').innerHTML;
		var infoString = "GUID: %@, blockGUIDs: %@, containerGUID: %@".fmt(guid, extendedAttributes.blockGUIDs, extendedAttributes.containerGUID);
		// Update the dialog for the given block.
		$('text_block_debug_dialog_html').value = content;
		var debugDialogOptions, debugDialogOptionIdx, debugDialogOption;
		debugDialogOptions = $$('#text_block_debug_dialog option');
		for (debugDialogOptionIdx = 0; debugDialogOptionIdx < debugDialogOptions.length; debugDialogOptionIdx++) {
			debugDialogOption = debugDialogOptions[debugDialogOptionIdx];
			(debugDialogOption.value == tagName || debugDialogOption.value == alignment) ? debugDialogOption.setAttribute('selected', true) : debugDialogOption.removeAttribute('selected');
		}
		$('text_block_debug_dialog_properties').innerHTML = infoString;
		var callback = function(event, block) {
			markup = $('text_block_debug_dialog_html').value;
			block.setContent(markup);
		}
		// Show the dialog.
		dialogManager().show('text_block_debug_dialog', undefined, callback.bindAsEventListener(this, block));
	},
	// Initializes a copy/paste debug console that shows the current contents of the
	// offscreen simulated clipboard. Only shows in editor debug mode.
	renderCopyPasteDebugConsole: function() {
		var debugElem = Builder.node('div', {id: 'text_block_copy_paste_debug', className: 'collapsed chrome'}, [
			Builder.node('input', {type: 'button', className: 'clear', value: "_Editor.Block.Text.Debug.CopyPaste.Clear.Title".loc(), title: "_Editor.Block.Text.Debug.CopyPaste.Clear.Tooltip".loc()}),
			Builder.node('input', {type: 'button', className: 'toggle', value: "_Editor.Block.Text.Debug.CopyPaste.Toggle.Open.Title".loc(), title: "_Editor.Block.Text.Debug.CopyPaste.Toggle.Tooltip".loc()}),
			Builder.node('h2', {className: 'header'}, "_Editor.Block.Text.Debug.CopyPaste.Title".loc()),
			Builder.node('span', "_Editor.Block.Text.Debug.CopyPaste.Clipboard.Label".loc()),
			Builder.node('div', {className: 'clipboard'}),
		]);
		globalNotificationCenter().subscribe(CC.WikiEditor.NOTIFICATION_CLIPBOARD_DID_CHANGE, this.updateCopyPasteDebugConsole.bind(this));
		Element.observe(debugElem.down('input.clear'), 'click', this.handleCopyPasteDialogClear.bind(this));
		Element.observe(debugElem.down('input.toggle'), 'click', function(inEvent) {
			var _console = $('text_block_copy_paste_debug');
			this.toggleCopyPasteDebugConsole(inEvent, _console.hasClassName('collapsed'));
		}.bind(this));
		document.body.appendChild(debugElem);
	},
	handleCopyPasteDialogClear: function(inEvent) {
		$('text_block_copy_paste_debug').down('.clipboard').innerHTML = "";
	},
	updateCopyPasteDebugConsole: function(inMessage, inObject, inOptExtras) {
		$('text_block_copy_paste_debug').down('.clipboard').innerHTML = (inOptExtras.content.escapeHTML() || "_Editor.Block.Text.Debug.CopyPaste.Clipboard.Placeholder".loc());
	},
	toggleCopyPasteDebugConsole: function(inEvent, inShouldShowConsole) {
		var _console = $('text_block_copy_paste_debug');
		if (_console && (inShouldShowConsole != undefined)) {
			if (inShouldShowConsole) {
				_console.removeClassName('collapsed');
				_console.down('input.toggle').setValue("_Editor.Block.Text.Debug.CopyPaste.Toggle.Close.Title".loc());
			} else {
				_console.addClassName('collapsed');
				_console.down('input.toggle').setValue("_Editor.Block.Text.Debug.CopyPaste.Toggle.Open.Title".loc());
			}
		}
	},
	// 8764353
	// Normalizes inline styles for all text blocks or an optional text block on the page (using class names or
	// CSS style declarations). We convert any inline styled text to use a whitelist-friendly class name to avoid
	// potentially malicious inline style declarations and maintain page appearance. When the page first renders,
	// this method is automatically called for all text blocks. It is called in reverse when preparing individual
	// text blocks for save. You should not normally call this yourself.
	_normalizeInlineStyles: function(inShouldUseClassNames, inRootElement, inOptRecursiveElement) {
		var elem = $(inOptRecursiveElement || inRootElement);
		if (!elem) return false;
		if (!inOptRecursiveElement) {
			// 9314251
			// Bail if we don't have any tags with inline styles or font tags
			if ((!elem.down('font')) && (!elem.down('*[style]'))) return true;
			var formattingTags, formattingTagIdx, formattingTag;
			formattingTags = elem.select('b, i, u');
			for (formattingTagIdx = 0; formattingTagIdx < formattingTags.length; formattingTagIdx++) {
				formattingTag = formattingTags[formattingTagIdx];
				formattingTag.addClassName('wikieditor-textblock-deleteme');
			};
			// 7017852
			if (browser().isIE()) {
				var fontTags, fontTagIdx, fontTag;
				fontTags = elem.getElementsByTagName('font');
				for (fontTagIdx = 0; fontTagIdx < fontTags.length; fontTagIdx++) {
					fontTag = fontTags.item(fontTagIdx);
					var tempContainer = document.createElement('span');
					fontTag.parentNode.insertBefore(tempContainer, fontTag);
					tempContainer.innerHTML = Element.outerHtmlValue(fontTag).replace('FONT','SPAN');
					fontTag.parentNode.removeChild(fontTag);
					promoteElementChildren(tempContainer);
				}
			}
		} else {
			// Otherwise if we're recursing, bail if we're about to normalize a child-block.
			if (elem.hasClassName('block')) return true;
		}
		// If we're not using class names, we can heavily optimize converting to inline styles since we know exactly what
		// we're looking for. Also, by not querying the document for computed style values, we can normalize from classes
		// offscreen or in a fragment (9318032).
		if (!inShouldUseClassNames) {
			var stylesCache = textBlockDelegate().mRegisteredStyles;
			var stylesCacheKeys = stylesCache.keys(), stylesCacheIdx, stylesCacheKey, stylesCacheValue, styles, className;
			var tagsWithClassNames, tagWithClassName, styleKeys, styleKeyIdx, styleKey, _styles;
			for (stylesCacheIdx = 0; stylesCacheIdx < stylesCacheKeys.length; stylesCacheIdx++) {
				stylesCacheKey = stylesCacheKeys[stylesCacheIdx];
				stylesCacheValue = stylesCache.get(stylesCacheKey);
				styles = stylesCacheValue[2];
				className = stylesCacheValue[1];
				if (className) {
					tagsWithClassNames = elem.select("." + className);
					for (var tagIdx = 0; tagIdx < tagsWithClassNames.length; tagIdx++) {
						tagWithClassName = tagsWithClassNames[tagIdx];
						_styles = {};
						styleKeys = styles.keys();
						for (styleKeyIdx = 0; styleKeyIdx < styleKeys.length; styleKeyIdx++) {
							styleKey = styleKeys[styleKeyIdx];
							_styles[styleKey.camelize()] = styles.get(styleKey);
						}
						tagWithClassName.setStyle(_styles);
						tagWithClassName.removeClassName(className);
					}
				}
			}
			return true;
		}
		// For every non-whitespace text node child of the current working node, wrap the text node
		// in an <appletn> tag and re-apply the inherited styles to that tag.
		var childNodesLength = elem.childNodes.length, childNodeIdx, childNode, classNames, inheritedStylesString, tn, styles, styleIdx, style;
		for (childNodeIdx = 0; childNodeIdx < childNodesLength; childNodeIdx++) {
			var childNode = elem.childNodes.item(childNodeIdx);
			// Is the child a non-empty text node? 
			if (childNode.nodeType == 3 && childNode.nodeValue && childNode.nodeValue.match(/\S/)) {
				// Build an array of computed styles for the working element.
				var classNames = $A([]);
				for (var sIdx = 0; sIdx < CC.WikiEditor.TEXT_BLOCK_ALLOWED_INLINE_STYLES.length; sIdx++) {
					var s = CC.WikiEditor.TEXT_BLOCK_ALLOWED_INLINE_STYLES[sIdx];
					classNames.push(CC.WikiEditor.TextBlockHelpers.styleValueToClassName(s, elem.getStyle(s.camelize())));
				}
				// Wrap the working element (forcing inherited styles from the parent node).
				inheritedStylesString = CC.WikiEditor.TEXT_BLOCK_ALLOWED_INLINE_STYLES.join(': inherit; ') + ': inherit;';
				tn = Builder.node('appletn', {className: classNames.join(' '), style: inheritedStylesString}, childNode.nodeValue);
				elem.insertBefore(tn, childNode);
				// Clone the inherited styles to the newly inserted wrapper node and remove the originaltext node.
				styles = {}, styleIdx, style;
				for (styleIdx = 0; styleIdx < CC.WikiEditor.CAMELIZED_TEXT_BLOCK_ALLOWED_INLINE_STYLES.length; styleIdx++) {
					style = CC.WikiEditor.CAMELIZED_TEXT_BLOCK_ALLOWED_INLINE_STYLES[styleIdx];
					styles[style] = document.defaultView.getComputedStyle(tn, null)[style];
					if (style == 'fontWeight') styles[style] = CC.WikiEditor.TextBlockHelpers.normalizeBoldStyleValue(styles[style]);
				}
				Element.setStyle(tn, styles);
				Element.remove(childNode);
			}
			else if (childNode.nodeType == 1 && childNode.getAttribute('contentEditable') != false) {
				this._normalizeInlineStyles(inShouldUseClassNames, inRootElement, childNode);
			}
		}
		if (!inOptRecursiveElement) {
			// Remove all span tags and decorated formatting tags.
			var spans = elem.select('span'), spanIdx, span;
			for (spanIdx = spans.length - 1; spanIdx >= 0; spanIdx--) {
				span = spans[spanIdx];
				promoteElementChildren(span);
			}
			var formattingTags = elem.select('.wikieditor-textblock-deleteme'), formattingTagIdx, formattingTag;
			for (formattingTagIdx = formattingTags.length - 1; formattingTagIdx >= 0; formattingTagIdx--) {
				formattingTag = formattingTags[formattingTagIdx];
				promoteElementChildren(formattingTag);
			}
			// Convert any appletn wrapped text nodes back to styled text nodes using a combination of
			// bold, italic and underline formatting nodes and span tags with either class names or inline
			// styles depending on the value of inShouldUseClassNames passed.
			var tns = $A(elem.getElementsByTagName('appletn')), tnIdx, tn, tnClassNames, tnClassNameIdx, tnClassName;
			for (tnIdx = 0; tnIdx < tns.length; tnIdx++) {
				tn = tns[tnIdx];
				tnClassNames = tn.className.split(' ');
				// Are we normalizing to a class name on a wrapper element?
				if (inShouldUseClassNames) {
					var stylesCache = textBlockDelegate().mRegisteredStyles;
					var stylesCacheKeys = stylesCache.keys(), stylesCacheIdx, stylesCacheKey, stylesCacheValue, styles, styleKeys, styleKeysIdx, styleKey, className, allStylesPresent;
					for (stylesCacheIdx = 0; stylesCacheIdx < stylesCacheKeys.length; stylesCacheIdx++) {
						stylesCacheKey = stylesCacheKeys[stylesCacheIdx];
						stylesCacheValue = stylesCache.get(stylesCacheKey);
						styles = stylesCacheValue[2];
						styleKeys = styles.keys();
						className = stylesCacheValue[1];
						// Only swap styles for a registered class name where we (at least) have all styles
						// required for that class name. Wrap applicable nodes in a span with a className.
						allStylesPresent = true;
						for (styleKeysIdx = 0; styleKeysIdx < styleKeys.length; styleKeysIdx++) {
							styleKey = styleKeys[styleKeysIdx];
							if (!tn.hasClassName(CC.WikiEditor.TextBlockHelpers.styleValueToClassName(styleKey, styles.get(styleKey)))) allStylesPresent = false;
						}
						if (allStylesPresent && className != 'plain') {
							var spanWithClassName = Element.wrap(tn, 'span');
							Element.addClassName(spanWithClassName, className);
						}
					}
				}
				// Otherwise we're normalizing to inline styles/formatting tags surrounding a wrapper element.
				else {
					var styledSpan; 
					for (tnClassNameIdx = 0; tnClassNameIdx < tnClassNames.length; tnClassNameIdx++) {
						tnClassName = tnClassNames[tnClassNameIdx];
						if (!textBlockDelegate().mAllowedNormalizedStyles.get(tnClassName)) continue;
						if (tnClassName == 'font-weight-bold') {
							Element.wrap(tn, 'b');
						}
						else if (tnClassName == 'font-style-italic') {
							Element.wrap(tn, 'i');
						}
						else if (tnClassName == 'text-decoration-underline') {
							Element.wrap(tn, 'u');
						}
						else {
							var backgroundColorMatch = tnClassName.match(/^\s*(background-color-.+)\s*$/);
							if (backgroundColorMatch) {
								if (!styledSpan) styledSpan = Element.wrap(tn, 'span');
								Element.setStyle(styledSpan, {'backgroundColor': tn.getStyle('backgroundColor')});
							}
							var colorMatch = tnClassName.match(/^\s*(color-.+)\s*$/);
							if (colorMatch) {
								if (!styledSpan) styledSpan = Element.wrap(tn, 'span');
								Element.setStyle(styledSpan, {'color': Element.getStyle(tn, 'color')});
							}
						}
					}
					styledSpan = null;
				}
				promoteElementChildren(tn);
			}
		}
	},
	// Normalizes alignment properties for an optional text block on the page. Converts text-align
	// style declarations and align attributes to class names (and vice-versa).
	_normalizeTextAlignment: function(inShouldUseClassNames, inRootElement) {
		var elem = $(inRootElement);
		var alignments = 'left right center justify'.w(), alignedTags, alignedTagIdx, alignedTag, alignment;
		if (inShouldUseClassNames) {
			alignedTags = elem.select("*[align], *[style]");
			for (alignedTagIdx = (alignedTags.length - 1); alignedTagIdx >= 0; alignedTagIdx--) {
				alignedTag = alignedTags[alignedTagIdx];
				alignment = (alignedTag.hasAttribute('align') ? alignedTag.getAttribute('align') : alignedTag.style.textAlign);
				if (alignment && !/\s/.test(alignment) && (alignments.indexOf(alignment) != -1)) {
					alignedTag.removeAttribute('align');
					alignedTag.style.textAlign = '';
					alignedTag.addClassName('align-' + alignment);
				}
			}
		} else {
			var alignedTags = elem.select(".align-%@".fmt(alignments.join(', .align-')));
			for (var alignedTagIdx = (alignedTags.length - 1); alignedTagIdx >= 0; alignedTagIdx--) {
				alignedTag = alignedTags[alignedTagIdx];
				alignment = alignedTag.className.match(/align-([\w]*)/)[1];
				alignedTag.removeClassName('align-' + alignment);
				alignedTag.setStyle({
					'textAlign': alignment
				});
			}
		}
	},
	// Takes the current document selection and inserts delimeters at the start and end
	// points of the selection range.
	addDelimetersToCurrentSelection: function() {
		// Flush any unwanted delimeters first.
		$$('.' + this.mDelimeterClassName).invoke('remove');
		// Get the current selection if it exists.
		var selectedRange = globalEditorTextSelectionDelegate().getSelectionAsRange();
		var startDelimeter = document.createElement('span');
		startDelimeter.className = '%@ start'.fmt(this.mDelimeterClassName);
		var endDelimeter = document.createElement('span');
		endDelimeter.className = '%@ end'.fmt(this.mDelimeterClassName);
		var clonedNode = document.createElement('div');
		// Surround the selected range in two delimeter elements.
		if (selectedRange && selectedRange.cloneContents && selectedRange.insertNode) {
			var extractedFragment = selectedRange.cloneContents();
			clonedNode.appendChild(extractedFragment.cloneNode(true));
			// Insert the start delimeter.
			selectedRange.insertNode(startDelimeter);
			// Create a new, non-destructive range after the current selection.
			var range = document.createRange();
			range.setStart(selectedRange.endContainer, selectedRange.endOffset);
			// Insert the end delimeter.
			range.insertNode(endDelimeter);
		}
	},
	// Partitions a given DOM element based on the position of any child delimeters, returning three
	// complete node trees (before the first delimeter, between the first and second delimeter and
	// after the second delimeter). Where the element being partitioned only contains one delimeter
	// returns two complete node trees (before the delimeter and between the delimeter and the end of
	// the text block). To split on a delimeter, we start at the delimeter node and recursively remove
	// all the previous/next nodes at that working level before stepping up to the parent node and repeating
	// until we hit the root node. The result is split element with unwanted non-layout-affecting peer nodes
	// removed. You should not normally call this method yourself.	
	partitionElement: function(inElement) {
		if (!inElement) return;
		logger().debug("partitionElement: %o", inElement.innerHTML);
		// Ensure we have at least one delimeter before we clone any nodes.
		var delimeters = inElement.getElementsByClassName(this.mDelimeterClassName);
		if (!delimeters || delimeters.length == 0) return;
		// Clone the root node twice so we can create two adjusted trees.
		var leftTree = inElement.cloneNode(true), rightTree = inElement.cloneNode(true);
		var leftTreeDelimeter = leftTree.querySelector('.' + this.mDelimeterClassName);
		var rightTreeDelimeter = rightTree.querySelector('.' + this.mDelimeterClassName);
		// Recursively prunes peer node up to the root element.
		var pruneTree = function(inDelimeterNode, inOptPruneDirection, inOptRemoveNodeIdentifiers) {
			var workingNode = inDelimeterNode, sibling;
			while (workingNode && workingNode.parentNode) {
				if (inOptRemoveNodeIdentifiers && workingNode.id) workingNode.removeAttribute('id');
				sibling = (inOptPruneDirection == 'left' ? workingNode.previousSibling : workingNode.nextSibling);
				if (sibling == undefined) {
					workingNode = workingNode.parentNode;
					continue;
				}
				workingNode.parentNode.removeChild(sibling);
			}
			// Remove any cloned delimeters from the tree.
			if (inDelimeterNode && inDelimeterNode.parentNode) inDelimeterNode.parentNode.removeChild(inDelimeterNode);
			// Return.
			return workingNode;
		}
		// Initialize an array of partitions, and compute the partitions.
		var partitions = new Array();
		// Prune the cloned elements.
		leftTree = pruneTree(leftTreeDelimeter);
		rightTree = pruneTree(rightTreeDelimeter, 'left', true);
		partitions.push(leftTree.innerHTML);
		// Do we have another delimeter to partition on?
		if (rightTree.querySelector('.' + this.mDelimeterClassName)) {
			partitions = partitions.concat(this.partitionElement(rightTree));
		} else {
			partitions.push(rightTree.innerHTML);
		}
		// Remove any delimeter elements from the original element.
		var delimeterIdx, delimeter;
		for (delimeterIdx = (delimeters.length - 1); delimeterIdx >= 0; delimeterIdx--) {
			delimeter = delimeters.item(delimeterIdx);
			delimeter.parentNode.removeChild(delimeter);
		}
		// Return our newly computed partitions.
		logger().debug("partitions: %o", partitions);
		return partitions;
	},
	// Handles a change in edit mode on the page. Configures contentEditable on any text blocks on
	// the page, and exchanges classes for inline style declarations.
	handleEditModeDidChange: function(inMessage, inObject, inOptExtras) {
		var editable = (inMessage == CC.WikiEditor.NOTIFICATION_DID_START_EDITING) ? true : false;
		// Configure contentEditable on all text blocks.
		var editorView = globalEditorController().mEditorView.$();
		var editables = (editorView ? editorView.select('.block.text .editable') : []), editableIdx, _editable;
		for (editableIdx = 0; editableIdx < editables.length; editableIdx++) {
			_editable = editables[editableIdx];
			_editable.setAttribute('contentEditable', editable);
		}
		// If we need to, configure debug links.
		if (globalEditorController().mDebugMode) {
			var debugLinks = $$('.block.text .inner .debug'), debugLinkIdx, debugLink;
			var boundShowTextBlockDebugDialog = this.showTextBlockDebugDialogForBlock.bind(this);
			for (debugLinkIdx = 0; debugLinkIdx < debugLinks.length; debugLinkIdx++) {
				debugLink = debugLinks[debugLinkIdx];
				Event.observe(debugLink, 'click', boundShowTextBlockDebugDialog);
			}
		}
	},
	// Appends the result of a markup migration to a given block at an optionally restored selection point.
	// Since migrations are internally consistent, appends the contents of the text block at the root of the
	// migration result to the given block at the current/restored selection point. Following that, any child
	// blocks are added and placeholder elements expanded.
	appendMigratedContentToBlockAtSelection: function(inBlock, inMigrationResult, inOptRestoreSelection) {
		if (!CC.kindOf(inBlock, CC.WikiEditor.TextBlock) || (!inMigrationResult || !inMigrationResult.extendedAttributes.content)) return false;
		if (inOptRestoreSelection) {
			// 9454485
			if (browser().isFirefox()) inBlock.mViewInstance._editable.focus();
			try { globalEditorTextSelectionDelegate().restoreSelection(); } catch(e) {}
		}
		var _fragment = this.buildFragmentForBulkAddMigratedResultToBlock(inMigrationResult, inBlock);
		// 9408143
		// Insert a placeholder with an empty text node child, otherwise insertHTML will skip it.
		inBlock.mViewInstance.insertHTML('<img class="wikieditor-paste-placeholder"/>');
		// Find and replace the placeholder we just created.
		var placeholder = inBlock.mViewInstance.$('.wikieditor-paste-placeholder');
		if (placeholder) {
			placeholder.parentNode.insertBefore(_fragment, placeholder);
			// 9382142
			// Create a wrapping span around the placeholder element, and give it focus. This span will
			// be cleaned up sometime later when the content of the parent text block is normalized.
			var wrapperSpan = Element.wrap(placeholder, 'span');
			placeholder.parentNode.removeChild(placeholder);
			wrapperSpan.focus();
			globalEditorTextSelectionDelegate().selectAllChildren(wrapperSpan);
		}
	},
	// Appends the result of a migration to a given block, working inside a document fragment. Accepts an
	// optional editor argument for cases where we're not appending to the globalEditorController shared
	// instance.
	buildFragmentForBulkAddMigratedResultToBlock: function(inMigrationResult, inBlock, inOptEditor) {
		// Append the markup of the first migrated text block, working inside a document fragment.
		var _fragment = document.createDocumentFragment();
		var _workingElement = _fragment.appendChild(Element.extend(document.createElement('span')));
		var topLevelTextBlockMarkup = (inMigrationResult.extendedAttributes || {}).content;
		_workingElement.innerHTML = topLevelTextBlockMarkup;
		// Next migrate any child blocks in place. Child blocks will automatically be rendered in the position
		// of a corresponding placeholder element where it exists.
		var editorInstance = (inOptEditor || globalEditorController());
		if (!editorInstance) return _fragment;
		var _childBlocks = inMigrationResult._childBlocks, _childBlockIdx, _childBlock;
		if (_childBlocks && (_childBlocks.length > 0)) {
			for (_childBlockIdx = 0; _childBlockIdx < _childBlocks.length; _childBlockIdx++) {
				_childBlock = _childBlocks[_childBlockIdx];
				editorInstance.bulkAddBlock(_childBlock, undefined, inBlock, false, _workingElement);
			}
		}
		return _fragment;
	},
	attemptUndo: function() {
		try {
			document.execCommand('undo', false)
		} catch (e) {};
	}
};

// Text block controller.

CC.WikiEditor.TextBlock = Class.create(CC.WikiEditor.Block, CC.WikiEditor.Mixins.Navigation, {
	mBlockView: 'CC.WikiEditor.TextBlockView',
	mIsContainer: true,
	// Proxy most controller methods off to the view for this block.
	setContent: function() {
		return this.mViewInstance.setContent.apply(this.mViewInstance, arguments);
	},
	setFormatting: function() {
		return this.mViewInstance.setFormatting.apply(this.mViewInstance, arguments);
	},
	setStyle: function() {
		return this.mViewInstance.setStyle.apply(this.mViewInstance, arguments);
	},
	setAlignment: function() {
		return this.mViewInstance.setAlignment.apply(this.mViewInstance, arguments);
	},
	setListStyle: function() {
		return this.mViewInstance.setListStyle.apply(this.mViewInstance, arguments);
	},
	adjustIndentation: function() {
		return this.mViewInstance.adjustIndentation.apply(this.mViewInstance, arguments);
	},
	moveToStart: function() {
		return this.mViewInstance.moveToStart.apply(this.mViewInstance, arguments);
	},
	moveToEnd: function() {
		return this.mViewInstance.moveToEnd.apply(this.mViewInstance, arguments);
	},
	focusedAtStart: function() {
		return this.mViewInstance.focusedAtStart.apply(this.mViewInstance, arguments);
	},
	focusedAtEnd: function() {
		return this.mViewInstance.focusedAtEnd.apply(this.mViewInstance, arguments);
	},
	isEmpty: function() {
		var layer = this.mViewInstance.$('.editable');
		var val = (layer && layer.innerHTML);
		// Is the innerHTML of the editable element empty?
		var hasValue = ((val != undefined) && (val != ""));
		// If not, clone the editable element and strip any meaningless markup. If we're
		// left anything less than a single <br> tag, the node is considered empty.
		if (hasValue) {
			var clonedLayer = layer.cloneNode(true);
			removeMeaninglessMarkup(clonedLayer);
			if (clonedLayer.hasChildNodes()) {
				if (clonedLayer.childNodes.length == 1) {
					if (clonedLayer.firstChild.nodeName.toLowerCase() == 'br') return true;
				}
			} else {
				return true;
			}
			return false;
		}
		return true;
	},
	isExplosive: function() {
		return false;
	},
	handleDidStartEditing: function($super, inOptInfo) {
		$super.apply(null, Array.prototype.slice.call(arguments, 1));
		if (inOptInfo && inOptInfo.propagated) return true;
		// We only need to focus the contenteditable field to do text selection queries.
		// We explicitly choose not to focus if this callback was fired by a mouse event.
		var focus = false;
		// Was focus explicitly passed as false?
		if (inOptInfo && (inOptInfo.focus != false)) {
			focus = true;
		}
		// Should we position the cursor at the beginning?
		var start = inOptInfo ? inOptInfo.moveToStart : false;
		// Or the end?
		var end = inOptInfo ? inOptInfo.moveToEnd : false;
		this.mViewInstance._activate(focus, start, end);
	},
	handleDidStopEditing: function($super, inOptInfo) {
		$super();
		if (inOptInfo && inOptInfo.propagated) return true;
		this.mViewInstance._deactivate();
	},
	addLink: function(inLink, inEvent) {
		if (this.mViewInstance) this.mViewInstance.showLinkDialog(inEvent);
	},
	handleDidAddBlock: function($super, inOptInfo) {
		// Do we have a placeholder DOM element corresponding to the position of the child block view?
		// If we do, remove the placeholder element and replace it with the newly rendered block view.
		// Otherwise insert the block at the current cursor position (if we have one).
		if (!inOptInfo.block) return false;
		var blockGUID = inOptInfo.block.getRecordPropertyForPath('guid');
		var workingElement = (inOptInfo.workingElement || this.mViewInstance.$());
		var placeholder = workingElement.down(".block-placeholder[data-guid=\"%@\"]".fmt(blockGUID));
		var renderedResult;
		if (!placeholder) {
			// If we don't have a specific placeholder for this block, do we have a generic one? A
			// placeholder should only ever not have a specific GUID if it is declared in one of our
			// default page templates. Bit of a hack...
			var _placeholder = workingElement.down(".block-placeholder");
			if (_placeholder && !_placeholder.getAttribute('data-guid')) placeholder = _placeholder;
		}
		if (placeholder) {
			renderedResult = blockRenderingDelegate().renderAndInsertBlockAtPosition(inOptInfo.block, {'after': placeholder});
			placeholder.parentNode.removeChild(placeholder);
		} else if (inOptInfo.position) {
			renderedResult = blockRenderingDelegate().renderAndInsertBlockAtPosition(inOptInfo.block, inOptInfo.position);
		} else {
			// This may well fail, depending on whether we have a selection or not.
			try { globalEditorTextSelectionDelegate().restoreSelection(); } catch (e) {};
			renderedResult = blockRenderingDelegate().renderAndInsertBlock(inOptInfo.block);
			// If we don't have a selection, or inserting the block failed, fall back to inserting at
			// the end of this blocks view instance element.
			if (!renderedResult) {
				var editableElement = workingElement.down('.editable');
				if (editableElement) renderedResult = blockRenderingDelegate().renderAndInsertBlockAtPosition(inOptInfo.block, {'bottom': editableElement});
			}
		}
		if (!renderedResult) {
			logger().error("Could not add sub-block (%@) to text block (%@)", inOptInfo.block, this);
		}
		$super.apply(null, Array.prototype.slice.call(arguments, 1));
	},
	// Autosave support.
	restore: function($super, inChangesets) {
		var changesetKey, changesetValue, changesetIdx, changes;
		for (changesetIdx = 0; changesetIdx < inChangesets.length; changesetIdx++) {
			changes = inChangesets[changesetIdx];
			if (changes.length < 2) continue;
			changesetKey = changes[0];
			changesetValue = changes[1];
			if (changesetKey != 'extendedAttributes') continue;
			var content = changesetValue['content'];
			if (content) this.mViewInstance.setContent(content);
		}
		$super(inChangesets);
	}
});

CC.WikiEditor.TextBlockView = Class.create(CC.WikiEditor.BlockView, CC.WikiEditor.Mixins.Prediction, CC.WikiEditor.Mixins.Comparable, {
	mDefaultContent: "",
	mPasteHandlerDelay: 100,
	mChangeHandlerDelay: 5000,
	renderAsHTML: function() {
		var block = this.mContent;
		var attrs = block.getRecordPropertyForPath('extendedAttributes');
		var content = (attrs['content'] || this.mDefaultContent);
		var isPlaceholder = attrs['placeholder'], isEditable = block.isEditable();
		// If this block is a placeholder text block, render placeholder content. We first check for a
		// placeholderStringKey in the block extended attributes falling back to a default placeholder 
		// string where necessary.
		var innerHTML = (content || "");
		if (isPlaceholder && (!content || content.isWhitespace())) {
			var placeholderStringKey = block.getRecordPropertyForPath('extendedAttributes.placeholderStringKey', "_Editor.Block.Text.Placeholder");
			innerHTML = placeholderStringKey.loc();
		}
		// 9261334
		var tagName = attrs['tagName'], alignment = attrs['alignment'];
		var extraSeedClassNames = "";
		if (tagName || alignment) extraSeedClassNames += " " + ((tagName || "") + (alignment ? " align-%@".fmt(alignment) : ""));
		// Build the rendered text block.
		var html = "<div id=\"%@\" class=\"editable wrapchrome%@\" contentEditable=\"%@\">%@</div>".fmt(this.getEventDelegateIdentifer() + "-editable", extraSeedClassNames, isEditable, innerHTML);
		this._cachedContent = (innerHTML || "");
		return html;
	},
	registerEventHandlers: function() {
		this._editable = this.$().down('.editable');
		if (!this._editable) return;
		bindEventListeners(this, [
			'handleContentEditableMouseDown',
			'handleContentEditablePaste',
			'handleContentEditableDidFocus',
			'handleContentEditableDidBlur'
		]);
		var editableIdentifer = this.getEventDelegateIdentifer() + "-editable";
		globalEventDelegate().bulkRegisterDomResponderForEventByIdentifer([
			['mousedown', editableIdentifer, this.handleContentEditableMouseDown],
			['paste', editableIdentifer, this.handleContentEditablePaste],
			['focus', editableIdentifer, this.handleContentEditableDidFocus],
			['blur', editableIdentifer, this.handleContentEditableDidBlur]
		]);
		this.addExternalLinkTargets();
		this.initializePoorMansChangeObserver();
	},
	// Once the view has rendered, immediately convert classes to inline styles. We always work in inline
	// style declarations for performance. Note that when a text block is edited it pushes a deferred store
	// update that recalculates its HTML content value using normalized class name styles on a cloned DOM
	// node. On save - the page refreshes, and handleDidRenderView is called on the new view instance that
	// was just added. We normalize inline styles as soon as the view is rendered for performance (so we
	// don't recursively try to normalize styles on a nested tree of blocks).
	handleDidRenderView: function($super, inOptInfo) {
		$super.apply(null, Array.prototype.slice.call(arguments, 1));
		// Normalize inline styles before any child blocks are added to this parent.
		textBlockDelegate()._normalizeTextAlignment(false, this._editable);
		textBlockDelegate()._normalizeInlineStyles(false, this._editable);
	},
	_activate: function(inOptFocus, inOptMoveToStart, inOptMoveToEnd) {
		if (!this._editable) return;
		var block = this.mContent.mRecord;
		var attrs = block.extendedAttributes;
		if (inOptFocus) {
			if ((attrs.placeholder || inOptMoveToStart || inOptMoveToEnd) && this._editable) this._editable.focus();
			if (!attrs.placeholder && inOptMoveToStart) this.mContent.moveToStart();
			if (!attrs.placeholder && inOptMoveToEnd) this.mContent.moveToEnd();
		}
	},
	_deactivate: function() {
		// See prepareForEdit. Instead of setting content on deactivate, we set it on a change timer.
	},
	// Workaround the fact that change handlers refuse to fire for contentEditable elements and DOM mutation
	// events are EXTREMELY expensive in IE/Firefox by rigging up a poor-mans change observer.
	initializePoorMansChangeObserver: function() {
		if (this.mContentEditableChangeInterval) clearInterval(this.mContentEditableChangeInterval);
		var _observer = function() {
			if (!this.mPushedDeferredContentChange) {
				if (this.mContentEditableChangeInterval) clearInterval(this.mContentEditableChangeInterval);
				this.mContent.setRecordPropertyForPathUsingDeferred('extendedAttributes.content', this.prepareAndReturnMarkupForSave.bind(this));
				this.mPushedDeferredContentChange = true;
			}
		}.bind(this);
		this.mContentEditableChangeInterval = setInterval(_observer, this.mChangeHandlerDelay);
		// 9390569
		return _observer();
	},
	// Callback function called on page save when the editable region of this block has changed.
	prepareAndReturnMarkupForSave: function() {
		// Work on a clone so we don't lose the active selection by manipulating the DOM when autosaving changes.
		// The clone MUST be added to the dom so we can query computed styles when normalizing styles.
		var elem = this._editable.cloneNode(true);
		elem.style.display = 'none';
		document.body.appendChild(elem);
		// Replace child blocks with placeholders.
		this.replaceChildBlocksWithPlaceholders(elem);
		// Remove any external link targets.
		this.removeExternalLinkTargets(elem);
		// Normalize alignment and inline styles.
		textBlockDelegate()._normalizeTextAlignment(true, elem);
		textBlockDelegate()._normalizeInlineStyles(true, elem);
		// Remove any meaningless markup.
		removeMeaninglessMarkup(elem);
		// Remove any unwanted styles.
		CC.WikiEditor.TextBlockHelpers.fixInlineStyles(elem);
		var _innerHTML = elem.innerHTML;
		elem.parentNode.removeChild(elem);
		return _innerHTML;
	},
	handleContentEditableDidFocus: function(inEvent) {
		globalNotificationCenter().publish(CC.WikiEditor.NOTIFICATION_BLOCK_CONTENTEDITABLE_DID_FOCUS, this.mContent);
	},
	handleContentEditableDidBlur: function(inEvent) {
		this._deactivate();
		globalNotificationCenter().publish(CC.WikiEditor.NOTIFICATION_BLOCK_CONTENTEDITABLE_DID_BLUR, this.mContent);
	},
	handleKeyboardNotification: function(inMessage, inObject, inOptExtras) {
		if (inMessage == CC.Keyboard.NOTIFICATION_DID_KEYBOARD_BACKSPACE || inMessage == CC.Keyboard.NOTIFICATION_DID_KEYBOARD_DELETE || inMessage == CC.Keyboard.NOTIFICATION_DID_KEYBOARD_FORWARD_DELETE) {
			if (inOptExtras.event) inOptExtras.event.stopPropagation();
			return false;
		}
		if (inMessage == CC.Keyboard.NOTIFICATION_DID_KEYBOARD_INDENT || inMessage == CC.Keyboard.NOTIFICATION_DID_KEYBOARD_OUTDENT) {
			var direction = (inMessage == CC.Keyboard.NOTIFICATION_DID_KEYBOARD_OUTDENT ? 'outdent' : 'indent');
			this.adjustIndentation(direction);
			Event.stop(inOptExtras.event);
			return true;
		}
	},
	moveToStart: function() {
		return globalEditorTextSelectionDelegate().moveCursorToStart(this._editable);
	},
	moveToEnd: function() {
		return globalEditorTextSelectionDelegate().moveCursorToEnd(this._editable);
	},
	focusedAtStart: function() {
		return globalEditorTextSelectionDelegate().isCursorFocusedAtStart(this._editable);
	},
	focusedAtEnd: function() {
		return globalEditorTextSelectionDelegate().isCursorFocusedAtEnd(this._editable);
	},
	// Returns a comparable, sortable value for this block.
	getComparableValue: function() {
		return Element.textValue(this._editable);
	},
	// Raw html manipulation.
	insertHTML: function(inHTML) {
		if (browser().isIE()) {
			if (document.selection.type == 'None') this._editable.innerHTML += inHTML;
			else document.selection.createRange().pasteHTML(inHTML);
		}
		else {
			if (document.queryCommandEnabled('inserthtml')) {
				document.execCommand('inserthtml', false, inHTML);
			}
		}
	},
	// Removes the placeholder flag from this text block if it is set.
	removePlaceholderFlag: function() {
		var placeholder = this.mContent.getRecordPropertyForPath('extendedAttributes.placeholder');
		if (placeholder) this.mContent.setRecordPropertyForPath('extendedAttributes.placeholder', false);
	},
	// Triggers an editor toolbar update.
	triggerToolbarUpdate: function() {
		globalNotificationCenter().publish(CC.WikiEditor.NOTIFICATION_EDITOR_SHOULD_UPDATE_TOOLBAR, this, {'block': this.mContent});
	},
	// Contextual toolbar actions for text formatting.
	setContent: function(inContent) {
		this.removeExternalLinkTargets();
		var content = (inContent || this._editable.innerHTML);
		if (content != this._cachedContent) {
			if (inContent != undefined) this._editable.innerHTML = content;
			this.mContent.setRecordPropertyForPath('extendedAttributes.content', content);
			this._cachedContent = content;
			this.removePlaceholderFlag();
		}
		this.addExternalLinkTargets();
		return true;
	},
	setFormatting: function(inFormatting) {
		if (!inFormatting) return;
		try { globalEditorTextSelectionDelegate().restoreSelection(); } catch(e) {};
		var formatting = inFormatting;
		if (browser().isIE()) formatting = "<%@>".fmt(formatting);
		document.execCommand('formatblock', false, (browser().isIE() ? "<p>" : "p"));
		// 5297272
		document.execCommand('outdent', false, null);
		// We overload the blockquote tag for both quote styling, and indentation. If we're applying
		// in the former context, track any blockquote tags before the operation and add a class name
		// to any new blockquote tags added as a result of the operation. Since IE doesn't support
		// formatBlock using blockquote, temporarily format as h4 tags.
		var fakeBlockquotes;
		if (inFormatting == 'blockquote') {
			formatting = browser().isIE() ? "<h4>" : "h4";
			fakeBlockquotes = $$('.block .editable h4');
		}
		// Apply the formatting.
		document.execCommand('formatblock', false, formatting);
		// Touch up any fake blockquotes.
		if (inFormatting == "blockquote") {
			var _fakeBlockquotes = $$('.block .editable h4'), _fakeBlockquote;
			for (var idx = (_fakeBlockquotes.length - 1); idx >= 0; idx--) {
				_fakeBlockquote = _fakeBlockquotes[idx];
				if (fakeBlockquotes.indexOf(_fakeBlockquote) == -1) {
					var blockquote = Element.wrap(_fakeBlockquote, 'blockquote');
					blockquote.addClassName('quote');
					promoteElementChildren(blockquote.firstChild);
				}
			}
		}
		this.triggerToolbarUpdate();
	},
	setStyle: function(inStyle) {
		if (!inStyle) return;
		try { globalEditorTextSelectionDelegate().restoreSelection(); } catch(e) {};
		// Special-case plain styles and remove everything.
		if (inStyle == 'plain') {
			if (globalEditorTextSelectionDelegate().currentSelectionIsEmpty()) {
				if (document.queryCommandState('bold')) document.execCommand('bold', false, null);
				if (document.queryCommandState('italic')) document.execCommand('italic', false, null);
				if (document.queryCommandState('underline')) document.execCommand('underline', false, null);
				document.execCommand('foreColor', false, 'inherit');
				document.execCommand('backColor', false, 'inherit');
			}
			document.execCommand('removeFormat', false, null);
		}
		// Do we have any styles to apply?
		var style = textBlockDelegate().mRegisteredStyles.get(inStyle);
		if (style && style[2]) {
			var isIE = browser().isIE();
			// Apply any inline styles.
			// 5366338
			if (!isIE) document.execCommand('styleWithCSS', false, true);
			var styles = style[2];
			var styleKeys = styles.keys(), styleKeyIdx, styleKey, styleValue;
			for (styleKeyIdx = 0; styleKeyIdx < styleKeys.length; styleKeyIdx++) {
				styleKey = styleKeys[styleKeyIdx];
				styleValue = styles.get(styleKey);
				this._applyInlineStyle(styleKey, styleValue);
			}
			if (!isIE) document.execCommand('styleWithCSS', false, false);
		}
		CC.WikiEditor.TextBlockHelpers.fixInlineStyles(this._editable);
	},
	// Use execCommand to apply inline styles we know will work cross-browser.
	// http://www.quirksmode.org/dom/execCommand.html
	_applyInlineStyle: function(inStyleProperty, inOptStyleValue) {
		logger().debug("_applyInlineStyle: %o %o", inStyleProperty, inOptStyleValue);
		if (!inStyleProperty) return false;
		var styleValue = (inOptStyleValue || '');
		switch (inStyleProperty) {
			case 'background-color':
			case 'color':
				// 5369907
				if (browser().isIE()) styleValue = styleValue.replace(/^#/, '');
				var attr = (inStyleProperty == 'color' ? 'foreColor' : 'backColor');
				document.execCommand(attr, false, styleValue);
				break;
			case 'font-style':
				if (styleValue == 'italic' && !document.queryCommandState('italic')) document.execCommand('italic', false, null);
				break;
			case 'font-weight':
				// Convert integer boldness values to either bold or normal.
				styleValue = CC.WikiEditor.TextBlockHelpers.normalizeBoldStyleValue(styleValue);
				if ((styleValue == 'bold' && !document.queryCommandState('bold')) || (styleValue == 'normal' && document.queryCommandState('bold'))) document.execCommand('bold', false, null);
				break;
			case 'text-decoration':
				if (styleValue == 'underline' && !document.queryCommandState('underline')) document.execCommand('underline', false, null);
				break;
		}
	},
	setAlignment: function(inAlignment) {
		if (!this._editable || !inAlignment) return;
		document.execCommand('justifynone', false, null);
		var alignment = inAlignment;
		if (alignment == "justify") alignment = "full";
		alignment = "justify%@".fmt(alignment);
		document.execCommand(alignment, false, null);
		this.triggerToolbarUpdate();
	},
	showLinkDialog: function(inEvent, inOptAnchor) {
		var anchor = inOptAnchor || (inEvent && inEvent.findElement('li.item'));
		var selectedString = globalEditorTextSelectionDelegate().getSelectedString();
		textBlockDelegate().showSmartLinkPopup(anchor, undefined, selectedString, this.addLink.bind(this), this.handleLinkDialogCancelled.bind(this));
	},
	handleLinkDialogCancelled: function(inEvent) {
		this._activate(true);
		try { globalEditorTextSelectionDelegate().restoreSelection(); } catch(e) {};
	},
	// Makes the existing selection a link if it exists, or adds a new link.
	addLink: function(inURL, inLinkText) {
		this._activate(true);
		try { globalEditorTextSelectionDelegate().restoreSelection(); } catch(e) {};
		if (inURL && inURL != "" && !inURL.isWhitespace()) {
			// Always link to something.
			if (!inURL.match(/^\/|[A-Za-z]+:/i)) inURL = 'http://' + inURL;
			// Do we have an empty selection?
			if (globalEditorTextSelectionDelegate().currentSelectionIsEmpty()) {
				var match = inURL.match(/\/([^\/])$/);
				var linkText = inLinkText || (match ? match[1] : inURL);
				this.insertHTML('<a href=\"%@\">%@</a>'.fmt(inURL, linkText.escapeHTML()));
			} else {
				document.execCommand('createlink', false, inURL);
			}
		} else {
			// Strip any links if a URL isn't specified.
			document.execCommand('unlink');
		}
	},
	removeExternalLinkTargets: function(inOptElement) {
		(inOptElement || this._editable).select('a').invoke('removeAttribute', 'target');
	},
	addExternalLinkTargets: function(inOptElement) {
		var links = (inOptElement || this._editable).select('a'), href, linkIdx, link
		for (linkIdx = 0; linkIdx < links.length; linkIdx++) {
			link = links[linkIdx];
			href = link.getAttribute('href');
			if (href && href.match(/^[A-Za-z]+:\/{2,3}/)) link.setAttribute('target', '_blank');
		}
	},
	// Replaces first-descendant child blocks of this text block with rendering placeholders.
	// A rendering placeholder is a div.wiki-block-placeholder element.
	replaceChildBlocksWithPlaceholders: function(inOptWorkingElement) {
		var topLevelBlockGUIDs = this.mContent.computeBlockGUIDs();
		if (!topLevelBlockGUIDs || topLevelBlockGUIDs.length == 0) return;
		var selector = "";
		if (topLevelBlockGUIDs.length == 1) {
			selector = ".block[data-guid=\"" + topLevelBlockGUIDs[0] + "\"]";
		} else {
			var lastGUID = topLevelBlockGUIDs.pop();
			selector = ".block[data-guid=\"" + topLevelBlockGUIDs.join("\"], .block[data-guid=\"") + "\"], .block[data-guid=\"" + lastGUID + "\"]";
		}
		var firstLevelBlocks = $(inOptWorkingElement).select(selector), blockIdx, block, blockAttrs;
		if (!firstLevelBlocks || firstLevelBlocks.length == 0) return;
		var placeholder, _placeholder = document.createElement('div');
		_placeholder.className = 'block-placeholder';
		for (var blockIdx = 0; blockIdx < firstLevelBlocks.length; blockIdx++) {
			block = firstLevelBlocks[blockIdx];
			if (block) {
				blockAttrs = block.getDataAttributes();
				placeholder = _placeholder.cloneNode(false);
				placeholder.setAttribute('data-guid', blockAttrs.guid);
				placeholder.setAttribute('data-type', blockAttrs.type);
				placeholder.appendChild(document.createTextNode(blockAttrs.guid));
				block.parentNode.replaceChild(placeholder, block);
			}
		}
	},
	setListStyle: function(inListStyle) {
		switch (inListStyle) {
			case 'bulleted':
				document.execCommand('insertUnorderedList', false, null);
				break;
			case 'numbered':
				document.execCommand('insertOrderedList', false, null);
				break;
			case 'unformatted':
			default:
				// Toggle an existing list state if it exists.
				var isOrderedList = document.queryCommandState('insertOrderedList');
				var isUnorderedList = document.queryCommandState('insertUnorderedList');
				if (isOrderedList || isUnorderedList) {
					document.execCommand((isOrderedList ? 'insertOrderedList' : 'insertUnorderedList'), false, null);
				}
				break;
		}
		
		// 13483959
		if (browser().isIE()) {
			_globalEditorController.mEditorView.mPageView.mParentElement = $(_globalEditorController.mEditorView.mParentElement.querySelector('.page.blocks.selectable.wrapchrome.cc-view'));
		}
	},
	adjustIndentation: function(inIndentationDirection) {
		if (inIndentationDirection && $A(['indent', 'outdent']).include(inIndentationDirection)) document.execCommand(inIndentationDirection, false, null);
	},
	toolbarSettingsForKeys: function(inKeys) {
		var result = new Hash();
		var alignment = 'left';
		if (document.queryCommandState('justifyright')) alignment = 'right';
		if (document.queryCommandState('justifycenter')) alignment = 'center';
		if (document.queryCommandState('justifyfull')) alignment = 'justify';
		var keys = $A(inKeys), keyIdx, key;
		for (keyIdx = 0; keyIdx < keys.length; keyIdx++) {
			key = keys[keyIdx];
			result.set(key, {
				'enabled': true,
				'selected': (alignment == key)
			});
		}
		return result;
	},
	// Cleans up the last trailing line break in this text block.
	cleanLastTrailingLineBreak: function() {
		CC.WikiEditor.TextBlockHelpers.cleanLastTrailingLineBreak(this._editable);
	},
	// Cleans up the last trailing list item in this text block.
	cleanLastTrailingListItem: function() {
		CC.WikiEditor.TextBlockHelpers.cleanLastTrailingListItem(this._editable);
	},
	// 9272663
	handleContentEditableMouseDown: function(inEvent) {
		if (inEvent) inEvent.stopPropagation();
	},
	// Handles a paste event in a text block, migrating any pasted nodes to blocks.
	// We catch the paste event and redirect the paste to an off-screen focused element
	// where, after a delay, we process the markup by running it through a migrator.
	handleContentEditablePaste: function(inEvent) {
		var textSelectionDelegate = globalEditorTextSelectionDelegate();
		// Cache the current window selection.
		textSelectionDelegate.cacheSelection();
		// Stage something offscreen to recieve a paste event.
		globalEditorController().mCopyPasteDelegate.prepareToPaste();
		// Show a progress message.
		dialogManager().showProgressMessage("_Editor.Migration.Progress.CopyPaste".loc());
		// Give the runtime 100ms to process the paste event.
		setTimeout(function() {
			// If this text block is nested inside a table, remove any tables from the clipboard.
			// We don't allow tables inside tables.
			var elem = globalEditorController().mCopyPasteDelegate.mOffscreenElement;
			if (this.$().up('.block.table')) {
				var tables = elem.select('table'), table;
				for (var tableIdx = (tables.length - 1); tableIdx >= 0; tableIdx--) {
					table = tables[tableIdx];
					Element.insert(table, {'before': Builder.node('div', Element.textValue(table))});
					table.parentNode.removeChild(table);
				}
			}
			// Fetch the clipboard contents and migrate it.
			var markup = globalEditorController().mCopyPasteDelegate.clipboard(false);
			var migrated = globalEditorMigrationController().migrate(markup);
			// Restore the cached text selection, and process the migration result.
			textBlockDelegate().appendMigratedContentToBlockAtSelection(this.mContent, migrated, true);
			dialogManager().hideProgressMessage();
			return true;
		}.bind(this), this.mPasteHandlerDelay);
		// Return false to override default paste behavior.
		return false;
	}
});

// Define our text block toolbar.

CC.WikiEditor.TextBlockToolbar = Class.create(CC.WikiEditor.BlockToolbar, {
	mToolbarItems: [
		new CC.WikiEditor.EditorToolbarItem({
			mDisplayTitle: "_Editor.Block.Text.Toolbar.Formatting.Title".loc(),
			mTooltip: "_Editor.Block.Text.Toolbar.Formatting.Tooltip".loc(),
			mToolbarStyle: CC.WikiEditor.EDITOR_TOOLBAR_ITEM_STYLE_POPUP,
			mKey: 'formatting',
			mAction: 'setFormatting',
			mSubMenuItems: [
				new CC.WikiEditor.EditorToolbarItem({
					mDisplayTitle: "_Editor.Block.Text.Toolbar.Formatting.Paragraph.Title".loc(),
					mTooltip: "_Editor.Block.Text.Toolbar.Formatting.Paragraph.Tooltip".loc(),
					mKey: 'p'
				}),
				new CC.WikiEditor.EditorToolbarItem({
					mDisplayTitle: "_Editor.Block.Text.Toolbar.Formatting.BlockQuote.Title".loc(),
					mTooltip: "_Editor.Block.Text.Toolbar.Formatting.BlockQuote.Tooltip".loc(),
					mKey: 'blockquote'
				}),
				new CC.WikiEditor.EditorToolbarItem({
					mDisplayTitle: "_Editor.Block.Text.Toolbar.Formatting.Monospace.Title".loc(),
					mTooltip: "_Editor.Block.Text.Toolbar.Formatting.Monospace.Tooltip".loc(),
					mKey: 'pre'
				}),
				new CC.WikiEditor.EditorToolbarItem({
					mDisplayTitle: "_Editor.Block.Text.Toolbar.Formatting.LargeHeader.Title".loc(),
					mTooltip: "_Editor.Block.Text.Toolbar.Formatting.LargeHeader.Tooltip".loc(),
					mKey: 'h1'
				}),
				new CC.WikiEditor.EditorToolbarItem({
					mDisplayTitle: "_Editor.Block.Text.Toolbar.Formatting.MediumHeader.Title".loc(),
					mTooltip: "_Editor.Block.Text.Toolbar.Formatting.MediumHeader.Tooltip".loc(),
					mKey: 'h2'
				}),
				new CC.WikiEditor.EditorToolbarItem({
					mDisplayTitle: "_Editor.Block.Text.Toolbar.Formatting.SmallHeader.Title".loc(),
					mTooltip: "_Editor.Block.Text.Toolbar.Formatting.SmallHeader.Tooltip".loc(),
					mKey: 'h3'
				})
			]
		}),
		new CC.WikiEditor.EditorToolbarItem({
			mDisplayTitle: "_Editor.Block.Text.Toolbar.Style.Title".loc(),
			mTooltip: "_Editor.Block.Text.Toolbar.Style.Tooltip".loc(),
			mToolbarStyle: CC.WikiEditor.EDITOR_TOOLBAR_ITEM_STYLE_POPUP,
			mKey: 'style',
			mAction: 'setStyle',
			mSubMenuItems: [
				new CC.WikiEditor.EditorToolbarItem({
					mDisplayTitle: "_Editor.Block.Text.Toolbar.Style.Plain.Title".loc(),
					mTooltip: "_Editor.Block.Text.Toolbar.Style.Plain.Tooltip".loc(),
					mKey: 'plain'
				}),
				new CC.WikiEditor.EditorToolbarItem({
					mDisplayTitle: "_Editor.Block.Text.Toolbar.Style.Bold.Title".loc(),
					mTooltip: "_Editor.Block.Text.Toolbar.Style.Bold.Tooltip".loc(),
					mKey: 'bold'
				}),
				new CC.WikiEditor.EditorToolbarItem({
					mDisplayTitle: "_Editor.Block.Text.Toolbar.Style.Italic.Title".loc(),
					mTooltip: "_Editor.Block.Text.Toolbar.Style.Italic.Tooltip".loc(),
					mKey: 'italic'
				}),
				new CC.WikiEditor.EditorToolbarItem({
					mDisplayTitle: "_Editor.Block.Text.Toolbar.Style.Underline.Title".loc(),
					mTooltip: "_Editor.Block.Text.Toolbar.Style.Underline.Tooltip".loc(),
					mKey: 'underline'
				}),
				new CC.WikiEditor.EditorToolbarItem({
					mDisplayTitle: "_Editor.Block.Text.Toolbar.Style.Important.Title".loc(),
					mTooltip: "_Editor.Block.Text.Toolbar.Style.Important.Tooltip".loc(),
					mKey: 'important'
				}),
				new CC.WikiEditor.EditorToolbarItem({
					mDisplayTitle: "_Editor.Block.Text.Toolbar.Style.Emphasis.Title".loc(),
					mTooltip: "_Editor.Block.Text.Toolbar.Style.Emphasis.Tooltip".loc(),
					mKey: 'emphasis'
				}),
				new CC.WikiEditor.EditorToolbarItem({
					mDisplayTitle: "_Editor.Block.Text.Toolbar.Style.Highlight.Title".loc(),
					mTooltip: "_Editor.Block.Text.Toolbar.Style.Highlight.Tooltip".loc(),
					mKey: 'highlight'
				})
			]
		}),
		new CC.WikiEditor.EditorToolbarItem({
			mDisplayTitle: "_Editor.Block.Text.Toolbar.Link.Title".loc(),
			mTooltip: "_Editor.Block.Text.Toolbar.Link.Tooltip".loc(),
			mToolbarStyle: CC.WikiEditor.EDITOR_TOOLBAR_ITEM_STYLE_SELECT,
			mAction: 'addLink',
			mKey: 'link'
		}),
		new CC.WikiEditor.EditorToolbarItem({
			mDisplayTitle: "_Editor.Block.Text.Toolbar.Alignment.Title".loc(),
			mTooltip: "_Editor.Block.Text.Toolbar.Alignment.Tooltip".loc(),
			mToolbarStyle: CC.WikiEditor.EDITOR_TOOLBAR_ITEM_STYLE_SEGMENTED,
			mKey: 'alignment',
			mAction: 'setAlignment',
			mSubMenuItems: [
				new CC.WikiEditor.EditorToolbarItem({
					mDisplayTitle: "_Editor.Block.Text.Toolbar.Alignment.Left.Title".loc(),
					mTooltip: "_Editor.Block.Text.Toolbar.Alignment.Left.Tooltip".loc(),
					mKey: 'left'
				}),
				new CC.WikiEditor.EditorToolbarItem({
					mDisplayTitle: "_Editor.Block.Text.Toolbar.Alignment.Center.Title".loc(),
					mTooltip: "_Editor.Block.Text.Toolbar.Alignment.Center.Tooltip".loc(),
					mKey: 'center'
				}),
				new CC.WikiEditor.EditorToolbarItem({
					mDisplayTitle: "_Editor.Block.Text.Toolbar.Alignment.Right.Title".loc(),
					mTooltip: "_Editor.Block.Text.Toolbar.Alignment.Right.Tooltip".loc(),
					mKey: 'right'
				}),
				new CC.WikiEditor.EditorToolbarItem({
					mDisplayTitle: "_Editor.Block.Text.Toolbar.Alignment.Justify.Title".loc(),
					mTooltip: "_Editor.Block.Text.Toolbar.Alignment.Justify.Tooltip".loc(),
					mKey: 'justify'
				})
			]
		}),
		new CC.WikiEditor.EditorToolbarItem({
			mDisplayTitle: "_Editor.Block.Text.Toolbar.List.Style.Title".loc(),
			mTooltip: "_Editor.Block.Text.Toolbar.List.Style.Tooltip".loc(),
			mToolbarStyle: CC.WikiEditor.EDITOR_TOOLBAR_ITEM_STYLE_POPUP,
			mKey: 'liststyle',
			mAction: 'setListStyle',
			mSubMenuItems: [
				new CC.WikiEditor.EditorToolbarItem({
					mDisplayTitle: "_Editor.Block.Text.Toolbar.List.Style.Bulleted.Title".loc(),
					mTooltip: "_Editor.Block.Text.Toolbar.List.Style.Bulleted.Tooltip".loc(),
					mKey: 'bulleted'
				}),
				new CC.WikiEditor.EditorToolbarItem({
					mDisplayTitle: "_Editor.Block.Text.Toolbar.List.Style.Numbered.Title".loc(),
					mTooltip: "_Editor.Block.Text.Toolbar.List.Style.Numbered.Tooltip".loc(),
					mKey: 'numbered'
				}),
				new CC.WikiEditor.EditorToolbarItem({
					mDisplayTitle: "_Editor.Block.Text.Toolbar.List.Style.None.Title".loc(),
					mTooltip: "_Editor.Block.Text.Toolbar.List.Style.None.Tooltip".loc(),
					mKey: 'unformatted'
				})
			]
		}),
		new CC.WikiEditor.EditorToolbarItem({
			mDisplayTitle: "_Editor.Block.Text.Toolbar.List.Indentation.Title".loc(),
			mTooltip: "_Editor.Block.Text.Toolbar.List.Indentation.Tooltip".loc(),
			mToolbarStyle: CC.WikiEditor.EDITOR_TOOLBAR_ITEM_STYLE_SEGMENTED,
			mKey: 'indentation',
			mAction: 'adjustIndentation',
			mSubMenuItems: [
				new CC.WikiEditor.EditorToolbarItem({
					mDisplayTitle: "_Editor.Block.Text.Toolbar.List.Indentation.Indent.Title".loc(),
					mTooltip: "_Editor.Block.Text.Toolbar.List.Indentation.Indent.Tooltip".loc(),
					mKey: 'indent'
				}),
				new CC.WikiEditor.EditorToolbarItem({
					mDisplayTitle: "_Editor.Block.Text.Toolbar.List.Indentation.Outdent.Title".loc(),
					mTooltip: "_Editor.Block.Text.Toolbar.List.Indentation.Outdent.Tooltip".loc(),
					mKey: 'outdent'
				})
			]
		})
	]
});

// Register inline text styles. So that we can support theming, deliberately wait for
// the document object (and an editor toolbar) so we can sniff the inline styling of
// each built-in text style from the toolbar and duplicate it.

globalNotificationCenter().subscribe(CC.WikiEditor.NOTIFICATION_EDITOR_READY, function(inMessage, inObject, inOptExtras) {
	var toolbarDefinedStyles = $A([
		['plain', "_Editor.Block.Text.Style.Plain.Description".loc(), 'background-color color font-style font-weight text-decoration'.w()],
		['bold', "_Editor.Block.Text.Style.Bold.Description".loc(), 'font-weight'.w()],
		['italic', "_Editor.Block.Text.Style.Italic.Description".loc(), 'font-style'.w()],
		['underline', "_Editor.Block.Text.Style.Underline.Description".loc(), 'text-decoration'.w()],
		['important', "_Editor.Block.Text.Style.Important.Description".loc(), 'color font-weight'.w()],
		['emphasis', "_Editor.Block.Text.Style.Emphasis.Description".loc(), 'color font-weight'.w()],
		['highlight', "_Editor.Block.Text.Style.Highlight.Description".loc(), 'background-color color'.w()]
	]);
	var toolbarDefinedStyleIdx, style;
	for (toolbarDefinedStyleIdx = 0; toolbarDefinedStyleIdx < toolbarDefinedStyles.length; toolbarDefinedStyleIdx++) {
		style = toolbarDefinedStyles[toolbarDefinedStyleIdx];
		var stylePropertiesForDefinedStyle = style[2];
		var properties = new Hash();
		var styleMenuRoot;
		if (inObject && inObject.mToolbarParentElement) {
			styleMenuRoot = inObject.mToolbarParentElement.down('li.item.toplevel.style');
		}
		if (!styleMenuRoot) return;
		var allowedInlineStyles = CC.WikiEditor.TEXT_BLOCK_ALLOWED_INLINE_STYLES, allowedInlineStyleIdx, allowedInlineStyle;
		for (allowedInlineStyleIdx = 0; allowedInlineStyleIdx < allowedInlineStyles.length; allowedInlineStyleIdx++) {
			allowedInlineStyle = allowedInlineStyles[allowedInlineStyleIdx];
			// 10567453
			// Support multiple inline styles by only registering style properties we specifically set for each defined style.
			// When we convert between inline styles and class names, we will apply class names for all matching styles. 
			if (stylePropertiesForDefinedStyle.indexOf(allowedInlineStyle) != -1) {
				var styleMenuItem = styleMenuRoot.down('li.item.' + style[0]);
				var camelizedKey = allowedInlineStyle.camelize();
				var value = document.defaultView.getComputedStyle(styleMenuItem, null)[camelizedKey];
				if (camelizedKey == 'fontWeight') value = CC.WikiEditor.TextBlockHelpers.normalizeBoldStyleValue(value);
				properties.set(allowedInlineStyle, value);
			}
		}
		textBlockDelegate().registerInlineTextStyle(style[0], style[1], style[0], properties);
	}
});

// Register the text block with the editor.

globalEditorPluginManager().registerBlockType('text', 'CC.WikiEditor.TextBlock', {
	mBlockToolbar: 'CC.WikiEditor.TextBlockToolbar'
});
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.



// Image block delegate. Only really responsible for linking.

var ImageBlockDelegate = Class.createWithSharedInstance('imageBlockDelegate');
ImageBlockDelegate.prototype = {
	initialize: function() {
		if (document && document.body) return this._initialize();
	},
	_initialize: function() {
		this.mSmartLinkPopup = new CC.WikiEditor.SmartLinkPopup();
		this.mSmartLinkPopup._render();
		document.body.appendChild(this.mSmartLinkPopup.$());
	},
	showSmartLinkPopup: function(inOptAnchor, inOptURL, inOptLinkText, inOptCallback, inOptCancelCallback) {
		this.mSmartLinkPopup.preparePopup(inOptAnchor, inOptURL, inOptLinkText, inOptCallback, inOptCancelCallback);
		this.mSmartLinkPopup.show(inOptAnchor);
	}
};

CC.WikiEditor.ImageBlock = Class.create(CC.WikiEditor.FileBlock, {
	mBlockView: 'CC.WikiEditor.ImageBlockView',
	// Proxy method for the image editor toolbar.
	replaceFile: function() {
		if (this.mViewInstance) this.mViewInstance.replaceFile();
	},
	addLink: function(inLink, inEvent) {
		if (this.mViewInstance) this.mViewInstance.showLinkDialog(inEvent);
	}
});

CC.WikiEditor.ImageBlockView = Class.create(CC.WikiEditor.FileBlockView, {
	// Cache the image size so we can open new windows quickly.
	mCachedImageSize: null,
	mDeleteDialogTitle: "_Editor.Block.Image.Dialog.Delete.Title".loc(),
	mDeleteDialogDescription: "_Editor.Block.Image.Dialog.Delete.Description".loc(),
	renderAsHTML: function() {
		// Is this image borderless?
		var borderless = this.mContent.getRecordPropertyForPath('extendedAttributes.borderless');
		// Does this image have an explicit size setting?
		var size = (this.mContent.getRecordPropertyForPath('extendedAttributes.size') || {});
		var width = size.width, height = size.height;
		var sizeAttribute = width && height ? " width=\"%@px\" height=\"%@px\"".fmt(width, height) : "";
		// Figure out a path for this image.
		var imagePath;
		var staticImagePath = this.mContent.getRecordPropertyForPath('extendedAttributes.staticImagePath');
		var staticImagePathAt2x = this.mContent.getRecordPropertyForPath('extendedAttributes.staticImagePathAt2x');
		// Do we have a static image path to use?
		if (staticImagePath) imagePath = staticImagePath;
		if (staticImagePathAt2x && hidpi().isHiDPI()) imagePath = staticImagePathAt2x;
		// Otherwise fall back on expecting a file GUID in the extended attributes for this file block.
		if (!imagePath) imagePath = this.buildFileURL();
		// Do we have link attributes to worry about?
		var linkURL = this.mContent.getRecordPropertyForPath('extendedAttributes.linkURL');
		var linkText = this.mContent.getRecordPropertyForPath('extendedAttributes.linkText');
		this._preloadImage(imagePath);
		var eventDelegateIdentifer = this.getEventDelegateIdentifer();
		var html = "<div class=\"container wrapchrome%@\">".fmt((borderless ? ' borderless' : '')) +
			"<div id=\"%@\" class=\"delete clickable chrome\">%@</div><div class=\"placeholder chrome\"><h2>%@</h2></div>".fmt(eventDelegateIdentifer + "-container-delete", "_Editor.Delete.Block".loc(), "_Editor.Block.Image.Loading.Placeholder".loc()) +
			"<div class=\"image wrapchrome%@\"><img id=\"%@\" class=\"clickable cc-routeable\" data-route-href=\"%@\" src=\"%@\"%@/></div></div>".fmt((size.width ? ' sized' : ''), eventDelegateIdentifer + "-container-image-img", linkURL, imagePath, sizeAttribute);
		return html;
	},
	_preloadImage: function(inImagePathToPreload) {
		var img = new Image();
		Event.observe(img, 'load', function(inEvent) {
			this.mCachedImageSize = {'width': img.width, 'height': img.height};
		}.bind(this));
		img.src = inImagePathToPreload;
	},
	registerEventHandlers: function() {
		bindEventListeners(this, [
			'handleDeleteButtonClick',
			'handleImageClick'
		]);
		var eventDelegateIdentifer = this.getEventDelegateIdentifer();
		globalEventDelegate().bulkRegisterDomResponderForEventByIdentifer([
			['click', "%@-container-delete".fmt(eventDelegateIdentifer), this.handleDeleteButtonClick],
			['click', "%@-container-image-img".fmt(eventDelegateIdentifer), this.handleImageClick]
		]);
		this.updateLinkSettings();
	},
	updateLinkSettings: function() {
		var linkURL = this.mContent.getRecordPropertyForPath('extendedAttributes.linkURL');
		var linkText = this.mContent.getRecordPropertyForPath('extendedAttributes.linkText');
		var image = this.$('.image');
		if (linkURL) {
			image.addClassName('linked');
			if (linkText) image.setAttribute('title', linkText);
		} else {
			image.removeClassName('linked');
			image.removeAttribute('title');
		}
	},
	handleImageClick: function(inEvent) {
		if (globalEditorController().mEditMode) return false;
		var linkURL = this.mContent.getRecordPropertyForPath('extendedAttributes.linkURL');
		if (linkURL) {
			if (!linkURL.match(/^\/|[A-Za-z]+:/i)) linkURL = 'http://' + linkURL;
			if (linkURL.match(/^\//)) {
				globalRouteHandler().routeURL(linkURL);
				return true;
			} else {
				window.open(linkURL, undefined, 'status=0,toolbar=1,resizable=1,scrollbars=1');
				return true;
			}
		}
		// 11730803
		// Bail if we're on an iPad running iOS5 for GM.
		if (browser().isiPad() && browser().isiOS5Plus()) return false;
		// Otherwise show a full-size preview (if we can).
		var imageWindowURL = this.buildImageWindowURL();
		if (imageWindowURL) {
			var windowSize = this.mCachedImageSize;
			if (!windowSize) windowSize = {'width': document.viewport.getWidth(), 'height': document.viewport.getHeight()};
			var windowTitle = this.mContent.getRecordPropertyForPath('extendedAttributes.fileName') || "";
			var w = window.open(this.buildImageWindowURL(), undefined, 'status=0,toolbar=0,resizable=1,scrollbars=1,width=%@,height=%@'.fmt(windowSize.width+20, windowSize.height+20));
			w.moveTo(0, 0);
		}
	},
	buildImageWindowURL: function() {
		var fileGUID = this.mContent.getRecordPropertyForPath('extendedAttributes.fileGUID');
		if (fileGUID) {
			return '/__collabd/coreclientbase/image_window.html#fileDataGUID=%@'.fmt(fileGUID);
		}
	},
	showLinkDialog: function(inEvent) {
		var anchor = inEvent.findElement('li.item');
		var linkURL = this.mContent.getRecordPropertyForPath('extendedAttributes.linkURL');
		var linkText = this.mContent.getRecordPropertyForPath('extendedAttributes.linkText');
		textBlockDelegate().showSmartLinkPopup(anchor, linkURL, linkText, this.handleLinkDialogOK.bind(this));
	},
	handleLinkDialogOK: function(inURL, inLinkText) {
		this.mContent.setRecordPropertyForPath('extendedAttributes.linkURL', inURL);
		this.mContent.setRecordPropertyForPath('extendedAttributes.linkText', inLinkText);
		this.updateLinkSettings();
	}
});

CC.WikiEditor.ImageBlockToolbar = Class.create(CC.WikiEditor.BlockToolbar, {
	mToolbarItems: [
		new CC.WikiEditor.EditorToolbarItem({
			mDisplayTitle: "_Editor.Block.Image.Toolbar.Link.Title".loc(),
			mTooltip: "_Editor.Block.Image.Toolbar.Link.Tooltip".loc(),
			mToolbarStyle: CC.WikiEditor.EDITOR_TOOLBAR_ITEM_STYLE_SELECT,
			mAction: 'addLink',
			mKey: 'link'
		})
	]
});

globalEditorPluginManager().registerBlockType('image', 'CC.WikiEditor.ImageBlock', {
	mBlockToolbar: 'CC.WikiEditor.ImageBlockToolbar'
});
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.




CC.WikiEditor.MediaBlock = Class.create(CC.WikiEditor.ImageBlock, {
	mBlockView: 'CC.WikiEditor.MediaBlockView'
});

CC.WikiEditor.MediaBlockView = Class.create(CC.WikiEditor.FileBlockView, {
	mDefaultMovieDimensions: {'width': 384, 'height': 288},
	mDefaultAudioDimensions: {'width': 258, 'height': 258},
	mDeleteDialogTitle: "_Editor.Block.Media.Dialog.Delete.Title".loc(),
	mDeleteDialogDescription: "_Editor.Block.Media.Dialog.Delete.Description".loc(),
	renderAsHTML: function() {
		var eventDelegateIdentifer = this.getEventDelegateIdentifer();
		return "<div class=\"container wrapchrome loading\"><div id=\"%@\" class=\"delete clickable chrome\">%@</div><div id=\"%@\" class=\"placeholder clickable wrapchrome\"></div></div>".fmt(eventDelegateIdentifer + "-container-delete", "_Editor.Delete.Block".loc(), eventDelegateIdentifer + "-container-placeholder");
	},
	registerEventHandlers: function() {
		bindEventListeners(this, [
			'handleDeleteButtonClick',
			'handlePosterImageClicked'
		]);
		globalEventDelegate().registerDomResponderForEventByIdentifer('click', this.getEventDelegateIdentifer() + "-container-delete", this.handleDeleteButtonClick);
		this.fetchPreviewProperties();
	},
	handlePosterImageClicked: function(inEvent) {
		var fileBlock = this.mContent.mRecord;
		var mediaPath = this.buildFileURL();
		// Fetch the width of the poster image.
		var posterDimensions = this.mDefaultMovieDimensions;
		var posterImage = this.$('.placeholder img');
		if (posterImage) {
			var _posterDimensions = posterImage.getDimensions();
			if (_posterDimensions.width > 0) {
				posterDimensions = _posterDimensions
			}
		}
		this.$('.placeholder').hide();
		var mediaElement = Builder.node('div', {className: 'media'});
		this.$('.container').appendChild(mediaElement);
		qtMediaExpander().expandMedia({'src': mediaPath, 'width': posterDimensions.width, 'height': posterDimensions.height}, undefined, mediaElement, 'transparent');
	},
	// Fetches the preview information for this media, displaying a suitable poster
	// image and updating the dimensions of the media block on success, or displaying
	// an error message on failure
	fetchPreviewProperties: function() {
		var fileDataEntityGUID = this.mContent.getRecordPropertyForPath('extendedAttributes.fileDataGUID');
		var gotPreviewInformation = function(properties) {
			var elem = this.$('.container');
			// Remove any loading placeholders.
			elem.removeClassName('loading');
			// If we have no preview, show some placeholder error text.
			var quicklookable = (properties && properties.isQuickLookable);
			var audio = (properties && properties.mediaType && (properties.mediaType == 'audio'));
			var movie = (properties && properties.mediaType && (properties.mediaType == 'movie'));
			if (!quicklookable || !(audio || movie)) {
				elem.down('.placeholder').appendChild(Builder.node('h2', "_Editor.Block.Media.Preview.Missing".loc()));
				return;
			}
			var parentElement = elem.down('.placeholder');
			// Render the play overlay.
			parentElement.appendChild(Builder.node('div', {className: 'play'}));
			// If we're showing a movie, size the preview.
			var mediaType = properties.mediaType, previewWidth, previewHeight, posterImageSrc;
			var size = properties.size;
			if (mediaType == 'movie') {
				var maxSize = this.mDefaultMovieDimensions;
				if (size.width && size.height) maxSize = this.calculateMaxPreviewSize(size.width, size.height, elem);
				previewWidth = maxSize.width;
				previewHeight = maxSize.height;
				if (properties.previewURLs.length > 0) {
					posterImageSrc = properties.previewURLs[0];
				}
			} else if (mediaType == 'audio') {
				previewWidth = this.mDefaultAudioDimensions.width;
				previewHeight = this.mDefaultAudioDimensions.height;
				posterImageSrc = '/__collabd/coreclientbase/stylesheets/wikieditor/img/media_audio_poster.png';
			}
			// Append the poster image for the media preview (if we have it).
			var posterImage = Builder.node('img', {'width': previewWidth + 'px', 'height': previewHeight + 'px'});
			if (posterImageSrc) {
				posterImage.src = posterImageSrc;
				posterImage.show();
			} else {
				posterImage.hide();
			}
			parentElement.appendChild(posterImage);
			if (previewWidth && previewHeight) {
				parentElement.setStyle({
					'width': previewWidth + 'px',
					'height': previewHeight + 'px'
				});
			}
			this.$().addClassName(mediaType);
			// Only respond to click/tap once fully loaded.
			globalEventDelegate().registerDomResponderForEventByIdentifer('click', this.getEventDelegateIdentifer() + "-container-placeholder", this.handlePosterImageClicked);
		};
		quicklook().mService.pollForPreviewInformation(fileDataEntityGUID, gotPreviewInformation.bind(this));
	},
	// Determines the maximum dimensions for a preview based on the width of the page.
	// The height of the preview is scaled proportionally.
	calculateMaxPreviewSize: function(inWidth, inHeight, inOptElement) {
		if (!inWidth || !inHeight) return;
		var element = (inOptElement || this.$());
		var containerWidth = element.up('.wrapper').getLayout().get('width'); // Takes .wrapper padding into account
		var maxWidth = Math.round(Math.min(containerWidth, inWidth));
		var maxHeight = Math.round(maxWidth * (inHeight / inWidth));
		return {'width': maxWidth, 'height': maxHeight};
	}
});

globalEditorPluginManager().registerBlockType('media', 'CC.WikiEditor.MediaBlock', {});
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.

// Table block delegate.

var TableBlockDelegate = Class.createWithSharedInstance('tableBlockDelegate');
TableBlockDelegate.prototype = {
	// The active table block tracked by this delegate.
	mTableBlock: null,
	initialize: function() {
		if (document && document.body) return this._initialize();
	},
	_initialize: function() {
		// Initialize an inline table popup.
		this.mInlineTablePopup = new CC.WikiEditor.InlineTablePopup();
		this.mInlineTablePopup._render();
		document.body.appendChild(this.mInlineTablePopup.$());
		// Initialize a table block settings dialog.
		this.mTextBlockDebugDialog = dialogManager().drawDialog('table_block_settings_dialog', [
			{label: '', contents: '<label for="table_block_settings_alternating" class="checkbox"><input type="checkbox" id="table_block_settings_alternating", checked="checked"/> %@</label>'.fmt("_Editor.Block.Table.Dialog.Settings.Alternating.Label".loc())},
			{label: '', contents: '<label for="table_block_settings_gridlines" class="checkbox"><input type="checkbox" id="table_block_settings_gridlines", checked="checked"/> %@</label>'.fmt("_Editor.Block.Table.Dialog.Settings.Gridlines.Label".loc())}
		], "_Editor.Block.Table.Dialog.Settings.OK".loc(), undefined, "_Editor.Block.Table.Dialog.Settings.Title".loc(), "_Editor.Block.Table.Dialog.Settings.Cancel".loc());
	},
	addBlock: function() {
		// Restrict tables inside tables.
		if (globalEditorController().mActiveBlock.mViewInstance.$().up('.block.table')) return false;
		editorToolbarDelegate().addBlock('table', {}, true);
	},
	// Configures and shows the shared inline table popup for given column or row header.
	// Expects an anchor element (which should be the leading table cell of the row or
	// column for which the popup is being configured).
	configureAndShowTablePopup: function(inAnchorElement, inTableBlock) {
		if (!inAnchorElement) return console.error("Cannot configure inline table popup for an undefined anchor element (%@).".fmt(inAnchorElement));
		if (!inTableBlock || inTableBlock.getRecordPropertyForPath('blockType') != 'table') return console.error("Cannot configure inline table popup for an unknown block (%@).".fmt(inTableBlock));
		// First hide the popup if we're already showing it.
		if (this.mInlineTablePopup.mShowing) this.mInlineTablePopup.hide();
		// Find the closest containing td element.
		var anchor = (inAnchorElement.hasClassName('header') ? inAnchorElement : inAnchorElement.up('header'));
		if (!anchor) return console.error("Invalid anchor for table popup. Must be a row or column header.");
		// Track the new anchor for callbacks and block for callbacks.
		this.mAnchorElement = anchor;
		this.mTableBlock = inTableBlock;
		// Show the popup over the row or column heading.
		var isRow = anchor.hasClassName('row');
		var menu = anchor.down('.menu');
		this.mInlineTablePopup.preparePopup(menu, isRow);
		this.mInlineTablePopup.show(menu);
	},
	// Configures and shows the table settings dialog.
	configureAndShowTableSettingsDialog: function(inOptGridlinesEnabled, inOptAlternatingRows, inOptCallback) {
		$('table_block_settings_gridlines').checked = (inOptGridlinesEnabled || false);
		$('table_block_settings_alternating').checked = (inOptAlternatingRows || false);
		var callback = function() {
			var gridlines = $('table_block_settings_gridlines').checked;
			var alternating = $('table_block_settings_alternating').checked;
			if (inOptCallback) inOptCallback(gridlines, alternating);
		}
		dialogManager().show('table_block_settings_dialog', undefined, callback.bind(this));
	},
	// Hash of allowed table styles. Each style is a tuple of identifer and extra class names
	// that will be associated with the table when that style is applied. For simplicity, table
	// styles are exclusively specified in CSS.
	mRegisteredStyles: new Hash(),
	// Registers a new inline table style.
	registerTableStyle: function(inTableStyleIdentifer, inOptTableStyleDescription, inOptExtraClassNames) {
		if (!inTableStyleIdentifer) return logger().warn("Cannot register a table style without an identifer (%@)".fmt(inTableStyleIdentifer));
		if (this.mRegisteredStyles.get(inTableStyleIdentifer)) logger().warn("Table style (%@) is already registered and will be overwritten");
		var identifer = inTableStyleIdentifer;
		// Build some sort of description if we didn't get one.
		var displayName = (inOptTableStyleDescription || "%@ style".fmt(identifer));
		// The class names for a table style always include at least the table style identifier.
		var classNames = [inTableStyleIdentifer].concat((inOptExtraClassNames || []));
		this.mRegisteredStyles.set(identifer, [displayName, classNames]);
		return true;
	},
	// Unregisters a table style if it exists.
	unregisterTableStyle: function(inTableStyleIdentifer) {
		if (!inTableStyleIdentifer) return false;
		return this.mRegisteredStyles.unset(inTableStyleIdentifer);
	}
};

// Inline table row/column popup menu. Managed by the global table block delegate.

CC.WikiEditor.InlineTablePopup = Class.create(CC.WikiEditor.EditorToolbarPopupMenu, {
	mIdentifer: "table_block_inline_popup",
	render: function() {
		var elem = Builder.node('ul', {className: 'items'}, [
			Builder.node('li', {id: 'table_block_inline_popup_headercolumn', className: 'item headercolumn appliescolumn'}, [
				Builder.node('span', {title: "_Editor.Block.Table.Popup.Column.Header.Tooltip".loc()}, "_Editor.Block.Table.Popup.Column.Header.Title".loc())
			]),
			Builder.node('li', {id: 'table_block_inline_popup_sortasc', className: 'item sortasc appliescolumn'}, [
				Builder.node('span', {title: "_Editor.Block.Table.Popup.Column.Sort.Ascending.Tooltip".loc()}, "_Editor.Block.Table.Popup.Column.Sort.Ascending.Title".loc())
			]),
			Builder.node('li', {id: 'table_block_inline_popup_sortdesc', className: 'item sortdesc appliescolumn'}, [
				Builder.node('span', {title: "_Editor.Block.Table.Popup.Column.Sort.Descending.Tooltip".loc()}, "_Editor.Block.Table.Popup.Column.Sort.Descending.Title".loc())
			]),
			Builder.node('li', {id: 'table_block_inline_popup_addcolumnbefore', className: 'item addcolumnbefore appliescolumn'}, [
				Builder.node('span', {title: "_Editor.Block.Table.Popup.Column.Add.Before.Tooltip".loc()}, "_Editor.Block.Table.Popup.Column.Add.Before.Title".loc())
			]),
			Builder.node('li', {id: 'table_block_inline_popup_addcolumnafter', className: 'item addcolumnafter appliescolumn'}, [
				Builder.node('span', {title: "_Editor.Block.Table.Popup.Column.Add.After.Tooltip".loc()}, "_Editor.Block.Table.Popup.Column.Add.After.Title".loc())
			]),
			Builder.node('li', {id: 'table_block_inline_popup_deletecolumn', className: 'item deletecolumn appliescolumn'}, [
				Builder.node('span', {title: "_Editor.Block.Table.Popup.Column.Delete.Tooltip".loc()}, "_Editor.Block.Table.Popup.Column.Delete.Title".loc())
			]),
			Builder.node('li', {id: 'table_block_inline_popup_headerrow', className: 'item headerrow appliesrow'}, [
				Builder.node('span', {title: "_Editor.Block.Table.Popup.Row.Header.Tooltip".loc()}, "_Editor.Block.Table.Popup.Row.Header.Title".loc())
			]),
			Builder.node('li', {id: 'table_block_inline_popup_addrowabove', className: 'item addrowabove appliesrow'}, [
				Builder.node('span', {title: "_Editor.Block.Table.Popup.Row.Add.Above.Tooltip".loc()}, "_Editor.Block.Table.Popup.Row.Add.Above.Title".loc())
			]),
			Builder.node('li', {id: 'table_block_inline_popup_addrowbelow', className: 'item addrowbelow appliesrow'}, [
				Builder.node('span', {title: "_Editor.Block.Table.Popup.Row.Add.Below.Tooltip".loc()}, "_Editor.Block.Table.Popup.Row.Add.Below.Title".loc())
			]),
			Builder.node('li', {id: 'table_block_inline_popup_deleterow', className: 'item deleterow appliesrow'}, [
				Builder.node('span', {title: "_Editor.Block.Table.Popup.Row.Delete.Tooltip".loc()}, "_Editor.Block.Table.Popup.Row.Delete.Title".loc())
			])
		]);
		return elem;
	},
	registerEventHandlers: function($super) {
		$super.apply(null, Array.prototype.slice.call(arguments, 1));
		bindEventListeners(this, [
			'handleHeaderItemClicked',
			'handleSortByColumnClicked',
			'handleAddColumnClicked',
			'handleDeleteColumnClicked',
			'handleAddRowClicked',
			'handleDeleteRowClicked'
		]);
		globalEventDelegate().bulkRegisterDomResponderForEventByIdentifer([
			['click', 'table_block_inline_popup_headercolumn', this.handleHeaderItemClicked],
			['click', 'table_block_inline_popup_sortasc', this.handleSortByColumnClicked],
			['click', 'table_block_inline_popup_sortdesc', this.handleSortByColumnClicked],
			['click', 'table_block_inline_popup_addcolumnbefore', this.handleAddColumnClicked],
			['click', 'table_block_inline_popup_addcolumnafter', this.handleAddColumnClicked],
			['click', 'table_block_inline_popup_deletecolumn', this.handleDeleteColumnClicked],
			['click', 'table_block_inline_popup_headerrow', this.handleHeaderItemClicked],
			['click', 'table_block_inline_popup_addrowabove', this.handleAddRowClicked],
			['click', 'table_block_inline_popup_addrowbelow', this.handleAddRowClicked],
			['click', 'table_block_inline_popup_deleterow', this.handleDeleteRowClicked]
		]);
	},
	// Prepares this inline popup for display. Accepts an optional anchor for positioning,
	// and an optional showForRow flag that determines what options are included in the menu
	// before being shown. If inOptShowForRow is false or undefined, only menu items applicable
	// for a table column will be rendered.
	preparePopup: function(inOptAnchor, inOptShowForRow) {
		inOptShowForRow ? this.$().addClassName('forrow').removeClassName('forcolumn') : this.$().addClassName('forcolumn').removeClassName('forrow');
		// Configure the table heading option in the contextual toolbar. For simplicity,
		// we only allow the first row, or first column of a table to be a heading.
		if (!inOptAnchor) return;		
		var td = inOptAnchor.up('td'), rows = inOptAnchor.up('table').select('tr');
		var canBeHeadingRow = false, canBeHeadingColumn = false;
		if (inOptShowForRow && rows.indexOf(td.up('tr')) == 1) canBeHeadingRow = true;
		if (!inOptShowForRow && td.up('tr').select('td').indexOf(td) == 1) canBeHeadingColumn = true;
		var headerRowMenuItem = this.$('.item.headerrow'), headerColumnMenuItem = this.$('.item.headercolumn');
		canBeHeadingRow ? headerRowMenuItem.show() : headerRowMenuItem.hide();
		canBeHeadingColumn ? headerColumnMenuItem.show() : headerColumnMenuItem.hide();
		// Update the menu to reflect the current heading state.
		var table = inOptAnchor.up('table');
		var hasHeadingRow = table.hasClassName('headingrow'), hasHeadingColumn = table.hasClassName('headingcolumn');
		var headerRowItem = this.$('.item.headerrow');
		var headerColumnItem = this.$('.item.headercolumn');
		hasHeadingRow ? headerRowItem.addClassName('selected') : headerRowItem.removeClassName('selected');
		hasHeadingColumn ? headerColumnItem.addClassName('selected') : headerColumnItem.removeClassName('selected');
		// Disable add row above and add column before for header-enabled tables.
		var addRowAboveItem = this.$('.item.addrowabove');
		(canBeHeadingRow && hasHeadingRow) ? addRowAboveItem.hide() : addRowAboveItem.show();
		var addColumnBeforeItem = this.$('.item.addcolumnbefore');
		(canBeHeadingColumn && hasHeadingColumn) ? addColumnBeforeItem.hide() : addColumnBeforeItem.show();
	},
	// Override show/hide so we can force-display the table chrome while the menu is showing.
	show: function($super, inOptAnchorElement) {
		$super.apply(null, Array.prototype.slice.call(arguments, 1));
		if (this.mTimer) {
			clearTimeout(this.mTimer);
			delete this.mTimer;
		}
		if (inOptAnchorElement) Element.extend(inOptAnchorElement).up('.block.table table').addClassName('showingmenu');
	},
	hide: function($super, inEvent, inOptCallback) {
		$super.apply(null, Array.prototype.slice.call(arguments, 1));
		// Delay this so we don't show toolbar transitions on a table mid-change.
		this.mTimer = setTimeout(function() {
			var tableBlock = tableBlockDelegate().mTableBlock;
			if (tableBlock) tableBlock.mViewInstance.$().down('table').removeClassName('showingmenu');
		}, 400);
	},
	// Returns the row or column index for the anchor point for the inline table menu.
	// The index is determined by inspecting the position of the anchor element, over
	// which the popup formatting menu is shown.
	_$index: function() {
		var anchorElement = tableBlockDelegate().mInlineTablePopup.mAnchorElement;
		var headerElement = CC.WikiEditor.TableBlockHelpers.$td(anchorElement);
		return CC.WikiEditor.TableBlockHelpers.getRowOrColumnIndex(headerElement);
	},
	// Proxy methods to the table block instance we're editing.
	handleHeaderItemClicked: function(inEvent) {
		var element = inEvent.findElement('.item');
		var isRow = element.hasClassName('appliesrow');
		// Determin if we are toggling a header column or header row.
		element.hasClassName('appliesrow') ? tableBlockDelegate().mTableBlock.toggleHeaderRow() : tableBlockDelegate().mTableBlock.toggleHeaderColumn();
		this.hide();
	},
	handleSortByColumnClicked: function(inEvent) {
		var element = inEvent.findElement('.item');
		// Determine the sort direction.
		var sortDirection = (element.hasClassName('sortasc') ? 'ASC' : 'DESC');
		// Do the sort.
		tableBlockDelegate().mTableBlock.sortColumn(this._$index(), sortDirection);
		this.hide();
	},
	handleAddColumnClicked: function(inEvent) {
		var element = inEvent.findElement('.item');
		// Determine where to add the new column.
		var addBefore = element.hasClassName('addcolumnbefore');
		// Add the column.
		tableBlockDelegate().mTableBlock.addColumn(this._$index(), addBefore);
		this.hide();
	},
	handleDeleteColumnClicked: function(inEvent) {
		// Delete the column.
		tableBlockDelegate().mTableBlock.removeColumn(this._$index(), false);
		this.hide();
	},
	handleAddRowClicked: function(inEvent) {
		var element = inEvent.findElement('.item');
		// Determine where to add the new column.
		var addAbove = element.hasClassName('addrowabove');
		// Add the column.
		tableBlockDelegate().mTableBlock.addRow(this._$index(), addAbove);
		this.hide()
	},
	handleDeleteRowClicked: function(inEvent) {
		// Delete the row.
		tableBlockDelegate().mTableBlock.removeRow(this._$index(), false);
		this.hide();
	}
});

// Table helpers.

CC.WikiEditor.TableBlockHelpers = {
	// Returns the nearest table cell to an element, or the element itself.
	$td: function(inElement) {
		if (!inElement) return undefined;
		var tableCell = Element.extend(inElement);
		if (!tableCell) return undefined;
		return (tableCell.tagName.toLowerCase() == 'td') ? tableCell : tableCell.up('td');
	},
	// Calculates and returns the row or column index for a given table
	// header by parsing the title attribute.
	getRowOrColumnIndex: function(inElement) {
		var title = inElement.getAttribute('name');
		if (title) {
			var match = title.match(/(row|col)-([0-9]+)/i);
			if (match) return parseInt(match[2]);
		}
		return undefined;
	},
	// Returns the table row (0-indexed) for a supplied table cell element, or
	// child element of a table cell.
	rowForTableCell: function(inTableCellElement) {
		var tableCell = this.$td(inTableCellElement);
		if (!tableCell) return undefined;
		// Find the containing table row.
		var row = tableCell.up('tr');
		var table = tableCell.up('table'), rows = table.select('tr');
		// Get the index of the containing table row in the table.
		var index = rows.indexOf(row) - 1;
		return (index >= 0 ? index : undefined);
	},
	// Likewise, returns the table column.
	columnForTableCell: function(inTableCellElement) {
		var tableCell = this.$td(inTableCellElement);
		if (!tableCell) return undefined;
		// Find all the adjacent td elements.
		var row = tableCell.up('tr'), columns = row.select('td');
		var index = columns.indexOf(tableCell) - 1;
		return (index >= 0 ? index : undefined);
	},
	// Returns a tuple of arrays of table headers and data cells.
	computeTableCells: function(inRootElement) {
		// Fetch all table cells.
		var root = $(inRootElement);
		var cells = root.getElementsByTagName('td');
		// Partition into four sets (headers, data, row and column headers).
		var headerCells = [], dataCells = [], rowHeaders = [], columnHeaders = [], cellsLength = cells.length, cellIdx, cell;
		for (cellIdx = 1; cellIdx < cells.length; cellIdx++) {
			cell = cells.item(cellIdx);
			if (Element.hasClassName(cell, 'header')) {
				headerCells.push(cell);
				Element.hasClassName(cell, 'row') ? rowHeaders.push(cell) : columnHeaders.push(cell);
			} else {
				dataCells.push(cell);
			}
		}
		return [headerCells, dataCells, rowHeaders, columnHeaders];
	}
};

// A simple table height observer.

CC.WikiEditor.TableHeightObserver = Class.create(Abstract.TimedObserver, {
	getValue: function() {
		return Element.getHeight(this.element);
	}
});

CC.WikiEditor.NOTIFICATION_TABLE_DID_CHANGE = 'TABLE_DID_CHANGE';
CC.WikiEditor.NOTIFICATION_TABLE_SETTINGS_DID_CHANGE = 'TABLE_SETTINGS_DID_CHANGE';

// A table block.

CC.WikiEditor.TableBlock = Class.create(CC.WikiEditor.Block, {
	mBlockView: 'CC.WikiEditor.TableBlockView',
	mIsContainer: true,
	initialize: function($super) {
		$super.apply(null, Array.prototype.slice.call(arguments, 1));
		globalNotificationCenter().subscribe(CC.WikiEditor.NOTIFICATION_TABLE_DID_CHANGE, this.updateLayoutAndSize.bind(this), this);
	},
	// A table is empty if it has no rows or columns.
	isEmpty: function() {
		var size = this.mViewInstance.getComputedSize();
		return (size.width == 0 && size.height == 0);
	},
	// Tables are explosive.
	isExplosive: function() {
		return true;
	},
	handleDidStartEditing: function($super, inOptInfo) {
		$super.apply(null, Array.prototype.slice.call(arguments, 1));
		if (inOptInfo && !inOptInfo.propagated && (inOptInfo.moveToStart || inOptInfo.moveToEnd)) this.mViewInstance._activate();
		this.mViewInstance.trackActiveCell();
	},
	handleDidStopEditing: function($super, inOptInfo) {
		$super.apply(null, Array.prototype.slice.call(arguments, 1));
		this.mViewInstance._deactivate();
		this.updateLayoutAndSize();
		this.mViewInstance.trackActiveCell();
	},
	// Table editing proxy methods.
	sortColumn: function(inColumnIndex, inOptSortDirection) {
		this.mViewInstance.sortColumn(inColumnIndex, inOptSortDirection);
		globalNotificationCenter().publish(CC.WikiEditor.NOTIFICATION_TABLE_DID_CHANGE, this);
	},
	addColumn: function(inColumnIndex, inOptShouldAddColumnBefore) {
		this.mViewInstance.addColumn(inColumnIndex, (inOptShouldAddColumnBefore == true));
		globalNotificationCenter().publish(CC.WikiEditor.NOTIFICATION_TABLE_DID_CHANGE, this);
	},
	removeColumn: function(inColumnIndex, inOptControlledExplosion) {
		this.mViewInstance.removeColumn(inColumnIndex, (inOptControlledExplosion == true));
		globalNotificationCenter().publish(CC.WikiEditor.NOTIFICATION_TABLE_DID_CHANGE, this);
	},
	addRow: function(inRowIndex, inOptShouldAddRowAbove) {
		this.mViewInstance.addRow(inRowIndex, (inOptShouldAddRowAbove == true));
		globalNotificationCenter().publish(CC.WikiEditor.NOTIFICATION_TABLE_DID_CHANGE, this);
	},
	removeRow: function(inRowIndex, inOptControlledExplosion) {
		this.mViewInstance.removeRow(inRowIndex, (inOptControlledExplosion == true));
		globalNotificationCenter().publish(CC.WikiEditor.NOTIFICATION_TABLE_DID_CHANGE, this);
	},
	toggleHeaderRow: function(inRowIndex) {
		this.mViewInstance.toggleHeaderRow(inRowIndex);
		globalNotificationCenter().publish(CC.WikiEditor.NOTIFICATION_TABLE_DID_CHANGE, this);
	},
	toggleHeaderColumn: function(inColumnIndex) {
		this.mViewInstance.toggleHeaderColumn(inColumnIndex);
		globalNotificationCenter().publish(CC.WikiEditor.NOTIFICATION_TABLE_DID_CHANGE, this);
	},
	showSettingsDialog: function() {
		var table = this.mViewInstance.$('table');
		var gridlines = table.hasClassName('gridlines');
		var alternating = table.hasClassName('alternating');
		var callback = function(inOptGridlinesEnabled, inOptAlternatingRows) {
			this.setRecordPropertyForPath('extendedAttributes.gridlines', (inOptGridlinesEnabled || false));
			this.setRecordPropertyForPath('extendedAttributes.alternating', (inOptAlternatingRows || false));
			globalNotificationCenter().publish(CC.WikiEditor.NOTIFICATION_TABLE_SETTINGS_DID_CHANGE, this);
		};
		tableBlockDelegate().configureAndShowTableSettingsDialog(gridlines, alternating, callback.bind(this));
	},
	// Table-specific implementation of computeBlockGUIDs.
	computeBlockGUIDs: function() {
		if (!this.mViewInstance || !this.mViewInstance.$()) return [];
		var blockViews = this.mViewInstance.$().select('table td > .block, table td > .block-placeholder');
		return blockViews.invoke('getAttribute', 'data-guid');
	},
	// Updates the current size and layout information for this block.
	updateLayoutAndSize: function() {
		this.mViewInstance._computeAndCacheTableCells();
		var size = this.mViewInstance.getComputedSize(true);
		var layout = this.mViewInstance.getComputedLayout(true);
		var reverseLayout = this.mViewInstance.getComputedReverseLayout(true);
		var headerPreferences = this.mViewInstance.getComputedHeaderPreference(true);
		var dimensions = this.mViewInstance.getComputedDimensions(true);
		var blockGUIDs = this.computeBlockGUIDs();
		this.setRecordPropertyForPath('extendedAttributes.size', size);
		this.setRecordPropertyForPath('extendedAttributes.layout', layout);
		this.setRecordPropertyForPath('extendedAttributes.reverseLayout', reverseLayout);
		this.setRecordPropertyForPath('extendedAttributes.headerPreferences', headerPreferences);
		if (this.mViewInstance.mSizedManually) this.setRecordPropertyForPath('extendedAttributes.dimensions', dimensions);
		this.setRecordPropertyForPath('extendedAttributes.blockGUIDs', blockGUIDs);
	},
	mCachedWorkingElement: null,
	mCachedWorkingElementDataCells: null,
	handleDidAddBlock: function($super, inOptInfo) {
		// If the block is being added in an explicit position, render it immediately.
		if (!inOptInfo.quietly && inOptInfo.position) {
			blockRenderingDelegate().renderAndInsertBlockAtPosition(inOptInfo.block, inOptInfo.position);
		}
		// Otherwise, if we're rendering quietly (response from the server on page load or an autosave
		// restore) manually append the block to this contain in the position we already know about.
		else if (inOptInfo && inOptInfo.block) {
			var size = this.getRecordPropertyForPath('extendedAttributes.size');
			var layout = $H(this.getRecordPropertyForPath('extendedAttributes.reverseLayout'));
			var blockGUID = inOptInfo.block.getRecordPropertyForPath('guid');
			if (inOptInfo.workingElement && inOptInfo.workingElement != this.mCachedWorkingElement) {
				this.mCachedWorkingElement = inOptInfo.workingElement;
				this.mCachedWorkingElementDataCells = CC.WikiEditor.TableBlockHelpers.computeTableCells(this.mCachedWorkingElement)[1];
			}
			var workingElement = (inOptInfo.workingElement || this.mViewInstance.$());
			var position, rowId, columnIdx, dataCells, targetCellIdx;
			if (blockGUID && (position = layout.get(blockGUID))) {
				if (position.length != 2) return;
				var rowIdx = position[0], columnIdx = position[1];
				// Are we rendering in a scratch element?
				if (inOptInfo.workingElement) {
					if (this.mCachedWorkingElement != inOptInfo.workingElement) {
						this.mCachedWorkingElement = inOptInfo.workingElement;
						this.mCachedWorkingElementDataCells = CC.WikiEditor.TableBlockHelpers.computeTableCells(this.mCachedWorkingElement)[1];
					}
					dataCells = this.mCachedWorkingElementDataCells;
				} else {
					dataCells = this.mViewInstance.getDataCells();
				}
				targetCellIdx = (rowIdx * size.width) + columnIdx;
				if (dataCells.length <= targetCellIdx) return;
				// Render and position the block.
				blockRenderingDelegate().renderAndInsertBlockAtPosition(inOptInfo.block, {'bottom': dataCells[targetCellIdx]});
			}
		}
		$super.apply(null, Array.prototype.slice.call(arguments, 1));
	},
	handleBlocksDidChange: function($super, inOptInfo) {
		if (!inOptInfo || (inOptInfo && !inOptInfo.quietly)) {
			globalNotificationCenter().publish(CC.WikiEditor.NOTIFICATION_TABLE_DID_CHANGE, this);
		}
		$super.apply(null, Array.prototype.slice.call(arguments, 1));
	},
	// Autosave support.
	restore: function($super, inChangesets) {
		$super(inChangesets);
		// To restore a table, we need to both restore the state of the table (header settings,
		// number of rows and columns etc) and any child blocks that are already saved on the
		// page and were rendered when the page was rendered.
		var childBlockElements = this.mViewInstance.$().select('table .block'), childBlockElementIdx, childBlockElement;
		var stashedBlockViewElements = new Array();
		for (childBlockElementIdx = 0; childBlockElementIdx < childBlockElements.length; childBlockElementIdx++) {
			childBlockElement = childBlockElements[childBlockElementIdx];
			stashedBlockViewElements.push(Element.remove(childBlockElement));
		}
		// Force re-render the table with any new changeset-applied attributes.
		var selectableElement = this.mViewInstance.$('.content.selectable .container');
		Element.insert(selectableElement, {'before': this.mViewInstance.renderBlock()});
		Element.remove(selectableElement);
		// Re-add any child blocks.
		var block, stashedBlockViewElementIdx, stashedBlockViewElement;
		for (stashedBlockViewElementIdx = 0; stashedBlockViewElementIdx < stashedBlockViewElements.length; stashedBlockViewElementIdx++) {
			stashedBlockViewElement = stashedBlockViewElements[stashedBlockViewElementIdx];
			block = globalEditorController().blockForBlock(stashedBlockViewElement);
			this.addBlock(block, undefined, true, true);
		}
	}
});

// The view displaying a table block. A table block is a container for a series of child
// content blocks, e.g. text and images, presented in a tabular form. Like other container
// blocks, a table block's model has a blockGUIDs array in its extendedAttributes (with an
// ordered array of the GUIDs for each child block), and a layout property in its extendedAttributes
// tracking the positioning of each of those children. The layout of a table is stored as an array of
// arrays (where the array snakes to fill the table). For performance, we also track the
// table size, and a reverse layout (dictionary keyed by block guid with an row and column
// index tuple).

CC.WikiEditor.TableBlockView = Class.create(CC.WikiEditor.NonTextBlockView, CC.WikiEditor.Mixins.AskBeforeDeleting, {
	// The default number of rows and columns for an empty table.
	mDefaultSize: {'width': 3, 'height': 4},
	// The default layout for an empty table.
	mDefaultLayout: [],
	// The default reverse layout for an empty table.
	mDefaultReverseLayout: {},
	mDefaultDisplayAlternatingRows: true,
	mDefaultDisplayGridlines: true,
	mDefaultColumnWidth: 215,
	mMinimumColumnWidth: 40,
	mDefaultRowHeight: 32,
	mMinimumRowHeight: 32,
	// The currently active cell if it exists.
	mActiveCell: null,
	// Is this table being sized manually?
	mSizedManually: false,
	mDeleteDialogTitle: "_Editor.Block.Table.Dialog.Delete.Title".loc(),
	mDeleteDialogDescription: "_Editor.Block.Table.Dialog.Delete.Description".loc(),
	initialize: function($super) {
		$super.apply(null, Array.prototype.slice.call(arguments, 1));
		bindEventListeners(this, [
			'handleInlineTableMenuButtonMouseDown',
			'handleResizeTableRowColumnMouseDown',
			'handleWindowMouseMove',
			'handleWindowMouseUp',
			'handleTableCellClick',
			'handleTableCellMouseDown'
		]);
	},
	getEventDelegateIdentiferForRowColumnIndex: function(inRowIndex, inColumnIndex) {
		return this.getEventDelegateIdentifer() + "-cell-%@".fmt(generateRamdomAlphanumericString(6));
	},
	renderAsHTML: function() {
		// Get the number of rows and columns.
		var size = (this.mContent.getRecordPropertyForPath('extendedAttributes.size') || this.mDefaultSize);
		// Get any row and column dimensions.
		var dimensions = this.mContent.getRecordPropertyForPath('extendedAttributes.dimensions');
		if (dimensions) this.mSizedManually = true;
		// Get the header preferences.
		var headerPreferences = this.mContent.getRecordPropertyForPath('extendedAttributes.headerPreferences') || [false, false];
		// Get the true size of the table, since the layout might not be null-padded.
		var upperLimit = (size.width + 1) * (size.height + 1);
		// Should we display gridlines or alternating rows?
		var gridlines = this.mContent.getRecordPropertyForPath('extendedAttributes.gridlines', this.mDefaultDisplayGridlines);
		var alternating = this.mContent.getRecordPropertyForPath('extendedAttributes.alternating', this.mDefaultDisplayAlternatingRows);
		// Are we rendering in edit mode?
		var editable = this.mContent.isEditable();
		// Render the table.
		var tableRows = [], cellIndex, rowIndex, columnIndex, dimension;
		var workingRow, workingRowSubstitutions = [];
		for (cellIndex = 0; cellIndex < upperLimit; cellIndex++) {
			columnIndex = (cellIndex % (size.width + 1));
			rowIndex = Math.floor(cellIndex / (size.width + 1));
			// Render a new HTML row.
			if (columnIndex == 0) {
				workingRow = this._renderRowAsHTML(rowIndex, (rowIndex == 0), size.width + 1);
			}
			// Are we building the 0th row?
			if (rowIndex == 0) {
				// Add the delete widget to the top left cell of every table.
				if (columnIndex == 0) {
					var eventDelegateIdentifer = this.getEventDelegateIdentifer() + "-delete";
					workingRowSubstitutions.push("<td class=\"reserved header chrome\" width=\"18px\" height=\"16px\"><div id=\"%@\" class=\"delete clickable\">%@</div></td>".fmt(eventDelegateIdentifer, "_Editor.Delete.Block".loc()));
				} else {
					dimension = ((dimensions && dimensions[0][columnIndex - 1]) || this.mDefaultColumnWidth);
					workingRowSubstitutions.push(this._renderHeaderAsHTML(rowIndex, columnIndex, false, dimension));
				}
			// Are we building the 0th column?
			} else {
				if (columnIndex == 0) {
					dimension = ((dimensions && dimensions[1][rowIndex - 1]) || this.mDefaultRowHeight);
					workingRowSubstitutions.push(this._renderHeaderAsHTML(rowIndex, columnIndex, true, dimension));
					continue;
				}
				workingRowSubstitutions.push(this._renderCellAsHTML(rowIndex, columnIndex, editable));
			}
			// Flush each row buffer as we go.
			if (columnIndex == size.width) {
				tableRows.push(workingRow.fmt.apply(workingRow, workingRowSubstitutions));
				workingRowSubstitutions = [];
			}
		}
		var result = "<div class=\"container wrapchrome\">" +
			"<div class=\"table mask chrome\" style=\"display: none;\"></div>" +
			"<div class=\"table alt controls row chrome\"><div id=\"%@\" class=\"toggle clickable\"></div><div class=\"rotary\"><div class=\"count\">3</div><div id=\"%@\" class=\"up clickable\"></div><div id=\"%@\" class=\"down clickable\"></div><div class=\"up-bg\"></div><div class=\"down-bg\"></div></div></div>".fmt(this.getEventDelegateIdentifer() + "-alt-controls-row-toggle", this.getEventDelegateIdentifer() + "-alt-controls-row-up", this.getEventDelegateIdentifer() + "-alt-controls-row-down") +
			"<div class=\"table alt controls col chrome\"><div id=\"%@\" class=\"toggle clickable\"></div><div class=\"rotary\"><div class=\"count\">2</div><div id=\"%@\" class=\"up clickable\"></div><div id=\"%@\" class=\"down clickable\"></div><div class=\"up-bg\"></div><div class=\"down-bg\"></div></div></div>".fmt(this.getEventDelegateIdentifer() + "-alt-controls-col-toggle", this.getEventDelegateIdentifer() + "-alt-controls-col-up", this.getEventDelegateIdentifer() + "-alt-controls-col-down") +
			"<table class=\"__wikiTableVersion:Lion%@%@%@%@\" width=\"1px\">%@</table>".fmt((headerPreferences[0] ? " headingrow" : ""), (headerPreferences[1] ? " headingcolumn" : ""), (gridlines ? " gridlines" : ""), (alternating ? " alternating" : ""), tableRows.join('')) +
			"</div>";
		return result;
	},
	// Renders an individual header cell.
	_renderHeader: function(inRowIndex, inColumnIndex, inOptIsRowHeader, inOptDimension) {
		var eventDelegateIdentifer = this.getEventDelegateIdentiferForRowColumnIndex(inRowIndex, inColumnIndex);
		var header = Builder.node('td', {id: eventDelegateIdentifer, className: 'reserved header chrome ' + (inOptIsRowHeader ? 'row' : 'col')}, [
			Builder.node('div', {className: 'chrome'}, [
				Builder.node('div', {className: 'index'}),
				Builder.node('div', {className: 'menu clickable', id: "%@-menu".fmt(eventDelegateIdentifer)}),
				Builder.node('div', {className: 'resize', id: "%@-resize".fmt(eventDelegateIdentifer)})
			])
		]);
		// Force width/height using a spacer image.
		var attrs = {className: 'sizer', src: '/__collabd/coreclientbase/static/spacer.gif', width: '16px', height: '18px'};
		var dimensionKey, dimension;
		if (inOptIsRowHeader) {
			dimensionKey = 'height';
			dimension = this.mDefaultRowHeight;
		} else {
			dimensionKey = 'width';
			dimension = this.mDefaultColumnWidth;
		}
		if (inOptDimension) {
			dimensionKey = (inOptIsRowHeader ? 'height' : 'width');
			dimension = inOptDimension;
		}
		attrs[dimensionKey] = (dimension - 1) + 'px';
		header.down('div.chrome').appendChild(Builder.node('img', attrs));
		header.setAttribute(dimensionKey, dimension + 'px');
		this._registerEventHandlersForHeader(header);
		return header;
	},
	_renderHeaderAsHTML: function(inRowIndex, inColumnIndex, inOptIsRowHeader, inOptDimension) {
		var spacerDimension = "width=\"16px\" height=\"18px\"", cellDimension = "", dimension;
		if (inOptIsRowHeader) {
			dimension = (inOptDimension || this.mDefaultRowHeight);
			cellDimension = " width=\"16px\" height=\"" + dimension + "px\""
			spacerDimension = " width=\"16px\" height=\"" + (dimension - 1) + "px\""
		} else {
			dimension = (inOptDimension || this.mDefaultColumnWidth);
			cellDimension = " width=\"" + dimension + "px\" height=\"18px\"";
			spacerDimension = " width=\"" + (dimension - 1) + "px\" height=\"18px\"";
		}
		var eventDelegateIdentifer = this.getEventDelegateIdentiferForRowColumnIndex(inRowIndex, inColumnIndex);
		var markup = "<td id=\"%@\" class=\"reserved header chrome %@\"%@>".fmt(eventDelegateIdentifer, (inOptIsRowHeader ? 'row' : 'col'), cellDimension) +
			"<div><div class=\"top\"></div><div class=\"right\"></div><div class=\"bottom\"></div><div class=\"left\"></div>" +
			"<div class=\"index\"></div><div id=\"%@\" class=\"menu\"></div>".fmt(eventDelegateIdentifer + "-menu") + 
			"<div id=\"%@\" class=\"resize\"></div><img class=\"sizer\" src=\"/__collabd/coreclientbase/static/spacer.gif\"%@/></div></td>".fmt(eventDelegateIdentifer + "-resize", spacerDimension);
		return markup;
	},
	_registerEventHandlersForHeader: function(inHeaderElement) {
		if (inHeaderElement) {
			var eventDelegateIdentifer = inHeaderElement.getAttribute('id');
			globalEventDelegate().bulkRegisterDomResponderForEventByIdentifer([
				['mousedown', "%@-menu".fmt(eventDelegateIdentifer), this.handleInlineTableMenuButtonMouseDown],
				['mousedown', "%@-resize".fmt(eventDelegateIdentifer), this.handleResizeTableRowColumnMouseDown]
			]);
		}
	},
	// Renders a row.
	_renderRow: function(inRowIndex, inOptIsHeaderRow) {
		var tr = Builder.node('tr');
		if (inOptIsHeaderRow) tr.addClassName('chrome');
		return tr;
	},
	_renderRowAsHTML: function(inRowIndex, inOptIsHeaderRow, inOptSubstitutions) {
		var substitutions = "";
		if (inOptSubstitutions) {
			for (var i = 0; i < inOptSubstitutions; i++) {
				substitutions += "%@";
			}
		}
		return "<tr%@>%@</tr>".fmt((inOptIsHeaderRow ? " class=\"chrome\"" : ""), substitutions);
	},
	// Renders an individual data cell.
	_renderCell: function(inRowIndex, inColumnIndex) {
		var eventDelegateIdentifer = this.getEventDelegateIdentiferForRowColumnIndex(inRowIndex, inColumnIndex);
		var cell = Builder.node('td', {id: eventDelegateIdentifer, className: 'cell'});
		this._registerEventHandlersForCell(cell);
		return cell;
	},
	_renderCellAsHTML: function(inRowIndex, inColumnIndex) {
		var eventDelegateIdentifer = this.getEventDelegateIdentiferForRowColumnIndex(inRowIndex, inColumnIndex);
		return "<td id=\"%@\" class=\"cell\"></td>".fmt(eventDelegateIdentifer);
	},
	_registerEventHandlersForCell: function(inCellElement) {
		globalEventDelegate().bulkRegisterDomResponderForEventByIdentifer([
			['mousedown', inCellElement.getAttribute('id'), this.handleTableCellMouseDown],
			['touchstart', inCellElement.getAttribute('id'), this.handleTableCellMouseDown],
			['click', inCellElement.getAttribute('id'), this.handleTableCellClick]
		]);
	},
	// Registers table-level event handlers.
	mTableHeightObserver: null,
	registerEventHandlers: function() {
		// As soon as we can, compute and cache any table cells.
		this._computeAndCacheTableCells();
		// Reconfigure any table headers.
		this.reconfigureTableHeaders();
		// Reconfigure the alt popup counts.
		this.reconfigureAltPopupCounts();
		// Enable the delete table button.
		var eventIdentifer = this.getEventDelegateIdentifer();
		globalEventDelegate().registerDomResponderForEventByIdentifer('click', "%@-delete".fmt(eventIdentifer), this.handleDeleteButtonClick.bind(this));
		// Enable the alternative row/column popup.
		bindEventListeners(this, [
			'handleDisplayAltControlsClicked',
			'handleAltTablePopupAddRowClicked',
			'handleAltTablePopupRemoveRowClicked',
			'handleAltTablePopupAddColumnClicked',
			'handleAltTablePopupRemoveColumnClicked'
		]);
		globalEventDelegate().bulkRegisterDomResponderForEventByIdentifer([
			['click', "%@-alt-controls-row-toggle".fmt(eventIdentifer), this.handleDisplayAltControlsClicked],
			['click', "%@-alt-controls-col-toggle".fmt(eventIdentifer), this.handleDisplayAltControlsClicked],
			['click', "%@-alt-controls-row-up".fmt(eventIdentifer), this.handleAltTablePopupAddRowClicked],
			['click', "%@-alt-controls-col-up".fmt(eventIdentifer), this.handleAltTablePopupAddColumnClicked],
			['click', "%@-alt-controls-row-down".fmt(eventIdentifer), this.handleAltTablePopupRemoveRowClicked],
			['click', "%@-alt-controls-col-down".fmt(eventIdentifer), this.handleAltTablePopupRemoveColumnClicked]
		]);
		// Register event handlers on table headers and cells.
		var headers = this.mCachedHeaderCells;
		for (var headerIdx = 0; headerIdx < headers.length; headerIdx++) {
			this._registerEventHandlersForHeader(headers[headerIdx]);
		}
		var cells = this.mCachedDataCells;
		for (var cellIdx = 0; cellIdx < cells.length; cellIdx++) {
			this._registerEventHandlersForCell(cells[cellIdx]);
		}
		// 9421864
		// Observe table height changes in case a sub-element in one of the table row cells
		// is forcing the row to draw taller than we expect. We have no option here, really.
		this.mTableHeightObserver = new CC.WikiEditor.TableHeightObserver(this.$().down('table'), 1, this.handleTableHeightChanged.bind(this));
		// Publish a notification once we're done.
		globalNotificationCenter().subscribe(CC.WikiEditor.NOTIFICATION_TABLE_SETTINGS_DID_CHANGE, this.handleTableSettingsDidChange.bind(this), this.mContent);
	},
	// Cached layouts, size and dimensions for this table.
	mCachedComputedLayout: null,
	mCachedComputedReverseLayout: null,
	mCachedComputedSize: null,
	mCachedComputedDimensions: null,
	// Returns the current computed layout based on the layout of the table.
	getComputedLayout: function(inOptForceRecalculate) {
		// If we can, return a cached value.
		if (this.mCachedComputedLayout && !inOptForceRecalculate) return this.mCachedComputedLayout;
		// First get the size of the table.
		var size = this.getComputedSize();
		// Initialize a new layout as an array of length size.width x size.height.
		var layout = new Array(size.width * size.height);
		// Iterate over every non-header table cell and inspect any child blocks.
		var rows = this.$().select('tr');
		if (rows.length > 0) rows.shift();
		// Loop through each table cell and build an ordered array of child block GUIDs. Each block
		// view that is a child node of a table cell has its GUID stashed in the for attribute of the
		// rendered block view. Once we have a list of children, update the layout array and continue.
		var cells, cellIdx, cell, topLevelBlockGUIDs, row, rowIdx;
		for (rowIdx = 0; rowIdx < rows.length; rowIdx++) {
			row = rows[rowIdx];
			cells = row.select('td');
			for (cellIdx = 1; cellIdx < cells.length; cellIdx++) {
				cell = cells[cellIdx];
				var blockGUIDs = cell.select('.block').invoke('getAttribute', 'data-guid');
				var nestedBlockGUIDs = cell.select('.block .block').invoke('getAttribute', 'data-guid');
				topLevelBlockGUIDs = stringArrayDifference(blockGUIDs, nestedBlockGUIDs);
				layout[(rowIdx * size.width) + (cellIdx - 1)] = (blockGUIDs.length > 0 ? blockGUIDs : undefined);
			}
		}
		return (this.mCachedComputedLayout = layout);
	},
	getComputedReverseLayout: function(inOptForceRecalculate) {
		if (this.mCachedComputedReverseLayout && !inOptForceRecalculate) return this.mCachedComputedReverseLayout;
		var size = this.getComputedSize();
		var computedLayout = this.getComputedLayout();
		// Initialize a new reverse layout.
		var reverseLayout = {};
		var cellLayout, columnIdx, rowIdx;
		// Iterate over the computed layout and build a layout keyed by block GUID.
		for (var idx = 0; idx < computedLayout.length; idx++) {
			cellLayout = $A(computedLayout[idx]);
			rowIdx = Math.floor(idx / size.width);
			columnIdx = (idx % size.width);
			for (var jdx = 0; jdx < cellLayout.length; jdx++) {
				blockGUID = cellLayout[jdx];
				reverseLayout[blockGUID] = [rowIdx, columnIdx];
			}
		}
		return (this.mCachedComputedReverseLayout = reverseLayout);
	},
	// Likewise, for size.
	getComputedSize: function(inOptForceRecalculate) {
		if (this.mCachedComputedSize && !inOptForceRecalculate) return this.mCachedComputedSize;
		var rows = this.$().select('table tr');
		var rowCount = rows.length;
		var cells = this.$().select('table td');
		var cellCount = cells.length;
		return (this.mCachedComputedSize = {'width': Math.floor(cellCount / rowCount) - 1, 'height': rowCount - 1});
	},
	// Likewise, for dimensions. Dimensions of a table (widths of columns and rows) are tracked as
	// a length-2 array of integer arrays, with the widths of all columns in an array at index 0, and
	// the heights of all rows in an array at index 1.
	getComputedDimensions: function(inOptForceRecalculate) {
		if (this.mCachedComputedDimensions && !inOptForceRecalculate) return this.mCachedComputedDimensions;
		var table = this.$('table'), width, height;
		var columnDimensions = table.select('td.reserved.header.col').collect(function(td) {
			return td.getWidth() - 1;
		});
		var rowDimensions = table.select('td.reserved.header.row').collect(function(td) {
			return td.getHeight() - 1;
		});
		return (this.mCachedComputedDimensions = [columnDimensions, rowDimensions]);
	},
	// Returns the current computed header settings for this table, as an length-2 array of booleans,
	// representing whether the row or column heading preference is enabled.
	mCachedHasHeadingPreferences: null,
	getComputedHeaderPreference: function(inOptForceRecalculate) {
		// If we can, return a cached value.
		if (this.mCachedHasHeadingPreferences && !inOptForceRecalculate) return this.mCachedHasHeadingPreferences;
		// Otherwise, recompute and return.
		var table = this.$('table');
		var hasRowHeading = table.hasClassName('headingrow');
		var hasColumnHeading = table.hasClassName('headingcolumn');
		return (this.mCachedHasHeadingPreferences = [hasRowHeading, hasColumnHeading]);
	},
	// Caches header/data cells for table performance as an array of table <td> elements.
	mCachedHeaderCells: null,
	mCachedRowHeaderCells: null,
	mCachedColumnHeaderCells: null,
	mCachedDataCells: null,
	getHeaderCells: function(inOptForceRecalculate) {
		if (this.mCachedHeaderCells && !inOptForceRecalculate) return this.mCachedHeaderCells;
		this._computeAndCacheTableCells();
		return this.mCachedHeaderCells;
	},
	getDataCells: function(inOptForceRecalculate) {
		if (this.mCachedDataCells && !inOptForceRecalculate) return this.mCachedDataCells;
		this._computeAndCacheTableCells();
		return this.mCachedDataCells;
	},
	_computeAndCacheTableCells: function() {
		var result = CC.WikiEditor.TableBlockHelpers.computeTableCells(this.$());
		this.mCachedHeaderCells = result[0];
		this.mCachedDataCells = result[1];
		this.mCachedRowHeaderCells = result[2];
		this.mCachedColumnHeaderCells = result[3];
	},
	// Returns the header string for use in a row/column header at a particular index.
	mAlphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split(''),
	buildHeaderString: function(inRowOrColumnIndex, inOptIsRowHeader) {
		var headerString = "%@".fmt(inRowOrColumnIndex);
		// Column headers are A-Z.
		if (!inOptIsRowHeader) {
			if (inRowOrColumnIndex >= this.mAlphabet.length) {
				var times = Math.floor(inRowOrColumnIndex / this.mAlphabet.length);
				var mod = inRowOrColumnIndex % this.mAlphabet.length;
				// Only go as far as "ZZ".
				if (times < this.mAlphabet.length) {
					headerString = "%@%@".fmt(this.mAlphabet[times], this.mAlphabet[mod]);
				}
			} else {
				headerString = this.mAlphabet[inRowOrColumnIndex];
			}
		}
		return headerString;
	},
	// Iterates over each of the table header elements, tagging them with their row or
	// column index, and adjusting the row or column display name. By tagging rows and
	// columns with an identifier, we can quickly determine the index of a row or column
	// operation without walking up and down the DOM inefficiently.
	reconfigureTableHeaders: function(inOptRootElement) {
		var elem = (inOptRootElement || this.$());
		// Adjust all the column headings in the first table row.
		var firstRow = elem.down('tr');
		var colHeaders = firstRow.select('td.header.col'), colHeaderIdx, colHeader;
		for (colHeaderIdx = 0; colHeaderIdx < colHeaders.length; colHeaderIdx++) {
			colHeader = colHeaders[colHeaderIdx];
			colHeader.setAttribute('name', 'col-' + colHeaderIdx);
			colHeader.down('.index').innerHTML = this.buildHeaderString(colHeaderIdx, false);
		}
		// Adjust each of the row headings.
		var rowHeaders = elem.select('td.header.row'), rowHeaderIdx, rowHeader;
		for (rowHeaderIdx = 0; rowHeaderIdx < rowHeaders.length; rowHeaderIdx++) {
			rowHeader = rowHeaders[rowHeaderIdx];
			rowHeader.setAttribute('name', 'row-' + rowHeaderIdx);
			rowHeader.down('.index').innerHTML = this.buildHeaderString((rowHeaderIdx + 1), true);
		}
	},
	// Reconfigures the count values in the alt table row/column popups.
	reconfigureAltPopupCounts: function(inOptRootElement) {
		var elem = (inOptRootElement || this.$());
		var computedSize = this.getComputedSize(true);
		var rowPopup = elem.down('.alt.controls.row');
		rowPopup.down('.count').update(computedSize.height);
		var columnPopup = elem.down('.alt.controls.col');
		columnPopup.down('.count').update(computedSize.width);
	},
	// Adds a new empty column to the table at a given index. By default, new columns are
	// added to the table to the right of the specified index, but you can optionally pass
	// inOptShouldAddColumnBefore as true to override this behavior. Because of the nature
	// of an HTML table, iterates through each of the existing rows in the table and
	// pushes a new table cell at the correct index for the insertion.
	addColumn: function(inColumnIndex, inOptShouldAddColumnBefore) {
		if (inColumnIndex < 0) return;
		// By default, columns are added at the end of a table.
		var newColumnIndex = this.getComputedSize().width;
		// Calculate an adjusted column index for the insertion point (if we have one).
		if (inColumnIndex != undefined) newColumnIndex = (inOptShouldAddColumnBefore) ? Math.max(inColumnIndex - 1, 1) : inColumnIndex + 1;
		var rows = this.$().select('table tr'), row;
		var pivotElement, cell, insertion, editable = this.mContent.isEditable();
		for (var rowIdx = 0; rowIdx < rows.length; rowIdx++) {
			row = rows[rowIdx];
			pivotElement = ((inColumnIndex != undefined) ? row.select('td')[inColumnIndex + 1] : row.select('td')[newColumnIndex]);
			cell = (rowIdx == 0 ? this._renderHeader(rowIdx, newColumnIndex, false, this.mDefaultColumnWidth) : this._renderCell(newColumnIndex, rowIdx, editable));
			insertion = (inOptShouldAddColumnBefore ? {'before': cell} : {'after': cell});
			Element.insert(pivotElement, insertion);
		}
		this.reconfigureTableHeaders();
		this.reconfigureAltPopupCounts();
	},
	removeColumn: function(inColumnIndex, inOptControlledExplosion) {
		if (inColumnIndex < 0) return;
		if (inColumnIndex == undefined) inColumnIndex = Math.max(this.getComputedSize().width - 1, 1);
		// There should always be at least one column.
		var columns = this.$().down('tr').select('td');
		if (columns.length <= 2) return false;
		// Calculate where to summon the smoke monster.
		if (inOptControlledExplosion != true) {
			var headerCell = this.$().select('td.header.col')[inColumnIndex];
			var table = this.$().down('table');
			var viewportOffset = Element.viewportOffset(headerCell);
			var dimensions = Element.getDimensions(headerCell);
			var left = viewportOffset.left + (dimensions.width / 2)
			var viewportHeight = document.viewport.getHeight();
			// The top position of smokey should be half way between the header cell
			// and the bottom of the table, or the header cell and the bottom of the
			// viewport, whichever is smaller.
			var top = viewportOffset.top + Math.min(((viewportHeight - viewportOffset.top) / 2), ((table.getHeight() - 27) / 2)); 
			smokey().showAtPosition({'left': left, 'top': top});
		}
		// Now delete each of the table cells in turn.
		var rows = this.$().select('table tr'), rowIdx, row;
		for (rowIdx = 0; rowIdx < rows.length; rowIdx++) {
			row = rows[rowIdx];
			Element.remove(row.childElements()[inColumnIndex + 1]);
		}
		// Reconfigure our table headers.
		this.reconfigureTableHeaders();
		this.reconfigureAltPopupCounts();
	},
	// Adds a new empty row to the table at a given index. Simply renders a new tr tag, with
	// a row header element and enough empty table cells to fill the row before appending.
	addRow: function(inRowIndex, inOptShouldAddRowAbove) {
		if (inRowIndex < 0) return;
		var newRowIndex = this.getComputedSize().height;
		// Calculate an adjusted row index for the insertion point.
		if (inRowIndex != undefined) newRowIndex = (inOptShouldAddRowAbove) ? Math.max(inRowIndex - 1, 0) : inRowIndex + 1;
		// Render a new row.
		var size = this.getComputedSize(), row = this._renderRow(newRowIndex), editable = this.mContent.isEditable();
		row.appendChild(this._renderHeader(newRowIndex, 0, true, this.mDefaultRowHeight));
		for (var columnIdx = 0; columnIdx < size.width; columnIdx++) {
			row.appendChild(this._renderCell(newRowIndex, columnIdx, editable));
		}
		// Find the pivot row about which we'll be inserting.
		var table = this.$().down('table')
		var rows = table.select('tr');
		var pivotElement = table;
		var insertion = {'bottom': row};
		if (inRowIndex != undefined) {
			pivotElement = rows[inRowIndex + 1];
			insertion = (inOptShouldAddRowAbove ? {'before': row} : {'after': row});
		}
		Element.insert(pivotElement, insertion);
		this.reconfigureTableHeaders();
		this.reconfigureAltPopupCounts();
	},
	removeRow: function(inRowIndex, inOptControlledExplosion) {
		if (inRowIndex < 0) return;
		if (inRowIndex == undefined) inRowIndex = Math.max(this.getComputedSize().height - 1, 1);
		var rows = this.$().select('table tr');
		// There should always be at least one row.
		if (rows.length <= 2) return false;
		var row = rows[inRowIndex + 1];
		if (inOptControlledExplosion != true) smokey().showOverElement(row);
		Element.remove(row);
		this.reconfigureTableHeaders();
		this.reconfigureAltPopupCounts();
	},
	// Redraws the table in-place, sorting rows in a specified direction by inspecting the contents
	// of a given column index.
	sortColumn: function(inColumnIndex, inOptSortDirection) {
		// Adjust the column index.
		inColumnIndex += 1;
		// First remove every non-header row.
		var table = this.$().down('table');
		var rows = table.select('tr');
		if (rows.length > 0) rows.shift();
		if (table.hasClassName('headingrow')) rows.shift();
		rows.collect(function(row) {
			return Element.remove(row);
		});
		// Next, sort the rows in the specified direction.
		var columns, firstBlockElement, firstBlockGUID, firstBlock;
		var sharedEditorInstance = globalEditorController();
		var sorted = rows.sortBy(function(row) {
			columns = row.select('td');
			if (columns.length <= inColumnIndex) return 0;
			firstBlockElement = columns[inColumnIndex].down('.block');
			var val = "";
			if (firstBlockElement) {
				firstBlockGUID = firstBlockElement.getAttribute('data-guid');
				firstBlock = sharedEditorInstance.blockForBlock(firstBlockGUID);
				if (firstBlock && firstBlock.mViewInstance && firstBlock.mViewInstance.mIsComparable) {
					val = firstBlock.mViewInstance.getComparableValue();
				}
			}
			return (null == val ? 0 : val.toLowerCase());
		});
		// Append ordered the rows to the document again.
		if (inOptSortDirection == "DESC") {
			for (var idx = (sorted.length - 1); idx >= 0; idx--) {
				table.appendChild(sorted[idx]);
			}
		} else {
			for (var idx = 0; idx < sorted.length; idx++) {
				table.appendChild(sorted[idx]);
			}
		}
		// Reconfigure table headings which might now be out of order.
		this.reconfigureTableHeaders();
	},
	toggleHeaderRow: function() {
		var table = this.$('table');
		table.hasClassName('headingrow') ? table.removeClassName('headingrow') : table.addClassName('headingrow');
	},
	toggleHeaderColumn: function(inColumnIndex) {
		var table = this.$('table');
		table.hasClassName('headingcolumn') ? table.removeClassName('headingcolumn') : table.addClassName('headingcolumn');
	},
	// Handles a table settings change from the table settings dialog.
	handleTableSettingsDidChange: function() {
		var gridlines = this.mContent.getRecordPropertyForPath('extendedAttributes.gridlines')
		var alternating = this.mContent.getRecordPropertyForPath('extendedAttributes.alternating')
		var table = this.$('table');
		gridlines ? table.addClassName('gridlines') : table.removeClassName('gridlines');
		alternating ? table.addClassName('alternating') : table.removeClassName('alternating');
	},
	// Tracks the currently active table cell.
	trackActiveCell: function() {
		this.mActiveCell = null;
		var activeBlock = this.$().down('.block.editing');
		if (activeBlock) {
			var cell = activeBlock.up('td');
			var rowIdx = CC.WikiEditor.TableBlockHelpers.rowForTableCell(cell);
			var colIdx = CC.WikiEditor.TableBlockHelpers.columnForTableCell(cell);
			this.mActiveCell = [rowIdx, colIdx];
		}
	},
	// Tabs to the next/previous table cells after/before the active cell.
	_tab: function(inOptTabInReverse) {
		if (!this.mActiveCell) this.mActiveCell = [0, 0];
		// Otherwise, figure out the next cell we can relocate to.
		var rowIdx = this.mActiveCell[0], colIdx = this.mActiveCell[1];
		var size = this.getComputedSize();
		// If we're at the end of a row, and not in the last row, select the first cell in
		// the next row.
		if (!inOptTabInReverse && colIdx == (size.width - 1)) {
			rowIdx = (rowIdx < (size.height - 1)) ? rowIdx + 1 : 0;
			colIdx = 0;
		}
		// If we're selecting in reverse, and we're at the start of the row, and not in
		// the first row, select the last cell in the previous row.
		else if (inOptTabInReverse && colIdx == 0) {
			rowIdx = (rowIdx > 0) ? rowIdx - 1 : size.height - 1;
			colIdx = size.width - 1;
		}
		// Otherwise select the next/previous cell in the same row.
		else {
			colIdx += (inOptTabInReverse ? -1 : 1);
		}
		logger().debug("rowIdx: %o, colIdx: %o", rowIdx, colIdx);
		this._activate(rowIdx, colIdx);
	},
	tabToNextCell: function() {
		this._tab();
	},
	tabToPreviousCell: function() {
		this._tab(true);
	},
	_activate: function(inOptRowIdx, inOptColumnIdx, inOptActivateAtEnd) {
		var blockGUIDs = this.mContent.getRecordPropertyForPath('extendedAttributes.blockGUIDs');
		var layout = this.mContent.getRecordPropertyForPath('extendedAttributes.layout');
		// If the layout is missing, recompute it.
		if (!layout) layout = this.getComputedLayout(true);
		var size = this.getComputedSize();
		var layoutIdx = 0;
		if (inOptRowIdx != undefined && inOptColumnIdx != undefined) {
			layoutIdx = (inOptRowIdx * size.width) + inOptColumnIdx;
		}
		// Do we have a layout for the calculated layout index?
		if (layout && layout[layoutIdx] != undefined) {
			var cellLayout = layout[layoutIdx];
			var blockGUID = cellLayout[(inOptActivateAtEnd ? (cellLayout.length - 1) : 0)];
			var block = this.mContent.mBlocks.get(blockGUID);
			return globalEditorController().startEditing(block, {'moveToStart': !inOptActivateAtEnd, 'moveToEnd': inOptActivateAtEnd}, true);
		}
		var prediction = globalEditorController().predictNextBlock();
		var cells = this.mCachedDataCells;
		var cell = (cells.length > layoutIdx) ? cells[layoutIdx] : cells[0];
		var position = (inOptActivateAtEnd ? {'bottom': cell} : {'top': cell});
		globalEditorController().addBlock(prediction.blockType, {'extendedAttributes': prediction.attributes}, true, position, this.mContent);
	},
	_deactivate: function() {
		// TODO
	},
	handleKeyboardNotification: function(inMessage, inObject, inOptExtras) {
		var inEvent = inOptExtras.event;
		var activeBlock = globalEditorController().mActiveBlock;
		switch (inMessage) {
			// Support tabbing and reverse tabbing through the table.
			case CC.Keyboard.NOTIFICATION_DID_KEYBOARD_TAB:
			case CC.Keyboard.NOTIFICATION_DID_KEYBOARD_SHIFT_TAB:
				Event.stop(inEvent);
				if (inMessage == CC.Keyboard.NOTIFICATION_DID_KEYBOARD_TAB) {
					this.tabToNextCell();
				} else {
					this.tabToPreviousCell();
				}
				return true;
			// Do not allow navigation between table cells using arrows keys. The browser will
			// navigate between table cells and editable regions outside this table based on
			// arrow key presses, so watch for an unwanted activation of another block and revert
			// it.
			case CC.Keyboard.NOTIFICATION_DID_KEYBOARD_LEFT:
			case CC.Keyboard.NOTIFICATION_DID_KEYBOARD_UP:
			case CC.Keyboard.NOTIFICATION_DID_KEYBOARD_RIGHT:
			case CC.Keyboard.NOTIFICATION_DID_KEYBOARD_DOWN:
				var stashedActiveBlock = globalEditorController().mActiveBlock;
				var stashedActiveBlockTableCell = stashedActiveBlock.mViewInstance.$().up('td');
				setTimeout(function() {
					var currentlyActiveBlock = globalEditorController().mActiveBlock;
					if (currentlyActiveBlock.mViewInstance.$().up('td') != stashedActiveBlockTableCell) {
						var options = (inMessage == CC.Keyboard.NOTIFICATION_DID_KEYBOARD_LEFT || inMessage == CC.Keyboard.NOTIFICATION_DID_KEYBOARD_UP) ? {'moveToStart': true} : {'moveToEnd': true};
						globalEditorController().startEditing(stashedActiveBlock, options);
					}
				}, 10);
				return true;
		}
		return false;
	},
	// Configures and presents the inline table popup meny over a header cell.
	handleInlineTableMenuButtonMouseDown: function(inEvent) {
		if (!this.isEditable()) return;
		tableBlockDelegate().configureAndShowTablePopup(inEvent.findElement('td'), this.mContent);
	},
	// Handles click events in an individual table data cell.
	handleTableCellClick: function(inEvent) {
		if (!this.isEditable()) return;
		Event.stop(inEvent);
		var cell = inEvent.findElement('td');
		var rowIdx = CC.WikiEditor.TableBlockHelpers.rowForTableCell(cell);
		var colIdx = CC.WikiEditor.TableBlockHelpers.columnForTableCell(cell);
		this._activate(rowIdx, colIdx, true);
	},
	// Handles mouse down events in an individual cell.
	handleTableCellMouseDown: function(inEvent) {
		if (Event.element(inEvent).tagName.toLowerCase() != 'td') return true;
		this.handleTableCellClick(inEvent);
	},
	// Row and column resize support. Allows inline resizing of rows and columns by dragging
	// a hidden handle left/right or up/down. The new row/column widths are applied right away,
	// but the adjusted dimensions are not persisted to the table block extended attributes until
	// the table block is deactivated.
	mResizeGesture: null,
	handleResizeTableRowColumnMouseDown: function(inEvent) {
		if (!this.isEditable()) return;
		Event.stop(inEvent);
		Event.observe(window, 'mousemove', this.handleWindowMouseMove);
		Event.observe(window, 'mouseup', this.handleWindowMouseUp);
		// Cache any resize gesture information.
		var anchor = inEvent.findElement('.resize');
		var root = inEvent.findElement('.reserved.header');
		var sizer = root.down('img.sizer');
		var table = root.up('table');
		this.mResizeGesture = {
			'anchor': anchor,
			'root': root,
			'sizer': sizer,
			'table': table,
			'isColumn': root.hasClassName('col'),
			'startPosition': {'x': inEvent.pointerX(), 'y': inEvent.pointerY()},
			'startDimensions': sizer.getDimensions()
		};
		this.$().addClassName('resizing');
	},
	handleWindowMouseMove: function(inEvent) {
		var start = this.mResizeGesture.startPosition;
		var column = this.mResizeGesture.isColumn;
		// Calculate a delta value from the original mouse down position.
		var delta = (column ? (inEvent.pointerX() - start.x) : (inEvent.pointerY() - start.y));
		// Tables with a width less than the width of the page are centered, therefore the delta
		// value needs to be compensated (doubled).
		if (column && (this.$('table').getWidth() <= this.$('.wrapper').getWidth())) delta = delta * 2;
		// Calculate the new height/width of the row/column.
		if (column) {
			this.handleTableColumnHeaderWidthChanged(this.mResizeGesture.root, (this.mResizeGesture.startDimensions.width + delta));
		} else {
			this.handleTableRowHeaderHeightChanged(this.mResizeGesture.root, (this.mResizeGesture.startDimensions.height + delta));
		}
	},
	handleWindowMouseUp: function(inEvent) {
		Event.stopObserving(window, 'mousemove', this.handleWindowMouseMove);
		Event.stopObserving(window, 'mouseup', this.handleWindowMouseUp);
		this.mResizeGesture = null;
		this.$().removeClassName('resizing');
		this.mSizedManually = true;
		globalNotificationCenter().publish(CC.WikiEditor.NOTIFICATION_TABLE_DID_CHANGE, this.mContent);
	},
	handleTableHeightChanged: function(inElement, inNewHeight) {
		// 9421864
		var rowHeaders = this.mCachedRowHeaderCells, rowHeader, rowHeaderHeight;
		for (var rowHeaderIdx = 0; rowHeaderIdx < rowHeaders.length; rowHeaderIdx++) {
			rowHeader = rowHeaders[rowHeaderIdx];
			this.handleTableRowHeaderHeightChanged(rowHeader, (rowHeader.getHeight() - 1));
		}
	},
	handleTableColumnHeaderWidthChanged: function(inElement, inNewWidth) {
		var newColumnWidth = Math.max(inNewWidth, this.mMinimumColumnWidth);
		inElement.setAttribute('width', newColumnWidth + 'px');
		inElement.down('img.sizer').setAttribute('width', newColumnWidth + 'px');
	},
	handleTableRowHeaderHeightChanged: function(inElement, inNewHeight) {
		var row = inElement.up("tr");
		var cellChildren = row.select("td:not(.header) > div");
		var maxCellHeight = cellChildren.max(function(child) { return (child.getHeight() + 4 + 1)}) || 0;
		var newRowHeight = Math.max(Math.max(inNewHeight, maxCellHeight), this.mMinimumRowHeight);
		inElement.setAttribute('height', newRowHeight + 'px');
		inElement.down('img.sizer').setAttribute('height', newRowHeight + 'px');
	},
	handleDisplayAltControlsClicked: function(inEvent) {
		// First hide any already-displayed controls.
		var allControls = this.$().select('.table.alt.controls');
		allControls.invoke('removeClassName', 'displaying');
		// Next display the controls just invoked and prepare a mask element behind the popup we'll
		// use for dismissing it.
		var controls = inEvent.findElement('.table.alt.controls');
		controls.addClassName('displaying');
		var mask = this.$().down('.mask');
		bindEventListeners(this, ['handleTableMaskClicked']);
		Event.observe(mask, 'click', this.handleTableMaskClicked);
		mask.show();
	},
	handleTableMaskClicked: function(inEvent) {
		var controls = this.$().select('.table.alt.controls');
		controls.invoke('removeClassName', 'displaying');
		Event.element(inEvent).hide();
	},
	handleAltTablePopupAddRowClicked: function(inEvent) {
		Event.stop(inEvent);
		this.addRow();
	},
	handleAltTablePopupRemoveRowClicked: function(inEvent) {
		Event.stop(inEvent);
		this.removeRow(undefined, true);
	},
	handleAltTablePopupAddColumnClicked: function(inEvent) {
		Event.stop(inEvent);
		this.addColumn();
	},
	handleAltTablePopupRemoveColumnClicked: function(inEvent) {
		Event.stop(inEvent);
		this.removeColumn(undefined, true);
	}
});

CC.WikiEditor.TableBlockToolbar = Class.create(CC.WikiEditor.BlockToolbar, {
	mToolbarItems: [
		new CC.WikiEditor.EditorToolbarItem({
			mDisplayTitle: "_Editor.Block.Table.Toolbar.Settings.Title".loc(),
			mTooltip: "_Editor.Block.Table.Toolbar.Settings.Tooltip".loc(),
			mKey: 'settings',
			mAction: 'showSettingsDialog'
		})
	]
});

globalEditorPluginManager().registerBlockType('table', 'CC.WikiEditor.TableBlock', {
	mEditorToolbarItem: new CC.WikiEditor.EditorToolbarItem({
		mDisplayTitle: "_Editor.Block.Table.Toolbar.Title".loc(),
		mTooltip: "_Editor.Block.Table.Toolbar.Tooltip".loc(),
		mIsEnabled: true,
		mKey: 'table',
		mAction: 'addBlock',
		mTarget: tableBlockDelegate()
	}),
	mBlockToolbar: 'CC.WikiEditor.TableBlockToolbar'
});
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.

var SandboxBlockDelegate = Class.createWithSharedInstance('sandboxBlockDelegate');
SandboxBlockDelegate.prototype = {
	initialize: function() {},
	addBlock: function() {
		var sandbox = editorToolbarDelegate().addBlock('sandbox', {}, true);
		if (sandbox && sandbox.mViewInstance) sandbox.mViewInstance.handleInfoButtonClicked();
	}
};

CC.WikiEditor.SandboxBlock = Class.create(CC.WikiEditor.Block, {
	mBlockView: 'CC.WikiEditor.SandboxBlockView',
	handleDidStartEditing: function($super, inOptInfo) {
		$super.apply(null, Array.prototype.slice.call(arguments, 1));
		this.mViewInstance._activate();
	},
	handleDidResumeEditing: function($super, inOptInfo) {
		$super.apply(null, Array.prototype.slice.call(arguments, 1));
		this.mViewInstance._reactivate();
	},
	handleDidStopEditing: function($super, inOptInfo) {
		$super.apply(null, Array.prototype.slice.call(arguments, 1));
		this.mViewInstance._deactivate();
	},
	handleFinishedAddingBlock: function($super, inOptInfo) {
		$super.apply(null, Array.prototype.slice.call(arguments, 1));
		this.mViewInstance.renderFrame();
	},
	restore: function($super, inChangesets) {
		var changesetKey, changesetValue, changesetIdx, changes;
		for (changesetIdx = 0; changesetIdx < inChangesets.length; changesetIdx++) {
			changes = inChangesets[changesetIdx];
			if (changes.length < 2) continue;
			changesetKey = changes[0];
			changesetValue = changes[1];
			if (changesetKey != 'extendedAttributes') continue;
			// Restore and render any markup.
			var content = changesetValue.markup || "";
			this.setRecordPropertyForPath('extendedAttributes.markup', content);
			this.mViewInstance.renderFrame();
		}
		$super(inChangesets);
	}
});

CC.WikiEditor.SandboxBlockView = Class.create(CC.WikiEditor.NonTextBlockView, CC.WikiEditor.Mixins.AskBeforeDeleting, {
	mFlipped: false,
	mDeleteDialogTitle: "_Editor.Block.Sandbox.Dialog.Delete.Title".loc(),
	mDeleteDialogDescription: "_Editor.Block.Sandbox.Dialog.Delete.Description".loc(),
	renderAsHTML: function() {
		var attrs = this.mContent.getRecordPropertyForPath('extendedAttributes');
		var markup = attrs['markup'] || "";
		var eventDelegateIdentifer = this.getEventDelegateIdentifer();
		var html = "<div class=\"container wrapchrome\">" +
			"<div class=\"frontside wrapchrome\"><div id=\"%@\" class=\"info clickable chrome\"></div><div class=\"iframe wrapchrome\"></div></div>".fmt(eventDelegateIdentifer + "-info") +
			"<div class=\"flipside chrome\">" +
				"<div class=\"controls\"><textarea id=\"%@\" class=\"markup clickable\" placeholder=\"%@\" title=\"%@\">%@</textarea></div>".fmt(eventDelegateIdentifer + "-markup", "_Editor.Block.Sandbox.Markup.Description".loc(), "_Editor.Block.Sandbox.Markup.Description".loc(), markup) +
				"<div class=\"buttons\"><div id=\"%@\" class=\"button matchstyles clickable\" title=\"%@\">%@</div><div id=\"%@\" class=\"button clickable done\">%@</div></div>".fmt(eventDelegateIdentifer + "-matchstyles", "_Editor.Block.Sandbox.Edit.MatchStyle.Tooltip".loc(), "_Editor.Block.Sandbox.Edit.MatchStyle.Label".loc(), eventDelegateIdentifer + "-done", "_Editor.Block.Sandbox.Edit.Done.Label".loc()) +
			"</div></div>";
		return html;
	},
	renderFrame: function() {
		var frame = this.$().down('.iframe');
		if (this.mContent.mParentContainer) {
			var migrated = (this.mContent.mParentContainer.getRecordPropertyForPath('extendedAttributes.migrated') != undefined);
			migrated ? frame.addClassName('migrated') : frame.removeClassName('migrated');
		}
		Element.update(frame, (this.mContent.getRecordPropertyForPath('extendedAttributes.markup') || ""));
	},
	registerEventHandlers: function() {
		bindEventListeners(this, [
			'stopPropagation',
			'handleInfoButtonClicked',
			'handleMatchStylesButtonClicked',
			'handleDoneButtonClicked'
		]);
		var eventDelegateIdentifer = this.getEventDelegateIdentifer();
		globalEventDelegate().bulkRegisterDomResponderForEventByIdentifer([
			['keydown', "%@-markup".fmt(eventDelegateIdentifer), this.stopPropagation],
			['paste', "%@-markup".fmt(eventDelegateIdentifer), this.stopPropagation],
			['click', "%@-info".fmt(eventDelegateIdentifer), this.handleInfoButtonClicked],
			['click', "%@-matchstyles".fmt(eventDelegateIdentifer), this.handleMatchStylesButtonClicked],
			['click', "%@-done".fmt(eventDelegateIdentifer), this.handleDoneButtonClicked]
		]);
	},
	_activate: function() {
		setTimeout(this._reactivate.bind(this), 400);
	},
	_reactivate: function() {
		if (this.mFlipped) {
			this.$().down('textarea').focus();
		}
	},
	_deactivate: function() {
		if (this.mFlipped) this.handleDoneButtonClicked();
	},
	setContent: function(inContent) {
		this.mContent.setRecordPropertyForPath('extendedAttributes.markup', (inContent || ""));
	},
	getFrameContent: function() {
		var frame = this.$().down('.iframe');
		return frame.innerHTML;
	},
	// Removes elements or attributes we added dynamically when rendering this sandbox.
	cleanDynamicContent: function(inDocument) {
		if (!inDocument || !inDocument.querySelectorAll) return false;
		// Undo any attachment link wrappers.
		var links = inDocument.select('.wikieditor_sandbox_attachment_wrapper'), link;
		for (var linkIdx = links.length - 1; linkIdx >= 0; linkIdx--) {
			link = links.item(linkIdx);
			promoteElementChildren(link);
		}
	},
	enableAttachmentLinks: function() {
		var frame = this.$().down('.iframe');
		var attachmentImages = frame.select('.attachment_handle_img');
		for (var idx = 0; idx < attachmentImages.length; idx++) {
			var img, a;
			img = attachmentImages.item(idx);
			a = document.createElement('a');
			a.className = 'wikieditor_sandbox_attachment_wrapper';
			a.setAttribute('href', '#');
			a.setAttribute('title', img.getAttribute('title'));
			img.parentNode.insertBefore(a, img);
			a.appendChild(img.cloneNode(true));
			img.parentNode.replaceChild(a, img);
			a.onclick = function(inEvent) {
				// Calculate the target URL for the nested img tag inside the link tag.
				var eventSource = Event.findElement(inEvent, 'a');
				if (eventSource) {
					var imgSource = eventSource.down('img');
					var targetURL = getFileDownloadURL(imgSource, true);
					window.location.href = targetURL;
				}
			}
		}
	},
	// 8579019
	enableEmbeddedMedia: function() {
		var frame = this.$().down('.iframe');
		var posterImages = frame.select('.posterimg'), posterImageIdx, posterImage;
		for (posterImageIdx = 0; posterImageIdx < posterImages.length; posterImageIdx++) {
			posterImage = posterImages.item(posterImageIdx);
			posterImage.setAttribute('tabindex', '0');
			posterImage.setAttribute('role', 'button');
			posterImage.onclick = function(inEvent) {
				var img = Event.element(inEvent);
				if (!img) return false;
				var mediaProperties = {
					'src': getFileDownloadURL(img, true),
					'width': img.width,
					'height': img.height
				}
				return qtMediaExpander().expandMedia(mediaProperties, img);
			}
		}
	},
	// A sandbox block is empty if it has no markup.
	isEmpty: function() {
		var markup = this.mContent.getRecordPropertyForPath('extendedAttributes.markup');
		return (markup == undefined || markup == "");
	},
	// Flips the sandbox block to reveal the back of the block. Accepts an optional
	// inOptShowSettings boolean argument, falling back to a toggle behavior otherwise.
	flip: function(inOptShowSettings) {
		// Reset the coorrdinate system once the transition is done.
		var elem = this.$();
		var showSettings = (inOptShowSettings || !elem.hasClassName('flipped'));
		if (showSettings) {
			elem.addClassName('staged');
			setTimeout(function() {
				elem.addClassName('flipped');
				setTimeout(function() {
					elem.addClassName('focused');
				}, 700);
			}, 50);
		} else {
			elem.addClassName('reset').removeClassName('flipped');
			setTimeout(function() {
				elem.removeClassName('reset');
			}, 1);
			setTimeout(function() {
				elem.removeClassName('focused');
				setTimeout(function() {
					elem.removeClassName('staged');
				}.bind(this), 50);
			}.bind(this), 750);
		}
		this.mFlipped = showSettings;
	},
	stopPropagation: function(inEvent) {
		inEvent.stopPropagation();
	},
	handleInfoButtonClicked: function(inEvent) {
		var markup = (this.getFrameContent() || this.mContent.getRecordPropertyForPath('extendedAttributes.markup'));
		var textarea = this.$().down('textarea');
		if (markup != undefined) textarea.value = markup;
		// Resize the text area to fit the sandbox.
		var containerLayout = this.$('.flipside').getLayout();
		textarea.setStyle({
			'height': (containerLayout.get('height') - 14 - 50) + 'px',
			'margin': '10px 0px 0px 12px',
			'width': (containerLayout.get('width') - 14 - 24) + 'px'
		});
		this.flip(true);
		this._reactivate();
	},
	handleDoneButtonClicked: function(inEvent) {
		var markup = this.mContent.getRecordPropertyForPath('extendedAttributes.markup');
		var textarea = this.$().down('textarea');
		var changes = $F(textarea);
		if (changes != markup && !changes.isWhitespace()) {
			this.mContent.setRecordPropertyForPath('extendedAttributes.markup', changes);
			this.renderFrame();
			this.flip(false);
			return;
		}
		this.flip(false);
	},
	handleMatchStylesButtonClicked: function(inEvent) {
		if ($('sandbox_block_match_styles_dialog')) Element.remove('sandbox_block_match_styles_dialog');
		dialogManager().drawDialog('sandbox_block_match_styles_dialog', ["_Editor.Block.Sandbox.Edit.MatchStyle.Dialog.Description".loc()], "_Editor.Block.Sandbox.Edit.MatchStyle.Dialog.OK".loc(), null, "_Editor.Block.Sandbox.Edit.MatchStyle.Dialog.Title".loc());
		// Migrate this sandbox in place and remove this block.
		var callback = function() {
			this.handleDoneButtonClicked();
			dialogManager().showProgressMessage("_Editor.Migration.Progress.MatchStyles".loc());
			var markup = (this.$().down('textarea').value || "");
			var migrated = globalEditorMigrationController().migrate(markup);
			if (migrated) {
				// If this sandbox is inside a text block (it should be) create a selection that spans the root
				// element of this block before migrating. The result of the migration will replace this block
				// using contentEditable insertHTML/pasteHTML commands.
				var directBlockParent = this.$().up('.block');
				if (directBlockParent && directBlockParent.getAttribute('data-type') == 'text') {
					var wrapperSpan = Element.wrap(this.$(), 'span');
					wrapperSpan.focus();
					globalEditorTextSelectionDelegate().selectAllChildren(wrapperSpan);
					textBlockDelegate().appendMigratedContentToBlockAtSelection(this.mContent.mParentContainer, migrated, false);
				}
			}
			dialogManager().hideProgressMessage();
		}.bind(this);
		// Confirm first.
		dialogManager().show('sandbox_block_match_styles_dialog', null, callback, inEvent.findElement('.matchstyles'), false, undefined, false);
	}
});

globalEditorPluginManager().registerBlockType('sandbox', 'CC.WikiEditor.SandboxBlock', {
	mEditorToolbarItem: new CC.WikiEditor.EditorToolbarItem({
		mDisplayTitle: "_Editor.Toolbar.Block.Sandbox.Title".loc(),
		mTooltip: "_Editor.Toolbar.Block.Sandbox.Tooltip".loc(),
		mClassName: 'sandboxblock',
		mIsEnabled: true,
		mKey: 'sandbox',
		mAction: 'addBlock',
		mTarget: sandboxBlockDelegate()
	})
});
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.








;
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.

CC.Revisions = CC.Revisions || new Object();
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.



CC.Revisions.NOTIFICATION_DID_RESTORE_ENTITY_REVISION = 'DID_RESTORE_ENTITY_REVISION';

// Revisions service responsible for fetching and restoring entity revisions.

CC.Revisions.RevisionService = Class.create({
	// Returns an single revision for an entity with a given GUID.
	getRevisionForEntityWithGUID: function(inGUID, inRevision, inOptCallback) {
		if (!inGUID || inRevision == undefined) return (inOptCallback ? inOptCallback([]) : undefined);
		var callback = function(inResponse) {
			if (inOptCallback) return inOptCallback(inResponse);
		}
		server_proxy().pastEntityForGUIDAtRevision(inGUID, inRevision, callback, callback);
	},
	// Fetches a lightweight set of revision data for an entity. Returns a rendered partial
	// ready to be inserted into the DOM. Accepts an optional revision and callback.
	getRevisionsSummaryForEntityWithGUID: function(inGUID, inRevision, inOptCallback) {
		if (!inGUID) return (inOptCallback ? inOptCallback([]) : undefined);
		var callback = function(inResponse) {
			if (inOptCallback) return inOptCallback(inResponse.response[0]);
		}
		server_proxy().revisionSummaryForGUID(inGUID, inRevision, callback, callback);
	},
	// Returns a diffed version of an entity between two specified revisions.
	// Assumes the entity is a page, and extendedAttributes.renderedPage is
	// being compared.
	getDiffForEntityBetweenRevisions: function(inGUID, inFirstRevision, inSecondRevision, inOptCallback) {
		if (!inGUID || (inFirstRevision == undefined || inSecondRevision == undefined)) return (inOptCallback ? inOptCallback() : undefined);
		server_proxy().diffForEntityBetweenRevisions(inGUID, inFirstRevision, inSecondRevision, inOptCallback, inOptCallback);
	},
	// Restores an entity with a given GUID to a state determined by a given timestamp.
	// Returns true if the operation was successful, and false otherwise.
	restoreEntityWithGUIDToRevision: function(inGUID, inRevision, inOptCallback) {
		if (!inGUID || !inRevision) return (inOptCallback ? inOptCallback() : undefined);
		var callback = function(inResponse) {
			var entity = inResponse.response;
			globalNotificationCenter().publish(CC.Revisions.NOTIFICATION_DID_RESTORE_ENTITY_REVISION, null, {'entity': entity});
			if (inOptCallback) inOptCallback(entity);
		}
		server_proxy().restoreRevision(inGUID, inRevision, callback, inOptCallback);
	}
});
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.





CC.Revisions.NOTIFICATION_REVISIONS_READY = 'DID_SHOW_REVISIONS';
CC.Revisions.NOTIFICATION_DID_SHOW_REVISIONS = 'DID_SHOW_REVISIONS';
CC.Revisions.NOTIFICATION_DID_HIDE_REVISIONS = 'DID_HIDE_REVISIONS';
CC.Revisions.NOTIFICATION_DID_SHOW_REVISION = 'DID_SHOW_REVISION';
CC.Revisions.NOTIFICATION_DID_SHOW_REVISION_DIFF = 'DID_SHOW_REVISION_DIFF';
CC.Revisions.NOTIFICATION_DID_SHOW_PREVIOUS_REVISION = 'DID_SHOW_PREVIOUS_REVISION';
CC.Revisions.NOTIFICATION_DID_SHOW_NEXT_REVISION = 'DID_SHOW_NEXT_REVISION';
CC.Revisions.NOTIFICATION_DID_RESTORE_PREVIOUS_REVISION = 'DID_RESTORE_PREVIOUS_REVISION';

// Simple history view implementation.

CC.Revisions.HistoryViewer = Class.create(CC.Keyboard.Mixins.Responder, {
	mRequestDelay: 250,
	mService: null,
	mBrowsingRevisions: false,
	mNowShowingRevisionIndex: 0,
	initialize: function(/* [options] */) {
		if (arguments.length && arguments[0]) Object.extend(this, arguments[0]);
		this._render();
		globalNotificationCenter().subscribe(CC.Revisions.NOTIFICATION_DID_SHOW_REVISIONS, this.updateButtonsForSelection.bind(this));
		globalNotificationCenter().subscribe(CC.Revisions.NOTIFICATION_DID_SHOW_PREVIOUS_REVISION, this.updateButtonsForSelection.bind(this));
		globalNotificationCenter().subscribe(CC.Revisions.NOTIFICATION_DID_SHOW_NEXT_REVISION, this.updateButtonsForSelection.bind(this));
		globalNotificationCenter().subscribe(CC.WikiEditor.NOTIFICATION_DID_SAVE_PAGE, this.handlePageDidSave.bind(this));
		globalNotificationCenter().subscribe(CC.WikiEditor.NOTIFICATION_DID_START_EDITING, this.hideRevisions.bind(this));
		globalNotificationCenter().subscribe(CC.UpdatesSidebar.NOTIFICATION_DID_CLOSE_UPDATES_SIDEBAR, this.hideRevisions.bind(this));
	},
	_render: function() {
		var rootElement = this.mRootSidebarElement;
		var tabIndexHistoryActionClose = accessibility().requestTabIndex(CC.Accessibility.TAB_INDEX_NAME_SIDEBAR_HISTORY_ACTION_CLOSE);
		var tabIndexHistoryActionRestore = accessibility().requestTabIndex(CC.Accessibility.TAB_INDEX_NAME_SIDEBAR_HISTORY_ACTION_RESTORE);
		var tabIndexHistoryActionShowchanges = accessibility().requestTabIndex(CC.Accessibility.TAB_INDEX_NAME_SIDEBAR_HISTORY_ACTION_SHOWCHANGES);
		var tabIndexHistoryHideChanges = accessibility().requestTabIndex(CC.Accessibility.TAB_INDEX_NAME_SIDEBAR_HISTORY_ACTION_HIDECHANGES);
				
		this.mRevisionsListingElement = Builder.node('div', {className: 'revisions listing'});		
		Element.insert(rootElement, {'top': this.mRevisionsListingElement});
		this.mRevisionsDetailElement = Builder.node('div', {className: 'revisions detail browsing'}, [
			Builder.node('div', {'role': 'navigation', 'aria-label': "_Accessibility.MenuBar.HistoryControls".loc(), className: 'controls'}, [
				Builder.node('a', {'tabindex': tabIndexHistoryActionClose, 'role': 'button', className: 'button close'}, "_Revisions.Controls.Cancel.Label".loc()),
				Builder.node('a', {'tabindex': tabIndexHistoryActionRestore, 'role': 'button', className: 'button restore'}, "_Revisions.Controls.Restore.Label".loc()),
				Builder.node('a', {'tabindex': tabIndexHistoryActionShowchanges, 'role': 'button', className: 'button showchanges'}, "_Revisions.Controls.ShowChanges.Label".loc()),
				Builder.node('a', {'tabindex': tabIndexHistoryHideChanges, 'role': 'button', className: 'button hidechanges'}, "_Revisions.Controls.HideChanges.Label".loc())
			]),
			Builder.node('div', {className: 'previews'})
		]);
		bindEventListeners(this, [
			'hideRevisions',
			'handleRestoreButtonClicked',
			'handleShowChangesButtonClicked',
			'handleHideChangesButtonClicked',
			'handleRevisionItemClicked'
		]);
		Event.observe(this.mRevisionsDetailElement.down('.button.close'), 'click', this.hideRevisions);
		Event.observe(this.mRevisionsDetailElement.down('.button.restore'), 'click', this.handleRestoreButtonClicked);
		Event.observe(this.mRevisionsDetailElement.down('.button.showchanges'), 'click', this.handleShowChangesButtonClicked);
		Event.observe(this.mRevisionsDetailElement.down('.button.hidechanges'), 'click', this.handleHideChangesButtonClicked);
		$('content-primary').appendChild(this.mRevisionsDetailElement);
	},
	initializeRevisions: function() {
		var revisionsContainer = this.mRevisionsListingElement;
		var revisions = revisionsContainer.select('.revision');
		// Show an empty placeholder if needs be, and register any event handlers.
		if (revisions.length == 0) {
			this.mRootSidebarElement.down('.placeholder').show();
		} else {
			this.mRootSidebarElement.down('.placeholder').hide();
			revisions.each(function(item) {
				Event.observe(item, 'click', this.handleRevisionItemClicked);
			}, this);
		}
		globalNotificationCenter().publish(CC.Revisions.NOTIFICATION_REVISIONS_READY);
	},
	// Handles a page save notification.
	handlePageDidSave: function(inMessage, inObject, inOptExtras) {
		if (inObject) {
			var pageGUID = CC.meta('x-apple-entity-guid');
			var revision = inObject.getRecordPropertyForPath('revision');
			var tabIndexHistoryItem = accessibility().requestTabIndex(CC.Accessibility.TAB_INDEX_NAME_SIDEBAR_HISTORY);
			var callback = function(response) {
				CC.setMeta('x-apple-entity-revision', response.revision);
				var newElem = Builder.node('div', {}, [Builder.node('div', {'tabindex': tabIndexHistoryItem, 'role': 'menuitem', className:'revision', name:"revision-"+response.revision, 'data-revision':response.revision, 'data-update-time':response.updateTime}, [
					Builder.node('span', {className:'author'}, response.updatedByUserLongName),
					Builder.node('span', {className:'time'}, globalLocalizationManager().shortLocalizedDateTime(response.updateTime))
				])]);				
				this.mRevisionsListingElement.innerHTML = (newElem.innerHTML + this.mRevisionsListingElement.innerHTML);
				this.initializeRevisions();
			}.bind(this);
			this.mRevisionsService.getRevisionsSummaryForEntityWithGUID(pageGUID, revision, callback);
		}
	},
	// Restores an entity with a given entity guid to a particular revision.
	restoreEntityWithGUIDToRevision: function(inEntityGUID, inRevision, inOptCallback) {
		this.mRevisionsService.restoreEntityWithGUIDToRevision(inEntityGUID, inRevision, inOptCallback);
	},
	showRevisions: function() {
		if (this.mBrowsingRevisions) return;
		document.body.addClassName('revisions');
		this.mBrowsingRevisions = true;
		this.becomeFirstResponder();
		globalNotificationCenter().publish(CC.Revisions.NOTIFICATION_DID_SHOW_REVISIONS);
	},
	hideRevisions: function() {
		if (!this.mBrowsingRevisions) return;
		document.body.removeClassName('revisions');
		$$('.revision.selected').invoke('removeClassName', 'selected');
		this.mBrowsingRevisions = false;
		this.loseFirstResponder();
		globalNotificationCenter().publish(CC.Revisions.NOTIFICATION_DID_HIDE_REVISIONS);
	},
	prepareAndShowRevisionAtIndex: function(inRevisionIndex) {
		var revision = this.mRevisionsListingElement.select('.revision')[inRevisionIndex];
		this.prepareAndShowRevision(revision.getAttribute('name').match(/revision-([0-9]+)/)[1]);
	},
	// Prepares and shows a particular revision in the timeline. If no revision index is
	// specified, defaults to showing the first revision. The revision index is the index
	// of the revision in the stack, not the revision identifier (since they may not be
	// sequential).
	prepareAndShowRevision: function(inOptRevision) {
		var revision = (inOptRevision || 0);
		// Update the currently selected revision in the revisions listing.
		var items = this.mRevisionsListingElement.select('.revision');
		items.invoke('removeClassName', 'selected');
		if (revision < 0) revision = 0;
		var item = this.mRevisionsListingElement.down('.revision[name="revision-%@"]'.fmt(revision));
		if (!item) return;
		item.addClassName('selected');
		item.removeClassName('unread');
		// Update the unread count.
		var unreadCount = this.mRevisionsListingElement.select('.unread').length;
		var unreadElement = this.mRevisionsListingElement.up('.cc-sidebar-section').down('h3 .unread');
		if (unreadElement) {
			unreadElement.innerHTML = (unreadCount > 0 ? "_Sidebars.Title.Unread.Count".loc(unreadCount) : "");
		}
		// Show the corresponding preview for this revision, loading the preview on-demand
		// if we don't already have it.
		dialogManager().showProgressMessage("_Revisions.Progress.Loading.Revision".loc());
		var preview = this.mRevisionsDetailElement.down('.revision[name="revision-%@"]'.fmt(revision));
		if (!preview) {
			preview = Builder.node('div', {className: 'revision', name: "revision-%@".fmt(revision)});
			Element.insert(this.mRevisionsDetailElement.down('.previews'), {'top': preview});
		}
		var previewReadyCallback = function() {
			dialogManager().hide();
			// Hide any currently showing previews.
			this.mRevisionsDetailElement.select('.selected').invoke('removeClassName', 'selected');
			preview.addClassName('selected');
			// Update the now showing index.
			this.mNowShowingRevision = revision;
			// If we're diffing, toggle diff mode.
			if (this.mRevisionsDetailElement.hasClassName('diffing')) this.handleShowChangesButtonClicked();
			// If we're displaying the most recent document revision, hide the restore button.
			var currentRevision = (CC.meta('x-apple-entity-revision') == this.mNowShowingRevision);
			var restoreButton = this.mRevisionsDetailElement.down('.controls .restore');
			if (restoreButton) currentRevision ? restoreButton.hide() : restoreButton.show();
			// Publish a notification.
			globalNotificationCenter().publish(CC.Revisions.NOTIFICATION_DID_SHOW_REVISION);
			this.showRevisions();
		}.bind(this);
		// If we have the revision preview already, show it immediately.
		if (preview.down('.current')) return previewReadyCallback();
		// Otherwise fetch and render it before displaying it.
		var entityGUID = CC.meta('x-apple-entity-guid');
		// If the revision is a wiki page, use the rapid-rendered page content as the preview.
		// Otherwise, if the revision looks like a file entity, render an inline file detail.
		// If the revision appears empty, fall back to rendering a placeholder string.
		var gotRevisionCallback = function(inRevision) {
			var revisionTitle = Builder.node('div', {className: 'cc-entity-title'}, [
				Builder.node('h1', inRevision.longName),
			]);
			var revisionPreview = Builder.node('div', {className: 'current'});
			if (inRevision.extendedAttributes && inRevision.extendedAttributes.renderedPage) {
				revisionPreview.innerHTML = inRevision.extendedAttributes.renderedPage;
				// 9311069
				// Some pages got saved with contentEditable attributes or editing class names.
				revisionPreview.select('*[contentEditable="true"]').invoke('removeAttribute', 'contentEditable');
				revisionPreview.select('.editing').invoke('removeClassName', 'editing');
				this.enableAttachmentsForPreviewElement(revisionPreview);
			} else if (inRevision.previewGUIDs || inRevision.iconGUID) {
				var fileDetailView = CC.Files.buildInlineFileDetailView(inRevision, false);
				revisionPreview.appendChild(fileDetailView.mParentElement);
			} else {
				revisionPreview.appendChild(Builder.node('h1', {className: 'empty'}, "_Revisions.Placeholder.Empty.Revision".loc()));
			}
			// Show the preview we just rendered.
			preview.appendChild(revisionTitle);
			preview.appendChild(revisionPreview);
			previewReadyCallback();
		}.bind(this);
		this.mRevisionsService.getRevisionForEntityWithGUID(entityGUID, revision, gotRevisionCallback);
	},
	// 9311069
	enableAttachmentsForPreviewElement: function(inElement) {
		var attachments = inElement.select('.block.attachment'), attachmentIdx, attachment;
		for (attachmentIdx = 0; attachmentIdx < attachments.length; attachmentIdx++) {
			attachment = attachments[attachmentIdx];
			attachment.down('.attachment').removeClassName('quicklookable');
			var fileDataGUID = attachment.getAttribute('data-file-guid');
			if (fileDataGUID) {
				var leftContainer = attachment.down('.left-container');
				leftContainer.onclick = function() {
					window.location.href = "/wiki/files/download/%@".fmt(fileDataGUID);
					return true;
				}
			}
		}
	},
	// Updates the buttons for the currently selected preview.
	updateButtonsForSelection: function() {
		// TODO
	},
	older: function() {
		var currentRevision = this.mRevisionsListingElement.down('.revision.selected');
		if (currentRevision) {
			var previousRevision = currentRevision.next('.revision');
			if (previousRevision) {
				this.prepareAndShowRevision(previousRevision.getAttribute('name').match(/revision-([0-9]+)/)[1]);
				globalNotificationCenter().publish(CC.Revisions.NOTIFICATION_DID_SHOW_PREVIOUS_REVISION);
			}
		}
	},
	newer: function() {
		var currentRevision = this.mRevisionsListingElement.down('.revision.selected');
		if (currentRevision) {
			var nextRevision = currentRevision.previous('.revision');
			if (nextRevision) {
				this.prepareAndShowRevision(nextRevision.getAttribute('name').match(/revision-([0-9]+)/)[1]);
				globalNotificationCenter().publish(CC.Revisions.NOTIFICATION_DID_SHOW_NEXT_REVISION);
			}
		}
	},
	handleRestoreButtonClicked: function(inEvent) {
		dialogManager().showProgressMessage("_Revisions.Progress.Restoring.Document".loc());
		var entityGUID = CC.meta('x-apple-entity-guid');
		var revision = this.mRevisionsListingElement.down('.revision.selected');
		if (!revision) return true;
		var revisionAttributes = revision.getDataAttributes();
		var revisionNumber = revisionAttributes['revision'];
		var restoreCallback = function(entity) {
			dialogManager().hide();
			this.hideRevisions();
			if (entity && entity.guid) {
				window.location.reload();
			} else {
				notifier().printErrorMessage("_Revisions.Notification.Restore.Document.Failed".loc())
			}
		}
		this.mRevisionsService.restoreEntityWithGUIDToRevision(entityGUID, revisionNumber, restoreCallback.bind(this));
	},
	handleShowChangesButtonClicked: function(inEvent) {
		// Do we already have the diff for this revision?
		var activeRevision = this.mRevisionsDetailElement.down('.revision[name="revision-%@"]'.fmt(this.mNowShowingRevision));
		if (!activeRevision) return;
		if (activeRevision.down('.diff')) {
			this.mRevisionsDetailElement.removeClassName('browsing').addClassName('diffing');
			return;
		}
		// Otherwise we need to request it.
		dialogManager().showProgressMessage("_Revisions.Progress.Loading.Revision.Changes".loc());
		var currentRevision = this.mRevisionsListingElement.down('.revision.selected');
		var previousRevisionIndex = 0;
		if (currentRevision) {
			// Previous revision is actually the next revision in the history list.
			var previousRevision = currentRevision.next('.revision');
			if (previousRevision) {
				previousRevisionIndex = previousRevision.getAttribute('data-revision');
			} else {
				// May be we are at the last revision before pagination
				var paginationElement = this.mRootSidebarElement.up().down('.cc-sidebar-pagination');
				if (paginationElement && paginationElement.getAttribute('data-pagination-ids').length) {
					previousRevisionIndex = paginationElement.getAttribute('data-pagination-ids').split(',')[0];
				}
			}
		}
		var diffCallback = function(diff) {
			dialogManager().hide();
			this.mRevisionsDetailElement.removeClassName('browsing').addClassName('diffing');
			// If we didn't get a diff, show an error.
			if (diff == undefined) return notifier().printErrorMessage("_Revisions.Notification.Revision.Changes.Failed".loc());
			// Otherwise append a new diff element. If the diff is empty, use the content
			// of the revision instead so we have something to show.
			var diffElement = Builder.node('div', {className: 'diff'});
			diffElement.innerHTML = diff ? diff : activeRevision.down('.current').innerHTML;
			activeRevision.appendChild(diffElement);
			globalNotificationCenter().publish(CC.Revisions.NOTIFICATION_DID_SHOW_REVISION_DIFF);
		};
		var entityGUID = CC.meta('x-apple-entity-guid');
		logger().debug("diffing between current: %s and previous %s", this.mNowShowingRevision, previousRevisionIndex)
		this.mRevisionsService.getDiffForEntityBetweenRevisions(entityGUID, previousRevisionIndex, this.mNowShowingRevision, diffCallback.bind(this));
	},
	handleHideChangesButtonClicked: function(inEvent) {
		this.mRevisionsDetailElement.removeClassName('diffing').addClassName('browsing');
	},
	handleRevisionItemClicked: function(inEvent) {
		var listElement = inEvent.findElement('.revision');
		// If we're toggling an already selected item, exit the history view.
		if (listElement.hasClassName('selected') && this.mBrowsingRevisions) {
			return this.hideRevisions();
		}
		// Otherwise, show just clicked revision.
		var revision = listElement.getAttribute('name').match(/revision-([0-9]+)/)[1];
		this.prepareAndShowRevision(revision);
	},
	handleKeyboardNotification: function(inMessage, inObject, inOptExtras) {
		switch (inMessage) {
			case CC.Keyboard.NOTIFICATION_DID_KEYBOARD_ESC:
				this.hideRevisions();
				break;
			case CC.Keyboard.NOTIFICATION_DID_KEYBOARD_UP:
			case CC.Keyboard.NOTIFICATION_DID_KEYBOARD_RIGHT:
				this.newer();
				break;
			case CC.Keyboard.NOTIFICATION_DID_KEYBOARD_DOWN:
			case CC.Keyboard.NOTIFICATION_DID_KEYBOARD_LEFT:
				this.older();
				break;
		}
		return true;
	}
});
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.

CC.QuickLook = CC.QuickLook || new Object();
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.

CC.QuickLook.NOTIFICATION_DID_FETCH_QUICKLOOK_INFO = 'DID_FETCH_QUICKLOOK_INFO';

// Basic quicklook service.

CC.QuickLook.Service = Class.create({
	// Is this the first polling request?
	mIsFirstRequest: true,
	// How often should we ask for preview information?
	mInitialInterval: 1000,
	mSubsequentInterval: 3000,
	// How many times should we ask for preview information before giving up?
	mMaxPollRequests: 50,
	mPollRequestsSoFar: 0,
	// Returns a hash of preview information for an entity with a given GUID if it
	// exists. Returns undefined where a quicklook could not be generated or a
	// preview does not exist.
	getPreviewInfoForEntityGUID: function(inGUID, inOptCallback, inOptForceRefresh) {
		if (!inGUID) return (inOptCallback ? inOptCallback() : undefined);
		var gotBatchedResponse = function(service_response) {
			var mappedEntity;
			if (service_response && service_response.responses && service_response.responses.length > 1) {
				var firstResponse = service_response.responses[1];
				var entity = firstResponse.response;
				var mappedEntity = (entity ? this._mapPreviewInfoFromEntity(entity) : undefined);
			}
			if (!inOptCallback) return mappedEntity;
			return inOptCallback(mappedEntity);
		}.bind(this);
		var batch = [
			// Kick off a preview if we need one.
			['QuickLookService', 'generateQuicklookIfNeededForFileEntityGUID:', inGUID],
			// Fetch the entity and map the result into a preview hash.
			['ContentService', 'entityForGUID:', inGUID, {'subpropertyPaths': server_proxy().mDefaultSubpropertyPaths}]
		];
		return service_client().batchExecuteAsynchronously(batch, {}, gotBatchedResponse, function() {
			console.error("Could not get preview information for entity guid (%o)", inGUID);
			return invalidate;
		});
	},
	// Fetches preview properties for a given entity on a timer. Where a preview is still
	// being generated, we poll (degrading exponentially) until the preview is ready or it
	// is deemed the preview cannot be generated.
	pollForPreviewInformation: function(inGUID, inCallback) {
		var gotResponse = function(inResponse) {
			this.mPollRequestsSoFar += 1;
			var properties = inResponse;
			// Is the preview still generating? Have we requested too many times?
			if ((this.mPollRequestsSoFar < this.mMaxPollRequests) && (!properties || (properties && properties.status && (properties.status == 'working')))) {
				var interval = (this.mIsFirstRequest ? this.mInitialInterval : this.mSubsequentInterval);
				this.mIsFirstRequest = false;
				if (this.mRequestTimer) clearTimeout(this.mRequestTimer);
				this.mRequestTimer = setTimeout(function() {
					this.getPreviewInfoForEntityGUID(inGUID, gotResponse.bind(this));
				}.bind(this), interval);
			} else {
				if (this.mRequestTimer) {
					clearTimeout(this.mRequestTimer);
					delete this.mRequestTimer;
					this.mIsFirstRequest = true;
					this.mPollRequestsSoFar = 0;
				}
				if (inCallback) return inCallback(properties);
			}
		}.bind(this);
		return this.getPreviewInfoForEntityGUID(inGUID, gotResponse);
	},
	// Returns a hash of preview info for a file entity.
	_mapPreviewInfoFromEntity: function(inEntity) {
		var result = {};
		if (!inEntity) return undefined;
		var isQuickLookable = inEntity.isQuickLookable;
		var title = inEntity.longName;
		var result = $H({
			'status': (isQuickLookable == true || isQuickLookable == false) ? 'ready' : 'working',
			'isQuickLookable': isQuickLookable,
			'title': title
		});
		// Bail if the entity isn't quicklookable, or the preview is not yet ready.
		if (!isQuickLookable) return result.toObject();
		// Is the preview audio or video?
		var mediaType = (inEntity.mediaType || "");
		result.update({'mediaType': mediaType});
		if (inEntity.extendedAttributes) {
			var width = parseInt(inEntity.extendedAttributes.width) || 0;
			var height = parseInt(inEntity.extendedAttributes.height) || 0;
			var size = (!width.isNaN ? {'width': Math.floor(width), 'height': Math.floor(height)} : undefined);
			result.update({
				'isAudio': (mediaType.match(/audio/) != undefined),
				'isVideo': (mediaType.match(/movie|video/) != undefined),
				'size': size
			});
		}
		// Build a list of all the thumbnails and previews for this quicklook.
		var url = '%@//%@'.fmt(window.location.protocol, window.location.host);
		var mapGUIDtoURL = function(guid) {
			return url + '%@/files/download/%@'.fmt(env().root_path, guid);
		}
		var thumbnailURLs = $A(inEntity.thumbnailGUIDs).map(mapGUIDtoURL);
		var previewURLs = $A(inEntity.previewGUIDs).map(mapGUIDtoURL);
		var downloadURL = mapGUIDtoURL(inEntity.guid);
		// A preview is paginated if there is more than one preview image.
		var isPaginated = (previewURLs.length > 1);
		// Update and return.
		result.update({
			'isPaginated': isPaginated,
			'pageCount': previewURLs.length,
			'thumbnailURLs': thumbnailURLs,
			'previewURLs': previewURLs,
			'downloadURL': downloadURL,
			'fileDataEntity': inEntity
		});
		return result.toObject();
	}
});
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.




// Notifications.

CC.QuickLook.NOTIFICATION_DID_SHOW_QUICKLOOK_PANEL = 'DID_SHOW_QUICKLOOK_PANEL';
CC.QuickLook.NOTIFICATION_DID_HIDE_QUICKLOOK_PANEL = 'DID_HIDE_QUICKLOOK_PANEL';
CC.QuickLook.NOTIFICATION_DID_CENTER_QUICKLOOK_PREVIEW = 'DID_CENTER_QUICKLOOK_PREVIEW';
CC.QuickLook.NOTIFICATION_DID_RESIZE_QUICKLOOK_PREVIEW = 'DID_RESIZE_QUICKLOOK_PREVIEW';
CC.QuickLook.NOTIFICATION_QUICKLOOK_DID_ENTER_FULLSCREEN_MODE = 'QUICKLOOK_DID_ENTER_FULLSCREEN_MODE';
CC.QuickLook.NOTIFICATION_QUICKLOOK_DID_EXIT_FULLSCREEN_MODE = 'QUICKLOOK_DID_EXIT_FULLSCREEN_MODE';

// Global quicklook instance.

CC.QuickLook.GlobalQuickLookInstance = Class.createWithSharedInstance('quicklook', false);
CC.QuickLook.GlobalQuickLookInstance.prototype = {
	mService: new CC.QuickLook.Service(),
	// The default panel size for a preview.
	mDefaultPanelSize: {'width': 960, 'height': 780},
	// The minimum panel size for a preview.
	mMinimumPanelSize: {'width': 640, 'height': 480},
	// Audio preview artwork should be 258px x 258px. Includes 6px width and 49px height compensation.
	mDefaultAudioPanelSize: {'width': 264, 'height': 307},
	// Default 480p movie size.
	mDefaultMovieSize: {'width': 640, 'height': 480},
	// Animation scale factor.
	mScaleFactor: 0.1,
	// Preloading spinner delay.
	mPreloadingDelay: 500,
	// Is quicklook active?
	mNowShowing: false,
	// Is the active request the first one we've made.
	mIsFirstRequest: true,
	// Is the active preview a movie or audio file?
	mIsVideo: false,
	mIsAudio: false,
	// Are we in full screen mode?
	mFullScreenBoundary: 25,
	mFullScreenMode: false,
	// Track any gesture start positions.
	mMouseDownPosition: {},
	initialize: function() {
		// User a smaller default panel size on mobile WebKit.
		if (browser().isMobileSafari) this.mDefaultPanelSize = {'width': 720, 'height': 588};
		// Bind any event listeners.
		bindEventListeners(this, [
			'showPreviewPanelAnimationDidFinish', 'hidePreviewPanel', 'hidePreviewPanelAnimationDidFinish', 
			'handleThumbnailClicked', 'handleResizeWidgetMouseDown', 'handleResizeWidgetMouseDrag',
			'handleResizeWidgetEndMouseDrag', 'toggleFullScreenMode', 'handleAttachmentDownloadClick',
			'handleWindowResized', 'handleWindowScrolled', 'handleWindowMouseDown', 'handleThumbnailScrollUpClick',
			'handleThumbnailScrollDownClick'
		]);
		globalNotificationCenter().subscribe(CC.Keyboard.NOTIFICATION_DID_KEYBOARD_ESC, this.handleKeyboardNotification.bind(this));
		globalNotificationCenter().subscribe(CC.Keyboard.NOTIFICATION_DID_KEYBOARD_LEFT, this.handleKeyboardNotification.bind(this));
		globalNotificationCenter().subscribe(CC.Keyboard.NOTIFICATION_DID_KEYBOARD_RIGHT, this.handleKeyboardNotification.bind(this));
		globalNotificationCenter().subscribe(CC.Keyboard.NOTIFICATION_DID_KEYBOARD_UP, this.handleKeyboardNotification.bind(this));
		globalNotificationCenter().subscribe(CC.Keyboard.NOTIFICATION_DID_KEYBOARD_DOWN, this.handleKeyboardNotification.bind(this));
	},
	// Renders the reusable quicklook chrome for displaying an preview. The quicklook dialog is
	// completely self contained, and appended to the document at the root level once the shared
	// instance is created.
	render: function() {
		if (this.mPreviewMask) this.mPreviewMask.remove();
		if (this.mPreviewPanel) this.mPreviewPanel.remove();
		this.mPreviewMask = Builder.node('div', {id: 'quicklook_mask', style: 'display: none;'});
		this.mPreviewPanel = Builder.node('div', {id: 'quicklook_panel', style: 'display: none;'}, [
			Builder.node('div', {id: 'quicklook_panel_close'}),
			Builder.node('div', {id: 'quicklook_panel_title'}),
			Builder.node('div', {id: 'quicklook_panel_loading', className: 'progress'}, [
				Builder.node('h2', {}, "_QuickLook.Status.Preview.Loading".loc())
			]),
			Builder.node('div', {id: 'quicklook_panel_error', className: 'progress', style: 'display: none;'}, [
				Builder.node('h2', {}, "_QuickLook.Status.Preview.Missing".loc())
			]),
			Builder.node('div', {id: 'quicklook_panel_browser', style: 'display: none'}),
			Builder.node('div', {id: 'quicklook_hovering_area'}, [
			    Builder.node('div', {id: 'quicklook_panel_preview', style: 'display: none'})
			])
		] );
		d.body.appendChild(this.mPreviewMask);
		d.body.appendChild(this.mPreviewPanel);

		this.renderRolloverControls();
		this.registerEventHandlers();
	},
	renderRolloverControls: function() {
		var fitOrFullScreen = document.body.hasClassName('ipad') ? 'fitscreen' : 'fullscreen';
		if (this.mRolloverControls) this.mRolloverControls.remove();
		this.mRolloverControls = Builder.node('div', {id: 'quicklook_hud', style: 'display: none;'}, [
			Builder.node('a', {id: 'quicklook_hud_scale', className: fitOrFullScreen}),
			Builder.node('a', {id: 'quicklook_hud_download', className: 'download'}),
			Builder.node('a', {id: 'quicklook_hud_close', className: 'close'})
		]);
		$('quicklook_hovering_area').insert(this.mRolloverControls);
		$('quicklook_hud_scale').observe('mousedown', this.toggleFullScreenMode);
		$('quicklook_hud_close').observe('mousedown', this.hidePreviewPanel);
		$('quicklook_hud_download').observe('click', this.handleAttachmentDownloadClick);
	},
	registerEventHandlers: function() {
		Event.observe('quicklook_panel_close', 'mouseup', this.hidePreviewPanel);
		Event.observe(window, 'resize', this.handleWindowResized);
		Event.observe(window, 'scroll', this.handleWindowScrolled);
		Event.observe(window, 'mousewheel', this.handleWindowScrolled);
		Event.observe(window, 'DOMMouseScroll', this.handleWindowScrolled);
		Event.observe(window, 'mousedown', this.handleWindowMouseDown);
	},
	unregisterEventHandlers: function() {
		Event.stopObserving('quicklook_panel_close', 'mouseup', this.hidePreviewPanel);
		Event.stopObserving('quicklook_mask', 'mouseup', this.hidePreviewPanel);
		Event.stopObserving(window, 'resize', this.handleWindowResized);
		Event.stopObserving(window, 'scroll', this.handleWindowScrolled);
		Event.stopObserving(window, 'mousewheel', this.handleWindowScrolled);
		Event.stopObserving(window, 'DOMMouseScroll', this.handleWindowScrolled);
		Event.stopObserving(window, 'mousedown', this.handleWindowMouseDown);
	},
	// Shows the preview panel. Accepts an optional inOptToggleFullScreenAtPageIndex argument
	// which, when supplied, will force the preview panel into full-screen mode at the specified
	// page index (if it exists).
	showPreviewPanelForAttachment: function(inAnchorElement, inEntityGUID, inOptToggleFullScreenAtPageIndex) {
		if (!inAnchorElement || !inEntityGUID) return false;
		// Stash the entity guid for later.
		this.mEntityGUID = inEntityGUID;
		// Render.
		this.render();
		this.mPreviewMask.show();
		// Do we have the preview information already?
		if (this.mPreviewInfo) {
			this.mIsAudio = this.mPreviewInfo.isAudio;
			this.mIsVideo = this.mPreviewInfo.isVideo;
			// Special-case audio and video previews (6421171 & 6421173). If the preview is a movie,
			// size the preview window to fit the width, height and aspect ratio of the preview. If
			// the preview is an audio file, special case the window dimensions. Otherwise, use the default
			// dimensions.
			if (this.mIsAudio || this.mIsVideo) {
				this.mStashedDefaultPanelSize = this.mDefaultPanelSize;
				if (this.mIsVideo) {
					if (this.mPreviewInfo.size && this.mPreviewInfo.size.width && this.mPreviewInfo.size.height) {
						this.mDefaultPanelSize = {'width': this.mPreviewInfo.size.width + 6, 'height': this.mPreviewInfo.size.height + 49};
					}
				}
				else if (this.mIsAudio) {
					this.mDefaultPanelSize = this.mDefaultAudioPanelSize;
				}
			}
			// Are we opening at a specific page index?
			else if ((inOptToggleFullScreenAtPageIndex != undefined) && (this.mPreviewInfo.previewURLs && inOptToggleFullScreenAtPageIndex < this.mPreviewInfo.previewURLs.length)) {
				this.mStashedDefaultPanelSize = this.mDefaultPanelSize;
				this.mDefaultPanelSize = this.calculateFullScreenWidthHeightLeftTop();
				this.mToggleFullScreenIndex = Math.max(0, inOptToggleFullScreenAtPageIndex);
			}
			// If this is a single-image preview, size the quicklook window to fit.
			else if (!this.mPreviewInfo.isPaginated && this.mPreviewInfo.size && this.mPreviewInfo.size.width && this.mPreviewInfo.size.height) {
				this.mStashedDefaultPanelSize = this.mDefaultPanelSize;
				var width = this.mPreviewInfo.size.width;
				var height = this.mPreviewInfo.size.height;
				var ratio = width / height;
				if (width > height) {
					if (height < this.mMinimumPanelSize.height) {
						this.mDefaultPanelSize = this.mMinimumPanelSize;
					} else {
						var displayHeight = this.mDefaultPanelSize.height;
						var displayWidth = (displayHeight * ratio);
						this.mDefaultPanelSize = {
							'width': displayWidth,
							'height': displayHeight + 27
						}
					}
				}
			}
		}
		// Position the quicklook panel over the anchor before animating.
		this.mAnchorElement = $(inAnchorElement);
		this.mPreviewPanel.setStyle(this.calculateStartStateForAnimation(this.mAnchorElement, this.mDefaultPanelSize));
		this.mPreviewPanel.show();
		// If we're not on an animation-capable browser, bail.
		if (!browser().isWebKit()) return this.showPreviewPanelAnimationDidFinish();
		// Otherwise, observe animation events and animate by removing the scale and updating
		// the opacity. We delay by 100ms to work around <rdar://problem/5639768>.
		if (browser().isWebKit()) {
			Event.stopObserving(this.mPreviewPanel, 'webkitTransitionEnd');
			Event.observe(this.mPreviewPanel, 'webkitTransitionEnd', this.showPreviewPanelAnimationDidFinish);
		}
		setTimeout(function() {
			this.mPreviewPanel.setStyle({
				'opacity': 1,
				'-webkit-transform': 'scale(1.0)'
			});
		}.bind(this), 100);
	},
	showPreviewPanelAnimationDidFinish: function(inEvent) {
		if (inEvent && inEvent.propertyName && inEvent.propertyName != '-webkit-transform') return;
		if (this.mPreviewInfo && this.mPreviewInfo.isQuickLookable) return this.configurePreviewPanel(this.mPreviewInfo);
		this.mService.pollForPreviewInformation(this.mEntityGUID, this.configurePreviewPanel.bind(this));
	},
	// Hides the preview panel.
	hidePreviewPanel: function() {
		if (this.mRequestTimer) {
			clearTimeout(this.mRequestTimer);
			delete this.mRequestTimer;
		}
		if (browser().isWebKit()) {
			Event.stopObserving(this.mPreviewPanel, 'webkitTransitionEnd');
			Event.observe(this.mPreviewPanel, 'webkitTransitionEnd', this.hidePreviewPanelAnimationDidFinish);
		}
		this.mPreviewPanel.setStyle(this.calculateStartStateForAnimation(this.mAnchorElement, this.mPreviewPanel.getDimensions()));
		if (!browser().isWebKit()) this.hidePreviewPanelAnimationDidFinish();
	},
	hidePreviewPanelAnimationDidFinish: function(inEvent) {
		if (inEvent && inEvent.propertyName && inEvent.propertyName != '-webkit-transform') return;
		this.unregisterEventHandlers();
		this.mPreviewPanel.hide();
		this.mPreviewMask.hide();
		if (this.mStashedDefaultPanelSize) this.mDefaultPanelSize = this.mStashedDefaultPanelSize;
		if (this.mPreviewInfo) delete this.mPreviewInfo;
		this.mIsAudio = this.mIsVideo = this.mIsFirstRequest = this.mFullScreenMode = false;
		this.mNowShowing = false;
		globalNotificationCenter().publish(CC.QuickLook.NOTIFICATION_DID_HIDE_QUICKLOOK_PANEL);
	},
	// Configures a preview panel for a supplied hash of preview info.
	configurePreviewPanel: function(inPreviewInfo) {
		if (!inPreviewInfo || (!inPreviewInfo.isQuickLookable) || (inPreviewInfo && !inPreviewInfo.downloadURL)) {
			$('quicklook_panel_error').show();
			$('quicklook_panel_loading').hide()
			return;
		}
		// Stash the preview information away.
		this.mPreviewInfo = inPreviewInfo;
		// Is the preview pane ready?
		this.mIsPreviewPanelReady = false;
		// Should we show the thumbnail browser?
		var shouldShowThumbnailBrowser = false;
		// Should we show the rollover controls?
		var shouldShowRolloverControls = false;
		// Is the preview an audio file? Audio files are displayed at a fixed window size with
		// embedded artwork (if we have it). Videos are displayed at their actual resolution up
		// to a limit.
		if (inPreviewInfo.isAudio || inPreviewInfo.isVideo) {
			this.mIsPreviewPanelReady = true;
			var mediaPath = inPreviewInfo.downloadURL;
			var previewPanel = $('quicklook_panel_preview');
			// Override the line height values for the preview panel if we're showing a media
			// preview, since we manually, absolutely, position media content using the
			// qtMediaExpander global. 
			previewPanel.setStyle({lineHeight: 'normal'});
			if (inPreviewInfo.isAudio) {
				var media = Builder.node('div', {className: 'media audio'}, [
					Builder.node('div', { className: 'artwork'})
				]);
				var audio = Builder.node('img', {className: 'posterimg', alt: mediaPath, width: '258px', height: '16px'});
				Element.insert(media, {bottom: audio});
				Element.insert(previewPanel, {top: media});
			}
			else if (inPreviewInfo.isVideo && inPreviewInfo.size) {
				var media = Builder.node('div', {className: 'media movie'});
				var movieSize = this.mDefaultMovieSize;
				if (inPreviewInfo.size && inPreviewInfo.size.width && inPreviewInfo.size.height) movieSize = inPreviewInfo.size;
				var movie = Builder.node('img', {className: 'posterimg', alt: mediaPath, width: movieSize.width + 'px', height: movieSize.height + 'px'});
				Element.insert(media, {top: movie});
				Element.insert(previewPanel, {top: media});
			}
		}
		else {
			shouldShowRolloverControls = true;
			// If the preview is paginated, configure the preview window. We'll load the
			// actual thumbnails later.
			if (inPreviewInfo.isPaginated) {
				shouldShowThumbnailBrowser = true;
				$('quicklook_hovering_area').addClassName('paginated');
			}
			// Load the first preview image.
			var previewPath = this.mToggleFullScreenIndex ? inPreviewInfo.previewURLs[this.mToggleFullScreenIndex] : inPreviewInfo.previewURLs[0];
			var previewImageElement = Builder.node('img', {src: previewPath, id: 'quicklook_now_showing', className: inPreviewInfo.isPaginated ? ' paginated' : ''});
			var preloadedImage = new Image();
			Event.observe(preloadedImage, 'load', function() {
				this.mIsPreviewPanelReady = true;
				this.mStashedPreviewWidth = preloadedImage.width;
				this.mStashedPreviewHeight = preloadedImage.height;
				// If the preview is paginated, populate the thumbnail browser.
				if (inPreviewInfo.isPaginated) {
					var browser = $('quicklook_panel_browser');
					var thumbnailCount = inPreviewInfo.thumbnailURLs.length;
					var thumbnailPath, thumbnailElement, thumbnailImage;
					var didLoadThumbnail = function(inEvent) {
						var thumbnailImage = inEvent.element();
						var thumbnail = thumbnailImage.up('.thumbnail');
						thumbnail.removeClassName('loading');
						if ($$('.thumbnail.loading').length == 0) {
							var browser = $('quicklook_panel_browser')
							var first = browser.down('.thumbnail');
							var selected = browser.down('.thumbnail.selected');
							if (selected && selected != first) this.scrollToThumbnail(selected, browser);
						}
					}.bind(this);
					for (var thumbnailIdx = 0; thumbnailIdx < thumbnailCount; thumbnailIdx++) {
						thumbnailPath = inPreviewInfo.thumbnailURLs[thumbnailIdx];
						thumbnailElement = Builder.node('div', {className: 'thumbnail loading'}, [
							Builder.node('div', {className: 'pagination-wrapper'}, [
								Builder.node( 'span', { className: 'pagination' }, "_QuickLook.Thumbnail.Page.Count".loc((thumbnailIdx + 1), thumbnailCount))
							])
						]);
						thumbnailImage = Builder.node('img');
						Event.observe(thumbnailElement, 'click', this.handleThumbnailClicked);
						Event.observe(thumbnailImage, 'load', didLoadThumbnail);
						if (thumbnailIdx == (this.mToggleFullScreenIndex || 0)) {
							thumbnailElement.addClassName('selected');
							thumbnailElement.down('span.pagination').show();
						}
						thumbnailImage.setAttribute('src', thumbnailPath);
						Element.insert(thumbnailElement, {'top': thumbnailImage});
						Element.insert(browser, {'bottom': thumbnailElement});
					}
					// Add thumbnail scrolling widgets (iPad-specific).
					var scrollThumbnailsUpElement = Builder.node('div', {id: 'quicklook_panel_thumbnails_scroll_up', className: 'scroller up disabled', style: 'display: none;'}, "_QuickLook.Thumbnail.Scroll.Up".loc());
					var scrollThumbnailsDownElement = Builder.node('div', {id: 'quicklook_panel_thumbnails_scroll_down', className: 'scroller down', style: 'display: none;'}, "_QuickLook.Thumbnail.Scroll.Down".loc());
					Element.insert(browser, {'after': scrollThumbnailsUpElement});
					Element.insert(browser, {'after': scrollThumbnailsDownElement});
					Event.observe(scrollThumbnailsUpElement, 'click', this.handleThumbnailScrollUpClick);
					Event.observe(scrollThumbnailsDownElement, 'click', this.handleThumbnailScrollDownClick);						
				}
			}.bind(this));
			preloadedImage.src = previewImageElement.src = previewPath;
			var previewPanel = $('quicklook_panel_preview');
			Element.insert(previewPanel, {top: previewImageElement});
		}
		// Add a title to the window.
		var titleElement = Builder.node('h3', {className: 'title', style: 'display: none;'}, [
			unescape(inPreviewInfo.title)
		]);
		var iconPath = inPreviewInfo.thumbnailURLs.length > 0 ? inPreviewInfo.thumbnailURLs[0] : undefined;
		if (iconPath) Element.insert(titleElement, {'top': Builder.node('img', {className: 'icon', src: iconPath})});
		var titlePanel = $('quicklook_panel_title');
		titlePanel.innerHTML = "";
		titlePanel.appendChild(titleElement);
		// Make the quicklook panel resizeable, if needed.
		if (!inPreviewInfo.isAudio) this.makePreviewPanelResizeable();
		// Make the preview panable if it needs to be.
		if (!inPreviewInfo.isAudio || !inPreviewInfo.isVideo) {
			this.renderRolloverControls();
			this.makePreviewPanable();
		}
		// Update any child elements.
		this.updatePreviewPanelChildElementsAfterResize(this.mPreviewPanel.getHeight());
		// Purposely delay hiding the loading panel for (at least) 500ms.
		var showPreviewAfterLoading = function() {
			// If the preview still isn't ready, show a loading spinner for another 0.5s.
			if (!this.mIsPreviewPanelReady) {
				this.mShowPreviewPanelTimer = setTimeout(showPreviewAfterLoading, this.mPreloadingDelay);
				return;
			}
			var loading = $('quicklook_panel_loading');
			if (loading) loading.hide();
			var title = $('quicklook_panel_title').down('.title');
			if (title) title.show();
			var browser = $('quicklook_panel_browser');
			if (browser && shouldShowThumbnailBrowser) {
				browser.show();
				var up = $('quicklook_panel_thumbnails_scroll_up');
				if (up) up.show();
				var down = $('quicklook_panel_thumbnails_scroll_down');
				if (down) down.show();
			}
			var panel = $('quicklook_panel_preview')
			if (panel) {
				panel.show();
				panel.focus();
			}
			var rollover = $('quicklook_hud');
			if (rollover && shouldShowRolloverControls) rollover.show();
			// If we're showing a media preview, auto-play and adjust the preview window to fit.
			if (inPreviewInfo && (inPreviewInfo.isAudio || inPreviewInfo.isVideo)) {
				var posterimg = panel.down('img.posterimg');
				if (posterimg) qtMediaExpander().expandPosterImage(posterimg, "transparent");
				this.resizeMediaPreview();
			}
			// Detect horizontally or vertically challenged previews
			var w = this.mStashedPreviewWidth;
			var h = this.mStashedPreviewHeight;
			var isPreviewSuperThin = h > w ? (w/h < 0.7) : (h/w < 0.7);
			delete this.mStashedPreviewHeight;
			delete this.mStashedPreviewWidth;
			// Are we toggling full-screen?
			if (this.mToggleFullScreenIndex != undefined || isPreviewSuperThin) {
				this.toggleFullScreenMode();
				delete this.mToggleFullScreenIndex;
			}
		}.bind(this);
		this.mShowPreviewPanelTimer = setTimeout(showPreviewAfterLoading, this.mPreloadingDelay);
		this.mNowShowing = true;
		globalNotificationCenter().publish(CC.QuickLook.NOTIFICATION_DID_SHOW_QUICKLOOK_PANEL);
	},
	calculateStartStateForAnimation: function(inAnchorElement, inPreviewPanelDimensions) {
		var anchorElement = $(inAnchorElement);
		var anchorOffset = anchorElement.viewportOffset();
		// Calculate the position of the preview panel once we show it.
		var centerX = anchorOffset.left + Math.floor(anchorElement.getWidth() / 2);
		var centerY = anchorOffset.top + Math.floor(anchorElement.getHeight() / 2);
		var newPosition = this.calculateCenterPositionForDimensions({ 'width': inPreviewPanelDimensions.width, 'height': inPreviewPanelDimensions.height});
		// So that the preview panel appears to animate from the anchor element, calculate top and
		// left pixel adjustment values and translate the scaled preview before animating.
		var targetLeft = Math.floor(centerX - (inPreviewPanelDimensions.width / 2));
		var targetTop = Math.floor(centerY - (inPreviewPanelDimensions.height / 2));
		var translateX = Math.abs(newPosition.left - targetLeft) / this.mScaleFactor;
		if (newPosition.left > targetLeft) translateX = translateX * (-1);
		var translateY = Math.abs(newPosition.top - targetTop) / this.mScaleFactor;
		if (newPosition.top > targetTop) translateY = translateY * (-1);
		var frame = {
			'opacity': browser().isWebKit() ? 0 : 1.0,
			'width': inPreviewPanelDimensions.width + 'px',
			'height': inPreviewPanelDimensions.height + 'px',
			'left': newPosition.left + 'px',
			'top': newPosition.top + 'px'
		};
		// If we're on WebKit, sprinkle some animation dust.
		if (browser().isWebKit()) frame['-webkit-transform'] = 'scale(' + this.mScaleFactor + ') translateX(' + translateX + 'px) translateY(' + translateY + 'px)';
		// Return the frame.
		return frame;
	},
	// Given a set of preview window dimensions, calculates a viewport-centered position.
	// Returns a hash of top/left width/height values.
	calculateCenterPositionForDimensions: function(inDimensions) {
		if (!inDimensions || !inDimensions.width || !inDimensions.height ) return true;
		var newLeft = (document.viewport.getWidth() / 2) - (inDimensions.width / 2);
		var newTop = ((document.viewport.getHeight() / 2) + document.viewport.getScrollOffsets().top) - (inDimensions.height / 2);
		if (newLeft < this.mFullScreenBoundary) newLeft = this.mFullScreenBoundary;
		if (newTop < this.mFullScreenBoundary) newTop = this.mFullScreenBoundary;
		return {'left': newLeft, 'top': newTop};
	},
	calculateFullScreenWidthHeightLeftTop: function() {
		var maxWidth = (d.viewport.getWidth() - (2 * this.mFullScreenBoundary));
		var maxHeight = (d.viewport.getHeight() - (2 * this.mFullScreenBoundary));
		// If the preview is not audio or video, ignore any aspect ratio and fit the browser.
		if (this.mPreviewInfo && (!this.mPreviewInfo.isAudio && !this.mPreviewInfo.isVideo)) {
			return {'width': maxWidth, 'height': maxHeight, 'left': this.mFullScreenBoundary, 'top': this.mFullScreenBoundary};
		}
		// If the window is taller than it is wider, calculate a height value
		// that is proportionate to the max width. If the window is wider than it
		// is taller, do the opposite.
		if (maxWidth < this.mDefaultPanelSize.width) maxWidth = this.mDefaultPanelSize.width;
		if (maxHeight < this.mDefaultPanelSize.height) maxHeight = this.mDefaultPanelSize.height;
		var newWidth = maxWidth;
		var newHeight = maxHeight;
		if (maxWidth <= maxHeight) {
			var widthScaleFactor = newWidth / this.mDefaultPanelSize.width;
			newHeight = Math.round(this.mDefaultPanelSize.height * widthScaleFactor);
			// 6412724
			if (newHeight > maxHeight) {
				newHeight = maxHeight;
				widthScaleFactor = newHeight / this.mDefaultPanelSize.height;
				newWidth = Math.round(this.mDefaultPanelSize.width * widthScaleFactor);
			}
		}
		else {
			var heightScaleFactor = newHeight / this.mDefaultPanelSize.height;
			newWidth = Math.round(this.mDefaultPanelSize.width * heightScaleFactor);
			// 6412724
			if (newWidth > maxWidth) {
				newWidth = maxWidth;
				widthScaleFactor = newWidth / this.mDefaultPanelSize.width;
				newHeight = Math.round(this.mDefaultPanelSize.height * widthScaleFactor);
			}
		}
		var newLeft = (d.viewport.getWidth() / 2) - (newWidth / 2);
		var newTop = ((d.viewport.getHeight() / 2) + d.viewport.getScrollOffsets().top) - (newHeight / 2);
		if (newLeft < this.mFullScreenBoundary) newLeft = this.mFullScreenBoundary;
		if (newTop < this.mFullScreenBoundary) newTop = this.mFullScreenBoundary;
		// Return the new dimensions and position.
		return {'width': newWidth, 'height': newHeight, 'left': newLeft, 'top': newTop};
	},
	// Resizes the preview panel to a given set of dimensions.
	resize: function(inDimensions) {
		if (!inDimensions || !inDimensions.width || !inDimensions.height || !inDimensions.left || !inDimensions.top ) return true;
		$('quicklook_panel').setStyle({
			'width': position.width + 'px',
			'height': position.height + 'px',
			'left': position.left + 'px',
			'top': position.top + 'px'
		});
		this.updatePreviewPanelChildElementsAfterResize(inDimensions.height);
	},
	resizeMediaPreview: function() {
		// Fudges with the width and height of media previews to compensate for quicklook
		// window paddings and the quicktime controller. Should be called any time the
		// container panel size is changed.
		var preview = $('quicklook_panel_preview');
		var media = preview.down('.media');
		if (media) {
			// 3px border on either side of the movie.
			var newWidth = preview.getWidth() - 6;
			// Audio previews are fixed at 16px tall. Movies fill the
			// height of the quicklook window (minus 21px padding for
			// the resize handle).
			var newHeight = (media.hasClassName('audio') ? 16 : preview.getHeight() - 21);
			var qtmedia = media.down('.qtmedia');
			if (qtmedia) {
				qtmedia.setStyle({
					'width': newWidth + 'px',
					'height': newHeight + 'px'
				});
			}
			var mediaChildren = media.getElementsBySelector('embed, object, video');
			mediaChildren.each(function(mediaChild) {
				mediaChild.width = newWidth;
				mediaChild.height = newHeight;
			});
		}
	},
	// Centers the preview panel in the viewport.
	centerPreviewPanel: function() {
		// If we're in fullscreen mode, stay in fullscreen mode by fitting
		// the preview window to the new browser size and redrawing the current
		// panned image.
		if (this.mFullScreenMode) {
			this.resize(this.calculateFullScreenWidthHeightLeftTop());
			this.switchPannedImage();
			if (this.mStashedPreviousPosition) {
				var updatedTopLeft = this.calculateCenterPositionForDimensions(this.mStashedPreviousPosition);
				this.mStashedPreviousPosition.top = updatedTopLeft.top;
				this.mStashedPreviousPosition.left = updatedTopLeft.left;
			}
			return true;
		}
		// Otherwise, center the window at its current size (need to compensate for 
		// getDimensions oversizing the window by including the glass border in the
		// dimensions calculation).
		var dimensions = this.mPreviewPanel.getDimensions();
		dimensions.width -= 6;
		dimensions.height -= 6;
		var pos = this.calculateCenterPositionForDimensions(dimensions);
		this.mPreviewPanel.setStyle({
			'left': pos.left + 'px',
			'top': pos.top + 'px'
		});
		globalNotificationCenter().publish(CC.QuickLook.NOTIFICATION_DID_CENTER_QUICKLOOK_PREVIEW);
	},
	// Resizes the preview window.
	resize: function(inPosition) {
		if (!inPosition.width || !inPosition.height || !inPosition.left || !inPosition.top) return true;
		this.mPreviewPanel.setStyle( {
			'width': inPosition.width + 'px',
			'height': inPosition.height + 'px',
			'left': inPosition.left + 'px',
			'top': inPosition.top + 'px'
		});
		this.updatePreviewPanelChildElementsAfterResize(inPosition.height);
		globalNotificationCenter().publish(CC.QuickLook.NOTIFICATION_DID_RESIZE_QUICKLOOK_PREVIEW);
	},
	updatePreviewPanelChildElementsAfterResize: function(newPreviewPanelHeight) {
		var newContentHeight = newPreviewPanelHeight - 35 + 'px';
		$('quicklook_panel_preview').setStyle({lineHeight: ((this.mIsAudio || this.mIsVideo) ? 'normal' :  newContentHeight)});
		this.resizeMediaPreview();
	},
	handleThumbnailClicked: function(inEvent) {
		var thumbnailElement = inEvent.findElement('.thumbnail');
		this.switchDisplayedPreview(thumbnailElement);
	},
	// Handles a new thumbnail selection on the left.
	switchDisplayedPreview: function(inThumbnailElementToActivate) {
		var newThumbnail = inThumbnailElementToActivate;
		var oldThumbnail = $('quicklook_panel_browser').down('.thumbnail.selected');
		if (newThumbnail != oldThumbnail) {
			oldThumbnail.removeClassName('selected');
			newThumbnail.addClassName('selected');
			var thumbnails = $('quicklook_panel_browser').select('.thumbnail');
			var thumbnailIdx = thumbnails.indexOf(newThumbnail);
			var previews = this.mPreviewInfo.previewURLs;
			var newPreviewImagePath = (previews.length >= thumbnailIdx) ? previews[thumbnailIdx] : previews[0];
			var preloadedPreviewImage = new Image();
			var preloadingContainer = $('quicklook_panel_preview');
			// Display a preloading spinner if loading the new image takes any more than
			// 0.5s, and ensure it shows for >= 0.5s.
			this.mNewPreviewHasLoaded = false;
			this.mCanHidePreviewPreloadingSpinner = false;
			this.mPreloadingPreviewTimer = setTimeout(function() {
				setTimeout(function() {
					// Signal the spinner can hide in case we're ahead of the preload.
					this.mCanHidePreviewPreloadingSpinner = true;
					if (this.mNewPreviewHasLoaded) preloadingContainer.removeClassName('preloading');
				}.bind(this), this.mPreloadingDelay);
				preloadingContainer.addClassName('preloading');
			}.bind(this), this.mPreloadingDelay);
			var doneLoadingImage = function() {
				if (this.preloadingTimer) clearTimeout(this.preloadingTimer);
				// Signal the image has loaded in case we're ahead of the timer.
				this.mNewPreviewHasLoaded = true;
				if (this.mCanHidePreviewPreloadingSpinner) preloadingContainer.removeClassName('preloading');
				$('quicklook_now_showing').src = preloadedPreviewImage.src;
				this.switchPannedImage();
			}
			Event.observe(preloadedPreviewImage, 'load', doneLoadingImage.bind(this));
			preloadedPreviewImage.src = newPreviewImagePath;
			this.scrollToThumbnail(newThumbnail);
		}
	},
	scrollToThumbnail: function(inThumbnailElement) {
		var thumbnail = $(inThumbnailElement);
		var container = $('quicklook_panel_browser');
		if (!thumbnail || !container) return true;
		var scroller = new CC.Scroller();
		scroller.scrollToInContainer(thumbnail, container);
	},
	makePreviewPanelResizeable: function() {
		var resizeHandle = Builder.node('div', {id: 'quicklook_resizehandle'});
		resizeHandle.observe('mousedown', this.handleResizeWidgetMouseDown);
		this.mPreviewPanel.insert(resizeHandle);
	},
	handleThumbnailScrollUpClick: function(inEvent) {
		var source = inEvent.findElement('.scroller');
		if (source.hasClassName('disabled')) return;
		var container = $('quicklook_panel_browser');
		this.scrollThumbnailsBrowserInDirectionByDelta(Math.floor(container.getHeight() * 0.9), 'up');
	},
	handleThumbnailScrollDownClick: function(inEvent) {
		var source = inEvent.findElement('.scroller');
		if (source.hasClassName('disabled')) return;
		var container = $('quicklook_panel_browser');
		this.scrollThumbnailsBrowserInDirectionByDelta(Math.floor(container.getHeight() * 0.9), 'down');		
	},
	scrollThumbnailsBrowserInDirectionByDelta: function(inDelta, inDirection) {
		var container = $('quicklook_panel_browser');
		if (!container) return true;
		if (this.mThumbnailScrollingEffect) this.mThumbnailScrollingEffect.cancel();
		var scrollFrom = container.scrollTop;
		var scrollTo = scrollFrom + (inDelta || 0);
		if (inDirection == 'up') scrollTo = (scrollFrom - (inDelta || 0)); 
		this.mThumbnailScrollingEffect = new Effect.Tween(container,
			scrollFrom,
			scrollTo,
			{duration: 0.4, afterFinish: this.updateThumbnailScrollers.bind(this)},
			function(p) { container.scrollTop = p.round(); }
		);
	},
	updateThumbnailScrollers: function() {
		var container = $('quicklook_panel_browser');
		var up = $('quicklook_panel_thumbnails_scroll_up');
		var down = $('quicklook_panel_thumbnails_scroll_down');
		(container.scrollTop <= 0) ? up.addClassName('disabled') : up.removeClassName('disabled');
		(container.scrollTop >= (container.scrollHeight - container.getHeight())) ? down.addClassName('disabled') : down.removeClassName('disabled');
	},
	handleResizeWidgetMouseDown: function(inEvent) {
		Event.stop(inEvent);
		var dragcanvas = Builder.node('div', {id:'quicklook_dragcanvas'});
		var dragoutline = Builder.node('div', {id: 'quicklook_dragoutline'});
		Element.insert(this.mPreviewPanel, {after: dragcanvas});
		Element.insert(this.mPreviewPanel, {after: dragoutline});
		dragoutline.setStyle({
			'width': this.mPreviewPanel.getStyle('width'),
			'height': this.mPreviewPanel.getStyle('height'),
			'left': this.mPreviewPanel.getStyle('left'),
			'top': this.mPreviewPanel.getStyle('top')
		});
		var offset = Element.cumulativeOffset(this.mPreviewPanel);
		this.mMouseDownPosition.x = offset.left + this.mPreviewPanel.getWidth();
		this.mMouseDownPosition.y = offset.top + this.mPreviewPanel.getHeight();
		dragcanvas.observe('mousemove', this.handleResizeWidgetMouseDrag);
		// 6405528
		Event.observe(document, 'mouseup', this.handleResizeWidgetEndMouseDrag);
		// 6417450
		Event.stopObserving(document, 'keydown', this.handleWindowKeyboardEvent);
	},
	handleResizeWidgetMouseDrag: function(inEvent) {
		Event.stop(inEvent);
		var dragoutline = $('quicklook_dragoutline');
		var oldPosition = {
			'left': Position.cumulativeOffset(dragoutline).left,
			'top': Position.cumulativeOffset(dragoutline).top,
			'width': dragoutline.getWidth(),
			'height': dragoutline.getHeight()
		};
		// Calculate delta for the mouse gesture we just tracked.
		var delta = {'x': inEvent.pointerX() - this.mMouseDownPosition.x, 'y': inEvent.pointerY() - this.mMouseDownPosition.y};
		// Calculate the new dimensions and position so that we maintain the
		// aspect ratio of the window.
		var newWidth = oldPosition.width + delta.x;
		var widthScaleFactor = newWidth / this.mDefaultPanelSize.width;
		var newHeight = Math.round(this.mDefaultPanelSize.height * widthScaleFactor);
		// Constrain to minimum and maximum bounds.
		if (newWidth < this.mDefaultPanelSize.width) {
			newWidth = this.mDefaultPanelSize.width;
			newHeight = this.mDefaultPanelSize.height;
		}
		if (newWidth > (d.viewport.getWidth() - (2 * this.mFullScreenBoundary))) return;
		if (newHeight > (d.viewport.getHeight() - (2 * this.mFullScreenBoundary))) return;
		// Update the positioning given the new dimensions.
		var newLeft = (d.viewport.getWidth() / 2) - (newWidth / 2);
		var newTop = ((d.viewport.getHeight() / 2) + d.viewport.getScrollOffsets().top) - (newHeight / 2);
		// Update the drag outline.
		dragoutline.setStyle({
			'width': newWidth + 'px',
			'left': newLeft + 'px',
			'height': newHeight + 'px',
			'top': newTop + 'px'
		});
		this.mMouseDownPosition.x = newLeft + newWidth;
		this.mMouseDownPosition.y = newTop + newHeight;
	},
	handleResizeWidgetEndMouseDrag: function(inEvent) {
		Event.stop(inEvent);
		var dragcanvas = $('quicklook_dragcanvas');
		if (!dragcanvas) return true;
		Element.remove(dragcanvas);
		// Resize the quicklook panel to match the drag outline.
		var dragoutline = $('quicklook_dragoutline');
		if (!dragoutline) return true;
		this.mPreviewPanel.setStyle({
			'width': dragoutline.getStyle('width'),
			'height': dragoutline.getStyle('height'),
			'left': dragoutline.getStyle('left'),
			'top': dragoutline.getStyle('top')
		});
		// Resize any content views to match the new height.
		this.updatePreviewPanelChildElementsAfterResize(parseInt(dragoutline.getStyle('height')));
		dragoutline.remove();
		// 6405528
		Element.stopObserving(document, 'mouseup', this.handleResizeWidgetEndMouseDrag);
		// 6417450
		Event.observe(document, 'keydown', this.handleWindowKeyboardEvent);
	},
	toggleFullScreenMode: function(inOptEvent) {
		if (inOptEvent) inOptEvent.stopPropagation();
		var btn = $('quicklook_hud_scale');
		if (btn.hasClassName('disabled')) return true;
		if (btn.hasClassName('fitscreen')) {
			// 6385209
			if (this.mStashedPreviousPosition) {
				this.resize(this.mStashedPreviousPosition);
				delete this.mStashedPreviousPosition;
			}
			$('quicklook_hud_scale').removeClassName('fitscreen');
			$('quicklook_hud_scale').addClassName('fullscreen');
			$('quicklook_panel_preview').removeClassName('fullscreen');
			var handle = $('quicklook_resizehandle');
			if (handle) handle.show();
			this.mFullScreenMode = false;
			globalNotificationCenter().publish(CC.QuickLook.NOTIFICATION_QUICKLOOK_DID_EXIT_FULLSCREEN_MODE);
		}
		else {
			// 6385209
			this.mStashedPreviousPosition = {
				'width': parseInt(this.mPreviewPanel.getStyle('width')),
				'height': parseInt(this.mPreviewPanel.getStyle('height')),
				'left': parseInt(this.mPreviewPanel.getStyle('left')),
				'top': parseInt(this.mPreviewPanel.getStyle('top'))
			}	
			this.resize(this.calculateFullScreenWidthHeightLeftTop());
			var handle = $('quicklook_resizehandle');
			if (handle) handle.hide();
			
			$('quicklook_panel_preview').addClassName('fullscreen');
			this.switchPannedImage();
			this.mFullScreenMode = true;
			globalNotificationCenter().publish(CC.QuickLook.NOTIFICATION_QUICKLOOK_DID_ENTER_FULLSCREEN_MODE);
		}
	},
	makePreviewPanable: function() {
		// If the preview image we're currently showing is taller or wider
		// than the default quick look panel size, enable the "expand" arrows
		// for viewing at 100%. Otherwise, dim the button and disable window
		// resizing.
		var currentImage = $('quicklook_now_showing');
		if (!currentImage || !currentImage.src) return true
		var previewImage = Element.extend(new Image());
		var callback = function() {
			var expandButton = $('quicklook_hud_scale');
			if (!expandButton) return true;
			var panX = previewImage.width > this.mDefaultPanelSize.width;
			var panY = previewImage.height > this.mDefaultPanelSize.height;
			if (panX || panY) {
				expandButton.removeClassName('disabled')
			}
			else {
				expandButton.addClassName('disabled');
				var handle = $('quicklook_resizehandle');
				if (handle) handle.remove();
			}
		};
		previewImage.observe('load', callback.bind(this));
		previewImage.src = currentImage.src;
	},
	switchPannedImage: function() {
		$('quicklook_hud_scale').removeClassName('fullscreen');
		$('quicklook_hud_scale').addClassName('fitscreen');
	},
	handleAttachmentDownloadClick: function(inEvent) {
		var href = '%@/files/download/%@'.fmt(env().root_path, this.mEntityGUID);
		window.location.href = href;
	},
	handleWindowResized: function(inEvent) {
		this.centerPreviewPanel();
	},
	handleWindowMouseDown: function(inEvent) {
		var quicklook = $('quicklook_panel');
		if (quicklook && !Position.within(quicklook, inEvent.pointerX(), inEvent.pointerY())) {
			this.hidePreviewPanel();
		}
	},
	handleWindowScrolled: function(inEvent) {
		// Allow normal scrolling inside the thumbnail browser.
		var thumbnailBrowser = inEvent.findElement('#quicklook_panel_browser');
		if (thumbnailBrowser) {
			var mouseDelta = inEvent.detail ? inEvent.detail : (-1) * (inEvent.wheelDelta / 40);
			// Are we scrolling past the top or the bottom?
			if (thumbnailBrowser.scrollTop + mouseDelta <= 0) inEvent.stop();
			if ((thumbnailBrowser.scrollTop + thumbnailBrowser.offsetHeight + mouseDelta) >= thumbnailBrowser.scrollHeight) inEvent.stop();
		}
	},
	handleKeyboardNotification: function(inMessage, inObject, inOptExtras) {
		if (!this.mNowShowing) return;
		var inEvent = Event.extend(inOptExtras.event);
		Event.stop(inEvent);
		switch (inMessage) {
			case CC.Keyboard.NOTIFICATION_DID_KEYBOARD_ESC:
				this.hidePreviewPanel();
				break;
			case CC.Keyboard.NOTIFICATION_DID_KEYBOARD_LEFT:
			case CC.Keyboard.NOTIFICATION_DID_KEYBOARD_UP:
			case CC.Keyboard.NOTIFICATION_DID_KEYBOARD_RIGHT:
			case CC.Keyboard.NOTIFICATION_DID_KEYBOARD_DOWN:
				var browser = $('quicklook_panel_browser')
				if (!browser) break;
				var selectedThumbnail = browser.down('.thumbnail.selected');
				if (!selectedThumbnail) break;
				var thumbnail = selectedThumbnail.previous('.thumbnail');
				if (inMessage == CC.Keyboard.NOTIFICATION_DID_KEYBOARD_RIGHT || inMessage == CC.Keyboard.NOTIFICATION_DID_KEYBOARD_DOWN) thumbnail = selectedThumbnail.next('.thumbnail');
				var targetThumbnail = thumbnail || selectedThumbnail;
				this.switchDisplayedPreview(targetThumbnail);
				break;
		}
	}
}
;
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.

CC.Files = CC.Files || new Object();
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.



// Notifications.

CC.Files.NOTIFICATION_FILE_DID_CHANGE = 'FILE_DID_CHANGE';
CC.Files.NOTIFICATION_DID_DOWNLOAD_FILE = 'DID_DOWNLOAD_FILE';
CC.Files.NOTIFICATION_DID_ABORT_FILE_REPLACE = 'DID_ABORT_FILE_REPLACE';
CC.Files.NOTIFICATION_DID_REPLACE_FILE = 'DID_REPLACE_FILE';
CC.Files.NOTIFICATION_REPLACE_FILE_DID_FAIL = 'REPLACE_FILE_DID_FAIL';

// File detail view.

CC.Files.FileDetailView = Class.create(CC.Mvc.View, {
	// How many preview pages shuold we load first?
	mInitialDisplayedPreviewCount: 5,
	// How many preview pages should we load per pagination?
	mPaginationCount: 5,
	// How many previews are we currently displaying?
	mCurrentDisplayedPreviewCount: 0,
	// do we render the title Element
	mRenderTitleElement: true,
	// Renders the core chrome and registers any event handlers.
	render: function() {
		// Build the icon path for this preview.
		var iconPath = this.buildIconPath();
		var titleViewElement = Builder.node('span', {}, "");
		if (this.mRenderTitleElement) {
			// Build a title view for this file and pre-render it.
			var titleView = new CC.EntityTitle.EntityTitleView({'mContent': this.mContent});
			titleView._render();
			titleView.updateDisplay(undefined, this.mContent, undefined);
			titleViewElement = titleView.$();
		}
		// Build the surrounding chrome.
		var elem = Builder.node('div', {className: 'files info loading' + (iconPath ? ' hasicon' : '')}, [
			titleViewElement,
			Builder.node('div', {className: 'detail'}, [
				Builder.node('div', {className: 'missing'}, [
					Builder.node('div', {className: 'icon'}, [
						Builder.node('img', {src: iconPath})
					]),
					Builder.node('h2', "_Files.PreviewMissing".loc())
				]),
				Builder.node('div', {className: 'previews'}),
				Builder.node('div', {className: 'pagination'}, [
					Builder.node('a', {className: 'more'})
				])
			])
		]);
		// Is the file quicklookable yet? If the quicklook is still pending, show a spinner.
		// Otherwise, if the quicklook is ready show the preview, otherwise so the no preview
		// chrome.
		var fileData = this.mContent.mRecord;
		var gotPreviewInformation = function(properties) {
			elem.removeClassName('loading');
			if (!properties || (!properties.isQuickLookable) || (properties && properties.previewURLs && properties.previewURLs.length == 0)) {
				elem.addClassName('nopreview');
				return;
			}
			var entity = properties['fileDataEntity'];
			this.mContent.mRecord = entity;
			this.renderPreviewForRange(0, this.mInitialDisplayedPreviewCount);
		}.bind(this);
		quicklook().mService.pollForPreviewInformation(fileData.dataGUID || fileData.guid, gotPreviewInformation);
		// Trigger a service_client flush so we wait for as little time as possible on a file view.
		service_client().flushQueuedServiceRequests();
		return elem;
	},
	// Renders and appends a specified amount of preview pages from a given start index
	// inside the previews container element. Displays spinners while we wait for images
	// to download, and automatically updates and localizes the pagination control.
	renderPreviewForRange: function(inStartIndex, inHowMany) {
		if (inStartIndex == undefined || inHowMany == undefined) return true;
		var fileData = this.mContent.mRecord;
		if (!fileData.isQuickLookable) return true;
		var previewCount = fileData.previewGUIDs.length;
		// Bail if we're trying to render an non-existing preview.
		if (inStartIndex > (previewCount - 1)) return true;
		// Otherwise, build our previews.
		var previewElements = new Array();
		// Define a did load callback, just removes the loading class name on the container.
		var didLoadPreview = function(inEvent) {
			var element = inEvent.element();
			if (element) element.up('.preview.loading').removeClassName('loading');
		};
		// Build a bunch of preview elements, and append to a list.
		for (var idx = inStartIndex; (idx < (inStartIndex + inHowMany)); idx++) {
			if (idx >= previewCount) break;
			var previewElement = Builder.node('div', {className: 'preview loading'}, [
				Builder.node('img'),
				Builder.node('div', {className: 'description'}, "_Files.Pagination.Page.Count".loc(idx + 1, previewCount))
			]);
			var img = previewElement.down('img');
			Event.observe(img, 'load', didLoadPreview);
			var imagePath = '%@/files/download/%@'.fmt(env().root_path, fileData.previewGUIDs[idx]);
			img.setAttribute('src', imagePath);
			Event.observe(previewElement, 'click', this.handlePreviewPageClicked);
			previewElements.push(previewElement);
			this.mCurrentDisplayedPreviewCount++;
		}
		// Update the paginator.
		var previewsLeft = Math.max(0, previewCount - (inStartIndex + inHowMany));
		var paginationString = "_Files.Pagination.Load.More".loc();
		this.mParentElement.down('.pagination .more').innerHTML = paginationString;
		if (previewsLeft == 0) this.mParentElement.down('.pagination').hide();
		// Append the previews to the document and return.
		previewElements.each(function(elem) {
			Element.insert(this.mParentElement.down('.previews'), {'bottom': elem});
		}, this);
	},
	// Returns the icon path for the content of this view.
	buildIconPath: function() {
		if (!this.mContent.mRecord.iconGUID) return "";
		return '%@/files/download/%@'.fmt(env().root_path, this.mContent.mRecord.iconGUID);
	},
	registerEventHandlers: function() {
		bindEventListeners(this, [
			'handleDownloadFileClicked',
			'handlePaginationControlClicked',
			'handlePreviewPageClicked'
		]);
		Event.observe(this.$().down('.pagination .more'), 'click', this.handlePaginationControlClicked);
	},
	handleDownloadFileClicked: function(inEvent) {
		var path = '%@/files/download/%@'.fmt(env().root_path, this.mContent.mRecord.guid);
		window.location.href = path;
		globalNotificationCenter().publish(CC.Files.NOTIFICATION_DID_DOWNLOAD_FILE);
	},
	handlePaginationControlClicked: function(inEvent) {
		this.renderPreviewForRange(this.mCurrentDisplayedPreviewCount, this.mPaginationCount);
	},
	handlePreviewPageClicked: function(inEvent) {
		// 11742434
		// Only display the preview window if the file is media on iPad.
		if (browser().isiPad() && browser().isiOS5Plus()) {
			var mediaType = (this.mContent.mRecord.mediaType || '');
			var isAudio = (mediaType.match(/audio/) != undefined);
			var isVideo = (mediaType.match(/movie|video/) != undefined);
			if (!(isAudio || isVideo)) return false;
		}
		var previews = this.mParentElement.select('.preview');
		var preview = inEvent.findElement('.preview');
		var previewIdx = previews.indexOf(preview);
		quicklook().showPreviewPanelForAttachment(inEvent.findElement('.preview'), this.mContent.mRecord.guid, (previewIdx >= 0 ? previewIdx : undefined));
	}
});


// Builds and returns a rendered inline file detail view, with event handlers already
// attached. Automatically renders the first preview thumbnail, if it exists.
CC.Files.buildInlineFileDetailView = function(inEntity, inOptShowTitle) {
	if (!inEntity) return undefined;
	// Otherwise, initialize and render a new file controller and view.
	var controller = new CC.Mvc.ObjectController({mRecord: inEntity});
	var view = new CC.Files.FileDetailView({
		'mContent': controller
	});
	if (inOptShowTitle == undefined) {
		inOptShowTitle = true;
	}
	view.mRenderTitleElement = inOptShowTitle;
	controller.mViewInstance = view;
	view._render();
	return view;
};
// Copyright (c) 2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.

/*
    dispatch.js
    A minimal kind of "GCD Lite" for use in the CalDAV library.
    
    This library does not provide actual concurrency, but it does allow you
    to serialize operations on a queue. This is used in CalDAV to simulate "pseudo-background"
    tasks. For example, when creating an event store for the current principal, the lookup
    request for the current principal is dispatched to a background queue. This allows the
    event store object to be returned immediately in a "not fully initialized" state,
    letting object methods that need full state to be delayed until everything is
    ready to run.
    
    Every attempt has been made to mimic the existing GCD API, though some
    functions have been modified to more appropriately suit JavaScript use cases.
    
    SPECIAL NOTE: if you perform an *actually* asynchronous operation inside a
    block (e.g., an Ajax call), you must dispatch_suspend before beginning the call,
    and dispatch_resume in the event handler to get the desired serial-blocking behavior.
*/

/* Class implementations */

function DispatchManager() {
    this.executionStack = [];
    this.usePostMessage = (window.postMessage != null);
	this.pauseDelay = -1;
	this.pauseHandler = null;
    
    if (this.usePostMessage) {
        this.pendingMessages = [];
        
        var self = this;
		if (browserSupportsAddEventListener()) {
	        window.addEventListener('message', function(e) {
	            if (e.source == window && e.data == '__dispatch') {
	                e.stopPropagation();
                
	                while (self.pendingMessages.length > 0) {
	                    var fn = self.pendingMessages.shift();
	                    if (fn[1] != null)
	                        fn[0].call(fn[1]);
	                    else
	                        fn[0]();
	                }
	            }
	        }, false);
		}
    }
}

DispatchManager.prototype.nextTick = function(callback, optContext) {
    if (this.usePostMessage) {
        this.pendingMessages.push([callback, optContext]);
        window.postMessage('__dispatch', '*');
    } else {
        if (optContext != null) {
            setTimeout(function() {
                callback.call(optContext);
            }, 0);
        } else {
            setTimeout(callback, 0);
        }
    }
};

DispatchManager.prototype.beginExecution = function(queue) {
    this.executionStack.push(queue);
};

DispatchManager.prototype.endExecution = function() {
    this.executionStack.pop();
};

DispatchManager.prototype.enablePauseDetection = function(callback, delay) {
	this.pauseHandler = callback;
	this.pauseDelay = delay;
};

DispatchManager.prototype.disablePauseDetection = function() {
	this.pauseHandler = null;
	this.pauseDelay = -1;
};

var __dispatch_manager = new DispatchManager();

function DispatchQueue(label) {
    this.label = label;
    this.tasks = [];
    this.executing = false;
    this.suspendCount = 0;
	this.pauseTimeout = null;
}

DispatchQueue.prototype.dispatch = function(callback) {
    // add this to the end of the queue
    this.tasks.push(callback);
    if (!this.executing)
        __dispatch_manager.nextTick(this.execute, this);
};

DispatchQueue.prototype.dispatchNext = function(callback) {
    // add this to the front of the queue
    this.tasks.unshift(callback);
    if (!this.executing)
        __dispatch_manager.nextTick(this.execute, this);
};

DispatchQueue.prototype.execute = function() {
    if (this.suspendCount > 0)
        return;
    
    this.executing = true;
    __dispatch_manager.beginExecution(this);
    
    while (this.tasks.length > 0) {
        this.tasks.shift()();
        if (this.suspendCount > 0)
            break;
    }
    
    __dispatch_manager.endExecution();
    this.executing = false;
};

DispatchQueue.prototype.suspend = function() {
    if (this.suspendCount++ == 0 && __dispatch_manager.pauseHandler !== null) {
		var queue = this;
    	this.pauseTimeout = setTimeout(function(){
    		if (__dispatch_manager.pauseHandler !== null)
				__dispatch_manager.pauseHandler.call(queue, queue);
    	}, __dispatch_manager.pauseDelay);
	}
};

DispatchQueue.prototype.resume = function() {
    if (--this.suspendCount <= 0) {
        this.suspendCount = 0;
        if (!this.executing)
            __dispatch_manager.nextTick(this.execute, this);
		
		if (this.pauseTimeout !== null) {
			clearTimeout(this.pauseTimeout);
			this.pauseTimeout = null;
		}
    }
};

/* Creating and Managing Queues */
function dispatch_queue_create(label) {
    return new DispatchQueue(label);
}

function dispatch_get_current_queue() {
    if (__dispatch_manager.executionStack.length == 0)
        return null;
    
    return __dispatch_manager.executionStack[__dispatch_manager.executionStack.length - 1];
}

function dispatch_queue_get_label(queue) {
    return queue.label;
}

/* Queuing Tasks for Dispatch */
function dispatch_async(queue, callback) {
    queue.dispatch(callback);
}

// Note: we can't wait() because JavaScript is single-threaded; this just does async
function dispatch_sync(queue, callback) {
    if (console && console.warn)
        console.warn('dispatch_sync is unavailable, performing dispatch_async instead');
    
    dispatch_async(queue, callback);
}

function dispatch_after(delay, queue, callback) {
    setTimeout(function() {
        queue.dispatchNext(callback);
    }, delay);
}

// This takes an optional continuation block to be called when all iterations are done
function dispatch_apply(iterations, queue, callback, continuation) {
    dispatch_async(queue, function() {
        for (var i = 0; i < iterations; i++)
            callback(i);
        
        if (typeof(continuation) === 'function')
            __dispatch_manager.nextTick(continuation);
    });
}

/* Suspending and resuming */
function dispatch_suspend(queue) {
    queue.suspend();
}

function dispatch_resume(queue) {
    queue.resume();
}

/* Debugging */
function dispatch_enable_pause_detection(callback, delay) {
	__dispatch_manager.enablePauseDetection(callback, delay);
}

function dispatch_disable_pause_detection() {
	__dispatch_manager.disablePauseDetection();
}
;
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.

// Global pages controller. Handles creating new pages (and blog posts).

CC.PagesController = Class.createWithSharedInstance('globalPagesController');
CC.PagesController.prototype = {
	initialize: function() {},
	showNewPageDialog: function(inOptAnchor, inOptPageName, inOptOwnerGUID, inOptIsBlogpost, inOptCallback, inOptCancelCallback) {
		// Remove any existing new page dialogs.
		var existingDialog = $('new_page_dialog');
		var tabIndex = accessibility().requestTabIndex(CC.Accessibility.TAB_INDEX_NAME_POPUP_DIALOG_NEW_PAGE);
		if (existingDialog) Element.remove(existingDialog);
		// Draw the new page dialog.
		var pageOrBlogLocKey = (inOptIsBlogpost == true) ? "NewBlogpost" : "NewPage";
		dialogManager().drawDialog('new_page_dialog', [
			{label:'_Dialogs.%@.Label'.fmt(pageOrBlogLocKey).loc(), contents: '<input tabindex="' + tabIndex + '" role="textbox" type="text" id="new_page_dialog_title" maxlength="100"/>'},
		], "_Dialogs.%@.OK".fmt(pageOrBlogLocKey).loc(), undefined, "_Dialogs.%@.Title".fmt(pageOrBlogLocKey).loc());
		// Create a new page, and link to it.
		var callback = function() {
			dialogManager().showProgressMessage("_Dialogs.%@.Progress.Creating".fmt(pageOrBlogLocKey).loc());
			var options = {'longName': $('new_page_dialog_title').value || undefined};
			// Is the page a blog post?
			if (inOptIsBlogpost) options['isBlogpost'] = true;
			// Do we have an explicit owner?
			if (inOptOwnerGUID) options['ownerGUID'] = inOptOwnerGUID;
			// Create the page.
			var success = function(entity) {
				dialogManager().hide();
				if (entity && inOptCallback) {
					var url = CC.entityURL(entity, true);
					inOptCallback(url, (inOptPageName || entity.longName));
				}
			};
			var failure = function() {
				dialogManager().hide();
				notifier().printErrorMessage("_Dialogs.%@.Progress.Failed".fmt(pageOrBlogLocKey).loc());
			};
			server_proxy().createPageWithOptionsAndOptionalACLs(options, undefined, success, failure);
		}.bind(this);
		// Prepare the dialog.
		$('new_page_dialog_title').value = (inOptPageName || '').escapeHTML();
		// Show the dialog.
		dialogManager().show('new_page_dialog', inOptCancelCallback, callback, inOptAnchor, false, 'new_page_dialog_title', false);
	}
};
// Copyright (c) 2009-2014 Apple Inc. All Rights Reserved.
// 
// IMPORTANT NOTE: This file is licensed only for use on Apple-branded
// computers and is subject to the terms and conditions of the Apple Software
// License Agreement accompanying the package this file is a part of.
// You may not port this file to another platform without Apple's written consent.
//
// IMPORTANT NOTE: This file is licensed only for use with the Wiki Server feature
// of the Apple Software and is subject to the terms and conditions of the Apple
// Software License Agreement accompanying the package this file is part of.

























































;

